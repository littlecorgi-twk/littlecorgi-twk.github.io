<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AndroidView之PopupWindow</title>
    <url>/posts/1900f7eb.html</url>
    <content><![CDATA[<h1 id="AndroidView之PopupWindow"><a href="#AndroidView之PopupWindow" class="headerlink" title="AndroidView之PopupWindow"></a>AndroidView之PopupWindow</h1><p>因为项目中有很多地方都需要使用PopupWindow，所以特别查了一下，做了一个简单的总结，过两天就加到项目中去。</p>
<span id="more"></span>
<h1 id="PopupWindow"><a href="#PopupWindow" class="headerlink" title="PopupWindow"></a>PopupWindow</h1><p>PopupWindow，顾名思义，就是一个用来显示弹窗的组件。</p>
<h1 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h1><ol>
<li>创建PopupWindow实例</li>
<li>设置一些基本参数</li>
<li>显示PopupWindow<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PopupWindow</span> <span class="variable">window</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PopupWindow</span>(View contentView, <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">boolean</span> focusable);</span><br></pre></td></tr></table></figure>
<p>这个方法有四个参数，第一个参数是用于PopupWindow中的View，第二个参数是PopupWindow的宽度，第三个参数是PopupWindow的高度，第四个参数指定PopupWindow能否获得焦点。</p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">View</span> <span class="variable">contentView</span> <span class="operator">=</span> LayoutInflater.from(MainActivity.<span class="built_in">this</span>).inflate(R.layout.popuplayout, <span class="literal">null</span>);</span><br><span class="line"><span class="type">PopupWindwo</span> <span class="variable">window</span> <span class="operator">=</span> PopupWindow (contentView, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h1 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h1><ul>
<li>window.setBackgroundDrawable(Drawable background); 设置PopupWindow的背景</li>
<li>window.setOutsideTouchable(boolean touchable); 设置PopupWindow是否能响应外部点击事件</li>
<li>window.setTouchable(boolean touchable); 设置PopupWindow是否能响应点击事件<br>只有同时设置PopupWindow的背景和可以响应外部点击事件，它才能“真正”响应外部点击事件。</li>
</ul>
<h1 id="显示PopupWindow"><a href="#显示PopupWindow" class="headerlink" title="显示PopupWindow"></a>显示PopupWindow</h1><ul>
<li>window.showAtLocation(View parent, int gravity, int x, int y); 第一个参数是PopupWindow的父View，第二个参数是PopupWindow相对父View的位置，第三和第四个参数分别是PopupWindow相对父View的x、y偏移</li>
<li>window.showAsDropDown(View anchor, int xoff, int yoff, int gravity); 第一个参数是PopupWindow的锚点，第二和第三个参数分别是PopupWindow相对锚点的x、y偏移</li>
</ul>
<h1 id="为PopupWindow添加动画"><a href="#为PopupWindow添加动画" class="headerlink" title="为PopupWindow添加动画"></a>为PopupWindow添加动画</h1><ul>
<li>进入时动画：(context_menu_enter.xml)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;set xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration=<span class="string">&quot;@android:integer/config_shortAnimTime&quot;</span></span><br><span class="line">        android:fromXDelta=<span class="string">&quot;0&quot;</span></span><br><span class="line">        android:fromYDelta=<span class="string">&quot;100%p&quot;</span></span><br><span class="line">        android:interpolator=<span class="string">&quot;@android:anim/accelerate_decelerate_interpolator&quot;</span></span><br><span class="line">        android:toXDelta=<span class="string">&quot;0&quot;</span></span><br><span class="line">        android:toYDelta=<span class="string">&quot;0&quot;</span>/&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>退出时动画：(context_menu_exit.xml)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;set xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> &gt;</span><br><span class="line"> </span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration=<span class="string">&quot;@android:integer/config_shortAnimTime&quot;</span></span><br><span class="line">        android:fromXDelta=<span class="string">&quot;0&quot;</span></span><br><span class="line">        android:fromYDelta=<span class="string">&quot;0&quot;</span></span><br><span class="line">        android:interpolator=<span class="string">&quot;@android:anim/accelerate_decelerate_interpolator&quot;</span></span><br><span class="line">        android:toXDelta=<span class="string">&quot;0&quot;</span></span><br><span class="line">        android:toYDelta=<span class="string">&quot;100%p&quot;</span> /&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>生成style</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style name=&quot;contextMenuAnim&quot; parent=&quot;@android:style/Animation.Activity&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@anim/context_menu_enter&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowExitAnimation&quot;&gt;@anim/context_menu_exit&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>Android多线程1--Java中的阻塞队列</title>
    <url>/posts/63ab42b7.html</url>
    <content><![CDATA[<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在谈论阻塞队列之前我们先看下操作系统多线程部分一个经典的例子——生产者和消费者问题：</p>
<blockquote>
<p>现在有两个进程，一个是生产者一个是消费者，还有一个线程缓冲区。生产者主要作用就是向缓冲区中添加数据，消费者就是从缓冲区中取出数据。这个问题的核心就是如何确保生产者不会在缓冲区满了的时候还往其中添加元素，消费者不会在缓冲区空了的时候还要求取出数据。</p>
</blockquote>
<span id="more"></span>
<p>关于这个问题的解决办法我们以后再说，我们现在主要讨论线程缓冲区——阻塞队列。</p>
<h2 id="阻塞队列简介"><a href="#阻塞队列简介" class="headerlink" title="阻塞队列简介"></a>阻塞队列简介</h2><p>阻塞队列就是队列，只是在一般的队列上添加了两个条件：</p>
<ol>
<li>当队列满了的时候不允许再添加数据</li>
<li>当队列空了的时候不允许从中取数据</li>
</ol>
<p>在Java中，阻塞队列是通过<code>BlockingQueue</code>来实现的，<code>BlockingQueue</code>是<code>Java.util.concurrent</code>包下一个重要的数据结构。</p>
<h2 id="BlockingQueue的操作方法"><a href="#BlockingQueue的操作方法" class="headerlink" title="BlockingQueue的操作方法"></a>BlockingQueue的操作方法</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">抛异常</th>
<th style="text-align:center">返回特定值</th>
<th style="text-align:center">阻塞</th>
<th style="text-align:center">超时</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">插入</td>
<td style="text-align:center">add(E e)</td>
<td style="text-align:center">offer(E e)</td>
<td style="text-align:center">put(E e)</td>
<td style="text-align:center">offer(E e, long timeout, TimeUnit unit)</td>
</tr>
<tr>
<td style="text-align:center">移除</td>
<td style="text-align:center">remove()</td>
<td style="text-align:center">poll()</td>
<td style="text-align:center">take()</td>
<td style="text-align:center">poll(time, unit)</td>
</tr>
<tr>
<td style="text-align:center">检查</td>
<td style="text-align:center">element()</td>
<td style="text-align:center">peek()</td>
<td style="text-align:center">不可用</td>
<td style="text-align:center">不可用</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>解释：</p>
<ol>
<li>抛异常：如果操作无法执行，则抛出一个异常</li>
<li>特定值：如果操作无法执行，则返回一个特定的值</li>
<li>阻塞： 如果操作无法执行，则方法调用被阻塞，直到可以执行</li>
<li>超时：如果操作无法执行，则方法调用被阻塞，直到可以执行或者超过限定的时间。返回一个特定值以告知该操作是否成功(典型的是true / false)。</li>
</ol>
</blockquote>
<h2 id="Java中的各种阻塞队列"><a href="#Java中的各种阻塞队列" class="headerlink" title="Java中的各种阻塞队列"></a>Java中的各种阻塞队列</h2><p><code>Java</code>基于<code>BlockingQueue</code>给开发者提供了7个阻塞队列：</p>
<ol>
<li><code>ArrayBlockingQueue</code>：基于数组的有界阻塞队列。有界就意味着他有一个最大限度，所存储的线程的数量不能超过这个限定值。你也可以在对其初始化的时候给定这个限定值。但是由于它是基于数组所以他和数组一样，在初始化的时候限定了这个大小以后就不能改变。</li>
<li><code>LinkedBlockingQueue</code>：基于链表的阻塞队列。它内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用<code>Integer.MAX_VALUE</code>作为上限。<code>LinkedBlockingQueue</code>内部以FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。由于默认是无上限的，所以在使用他的时候，如果生产者的速度大于消费者的速度，系统内存可能会被耗尽。所以使用他一定要设置初值。</li>
<li><code>PriorityBlockingQueue</code>：支持优先级的无界队列。默认情况按照自然顺序生序排列，你可以重写<code>compateTo()</code>方法来制定元素按规定排序。</li>
<li><code>DelayQueue</code>：支持延时获取元素的无界阻塞队列。队列中的元素必须实现<code>Delayed</code>接口。</li>
<li><code>SynchromousQueue</code>：是一个特殊的队列。他不能存储任何元素，他的每一次插入操作必须等待另一个线程相应的删除操作，反之亦然。</li>
<li><code>LinkedTransferQueue</code>：基于链表的无界阻塞<code>TransferQueue</code>队列。相对于其他队列，他多了<code>transfer(E e)</code>、<code>tryTransfer(E e)</code> 和 <code>tryTransfer(E e, long timeout, TimeUnit unit)</code>方法。</li>
<li><code>LinkedBlockingDeque</code>：是一个链表结构的双向阻塞队列。可在两端入队出对。所以当多线程入队时，减少了一半的竞争。</li>
</ol>
<h2 id="阻塞队列实现原理"><a href="#阻塞队列实现原理" class="headerlink" title="阻塞队列实现原理"></a>阻塞队列实现原理</h2><p>下面我们以<code>ArrayBlockingQueue</code>源码为例，来看下阻塞队列实现原理：</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>首先就是一堆变量的定义：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The queued items */</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** items index for next take, poll, peek or remove */</span></span><br><span class="line"><span class="type">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** items index for next put, offer, or add */</span></span><br><span class="line"><span class="type">int</span> putIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Number of elements in the queue */</span></span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Concurrency control uses the classic two-condition algorithm</span></span><br><span class="line"><span class="comment"> * found in any textbook.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Main lock guarding all access */</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Condition for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span></span><br><span class="line"><span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Condition for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span></span><br><span class="line"><span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure><br><code>items</code>是存储队列元素的数组，<code>takeIndex</code>和<code>putIndex</code>分别是取数据和存数据的索引，<code>count</code>是队列中元素个数，<code>lock</code>为看一个可重入锁，<code>notEmpty</code>和<code>notFull</code>均为等待条件，由<code>loc</code>k创建。</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>接下来看下它的构造器<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>构造器有三个重载的版本，第一个构造器只有一个参数用来指定容量，第二个构造器多了一个参数来指定访问策略，第三个构造器又多了一个参数可以指定用另外一个集合进行初始化。</p>
<h3 id="数据的添加"><a href="#数据的添加" class="headerlink" title="数据的添加"></a>数据的添加</h3><p>接下来我们看看<code>BlockingQueue</code>的三个插入的方法：<code>put()</code>、<code>add()</code>和<code>offer()</code>：</p>
<ul>
<li><code>put()</code> 方法：队列满，会阻塞调用存储元素的线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 先检查e是不是空，如果空则抛异常</span></span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    <span class="comment">// 获取一个重入锁lock</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁，保证调用put方法的时候只有1个线程</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 如果线程中的元素数量是否等于当前数组的长度，如果相等则调用await方法等待，如果不相等则enqueue方法插入元素</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>add()</code>方法：实际上调用了<code>offer()</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>offer()</code>方法：成功返回true，失败返回false</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查e是否为空</span></span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    <span class="comment">// 获取重入锁lock</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果如果线程中的元素数量是否等于当前数组的长度，如果相等则调返回false，如果不相等则enqueue方法插入元素并返回true</span></span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上三个方法都调用了<code>enqueue()</code>方法。下面我们就来看看这个方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts element at current put position, advances, and signals.</span></span><br><span class="line"><span class="comment"> * Call only when holding lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    items[putIndex] = e;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length) </span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>先获取元素数组<code>items</code>，然后添加<code>putIndex</code>上，如果<code>++putIndex</code>等于<code>items</code>的长度，则证明当前这个<code>items</code>所有元素都添加进了，就让<code>putIndex</code>等于0.然后调用<code>notEmpty.signal()</code>方法唤醒正在获取元素的线程，让他们从队列中取数据。</p>
<h3 id="数据的取出"><a href="#数据的取出" class="headerlink" title="数据的取出"></a>数据的取出</h3><p>ArrayBlockingQueue的取数据方法总共也有三个方法：<code>poll()</code>、<code>take()</code>和<code>remove()</code></p>
<ul>
<li><code>poll()</code>方法：获取元素，存在返回元素e,不存在返回null</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取重入锁lock</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果元素数量等于0就返回null，否则调用dequeue()方法</span></span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="literal">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>take()</code>方法：取元素。如果队列为空,则会阻塞调用获取元素的线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 获取重入锁lock</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果线程中的元素数量是否等于0，如果相等则调用await方法等待，如果不相等则dequeue方法删除元素</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>remove()</code>方法：取元素，它是取特定的那个元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断o是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 获取重入锁lock</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果元素数量大于0，则获取items，然后便利元素，判断o是其中的哪个，然后删除那个</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> takeIndex, end = putIndex, to = (i &lt; end) ? end : items.length; ; i = <span class="number">0</span>, to = end) &#123;</span><br><span class="line">                <span class="keyword">for</span> (; i &lt; to; i++)</span><br><span class="line">                    <span class="keyword">if</span> (o.equals(items[i])) &#123;</span><br><span class="line">                        removeAt(i);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">if</span> (to == end) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>poll()</code>和<code>take()</code>两个方法都调用了<code>dequeue()</code>方法，我们就看下<code>dequeue()</code>是如何来实现的：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Extracts element at current take position, advances, and signals.</span></span><br><span class="line"><span class="comment"> * Call only when holding lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length) takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="literal">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>和上面的<code>enqueue()</code>方法类似，再次就不再赘述。</p>
<h2 id="阻塞队列的应用"><a href="#阻塞队列的应用" class="headerlink" title="阻塞队列的应用"></a>阻塞队列的应用</h2><p>前面我说过，阻塞队列主要用在生产者和消费者模式中，那下面我们就来写一个简单的小demo</p>
<blockquote>
<blockquote>
<p>这段代码来自刘望舒所著《Android进阶之光》</p>
</blockquote>
</blockquote>
<p>如果不用阻塞队列：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">queueSize</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(queueSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> test.<span class="keyword">new</span> <span class="title class_">Producer</span>();</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> test.<span class="keyword">new</span> <span class="title class_">Consumer</span>();</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;队列空，等待数据&quot;</span>);</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            queue.notify();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 每次移走队首元素</span></span><br><span class="line">                    queue.poll();</span><br><span class="line">                    queue.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;队列满，等待有空余空间&quot;</span>);</span><br><span class="line">                        queue.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        queue.notify();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 每次插入一个元素</span></span><br><span class="line">                queue.offer(<span class="number">1</span>);</span><br><span class="line">                queue.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用阻塞队列<code>ArrayBlockingQueue</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">queueSize</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> ArrayBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(queueSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BlockingQueueTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlockingQueueTest</span>();</span><br><span class="line">        BlockingQueueTest.<span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> test.<span class="keyword">new</span> <span class="title class_">Producer</span>();</span><br><span class="line">        BlockingQueueTest.<span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> test.<span class="keyword">new</span> <span class="title class_">Consumer</span>();</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.take();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Android多线程2--Java中的线程池</title>
    <url>/posts/b39fd0ab.html</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>我们在写项目经常要用到多线程。但是线程的创建和摧毁都是较消耗资源和性能的，如果你每需要一个任务就新建一个线程，那可能会在线程的创建和摧毁上浪费掉很多资源。那如果我们让线程执行任务后不摧毁，接着执行下一个任务，这样是不是就能避免这种情况了。Java1.5中提供了<code>Executor</code>框架用于把任务的提交和执行解耦，任务的执行就交给<code>Runnable</code>或者<code>Callable</code>，而<code>Executor</code>框架用于处理任务。<code>Executor</code>中最核心的成员就是<code>ThreadPoolExecutor</code>，他就是线程池核心实现类。</p>
<span id="more"></span>
<h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><p>我们现在先来看下这个方法。<br>构造器：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                        <span class="type">int</span> maximumPoolSize,markdownlint</span></span><br><span class="line"><span class="params">                        <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                        TimeUnit unit,</span></span><br><span class="line"><span class="params">                        BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                        ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                        RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们来看下这些参数：</p>
<ul>
<li><code>corePoolSize</code>：核心线程数。线程池刚创建的时候，线程数量为0，只有任务提交的时候才会创建线程。如果当前线程数量小于<code>corePoolSize</code>，则创建新线程；如果等于或者大于，则不再创建。</li>
<li><code>maximumPoolSize</code>：线程池允许创建的最大线程数。当<code>workQueue</code>满了而且线程数小于<code>maximumPoolSize</code>时，线程池仍会创建新的线程。但是如果超过了<code>maximumPoolSize</code>时，则会抛出异常。</li>
<li><code>keepAliveTime</code>：非核心线程闲置的超过时间。当线程池中线程数量大于workQueue，如果一个线程的空闲时间大于keepAliveTime，则该线程会被回收。如果任务很多，并且每个任务 的执行事件很短，则可以调大keepAliveTime来提高线程的利用率。另外，如果设置 allowCoreThreadTimeOut属性为true时，keepAliveTime也会应用到核心线程上。</li>
<li><code>timeUnit</code>：keepAliveTime参数的时间单位。可选的单位有天(DAYS)、小时(HOURS)、分钟(MINUTES)、秒(SECONDS)、毫秒(MILLISECONDS)等。</li>
<li><code>workQueue</code>：任务队列。如果当前线程数大于<code>corePoolSize</code>，则将任务添加到此任务队列中。该任务 队列是<code>BlockingQueue</code>类型的，也就是阻塞队列。</li>
<li><code>threadFactory</code>：线程工厂。可以用线程工厂给每个创建出来的线程设置名字。一般情况下无须设置该参数。</li>
<li><code>RejectedExecutionHandler</code>：饱和策略。这是当任务队列和线程池都满了时所采取的应对策略，默认是AbordPolicy，表示无法处理新任务，并抛出<code>RejectedExecutionException</code>异常。此外还有3种策略，它们分别如下:<ol>
<li><code>CallerRunsPolicy</code>：用调用者所在的线程来处理任务。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。</li>
<li><code>DiscardPolicy</code>：不能执行的任务，并将该任务删除。</li>
<li><code>DiscardOldestPolicy</code>：丢弃队列最近的任务，并执行当前的任务。</li>
</ol>
</li>
</ul>
<h1 id="线程池的处理流程"><a href="#线程池的处理流程" class="headerlink" title="线程池的处理流程"></a>线程池的处理流程</h1><p>线程池的任务处理主要分为3个步骤</p>
<ol>
<li>提交任务后，线程池先判断线程数是否达到了核心线程数<code>corePoolSize</code>。如果未达到核心线程数，则创建核心线程处理任务；否则，就执行下一步操作。</li>
<li>接着线程池判断任务队列是否满了。如果没满，则将任务添加到任务队列中；否则，就执行下一步操作。</li>
<li>接着因为任务队列满了，线程池就判断线程数是否达到了最大线程数。如果未达到，则创建非核心线程处理任务；否则，就执行饱和策略，默认会抛出<code>RejectedExecutionException</code>异常。</li>
</ol>
<p><img src="https://psb1j8lvg.bkt.clouddn.com/mweb/屏幕快照2019-06-16下午3.03.51.png" alt="线程池执行流程"></p>
<ol>
<li>如果线程池中的线程数未达到核心线程数，则创建核心线程处理任务。</li>
<li>如果线程数大于或者等于核心线程数，则将任务加入任务队列，线程池中的空闲线程会不断地从 任务队列中取出任务进行处理。</li>
<li>如果任务队列满了，并且线程数没有达到最大线程数，则创建非核心线程去处理任务。</li>
<li>如果线程数超过了最大线程数，则执行饱和策略。</li>
</ol>
<h1 id="线程池的种类"><a href="#线程池的种类" class="headerlink" title="线程池的种类"></a>线程池的种类</h1><h2 id="CachedThreadPool：可缓存线程池"><a href="#CachedThreadPool：可缓存线程池" class="headerlink" title="CachedThreadPool：可缓存线程池"></a>CachedThreadPool：可缓存线程池</h2><ol>
<li>线程数无限制</li>
<li>有空闲线程则复用空闲线程，若无空闲线程则新建线程</li>
<li>一定程序减少频繁创建/销毁线程，减少系统开销</li>
</ol>
<p>创建源码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>CachedThreadPool</code>的<code>corePoolSize</code>为0，<code>maximumPoolSize</code>设置为<code>Integer.MAX_VALUE</code>，这意味着<code>CachedThreadPool</code>没有核心线程，非核心线程是无界的。<code>keepAliveTime</code>设置为60L，则空闲线程等待新任务 的最长时间为60s。在此用了阻塞队列<code>SynchronousQueue</code>，它是一个不存储元素的阻塞队列，每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。</p>
<h2 id="FixedThreadPool：定长线程池"><a href="#FixedThreadPool：定长线程池" class="headerlink" title="FixedThreadPool：定长线程池"></a>FixedThreadPool：定长线程池</h2><ol>
<li>可控制线程最大并发数（同时执行的线程数）</li>
<li>超出的线程会在队列中等待</li>
</ol>
<p>创建源码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>FixedThreadPool</code>的<code>corePoolSize</code>和<code>maximumPoolSize</code>都设置为创建<code>FixedThreadPool</code>指定的参数<code>nThreads</code>，也就意味着<code>FixedThreadPool</code>只有核心线程，并且数量是固定的，没有非核心线程。<code>keepAliveTime</code>设置为0L意味着多余的线程会被立即终止。因为不会产生多余的线程，所以<code>keepAliveTime</code>是无效的参数。另外，任务队列采用了无界的阻塞队列<code>LinkedBlockingQueue</code>。</p>
<h2 id="ScheduledThreadPool：定长线程池"><a href="#ScheduledThreadPool：定长线程池" class="headerlink" title="ScheduledThreadPool：定长线程池"></a>ScheduledThreadPool：定长线程池</h2><p>支持定时及周期性任务执行。</p>
<p>创建源码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">int</span> corePoolSize, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以看到在创建源码中他跳转到了<code>ScheduledThreadPoolExecutor</code>的构造方法，我们继续看进去：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                                    ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">            DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>(), threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码可以看出，<code>ScheduledThreadPoolExecutor</code>的构造方法最终调用的是<code>ThreadPoolExecutor</code>的构造方法。<code>corePoolSize</code>是传进来的固定数值，<code>maximumPoolSize</code>的值是<code>Integer.MAX_VALUE</code>。因为采用的<code>DelayedWorkQueue</code>是无界的，所以<code>maximumPoolSize</code>这个参数是无效的。</p>
<h2 id="SingleThreadExecutor：单线程化的线程池"><a href="#SingleThreadExecutor：单线程化的线程池" class="headerlink" title="SingleThreadExecutor：单线程化的线程池"></a>SingleThreadExecutor：单线程化的线程池</h2><ol>
<li>有且仅有一个工作线程执行任务</li>
<li>所有任务按照指定顺序执行，即遵循队列的入队出队规则</li>
</ol>
<p>创建源码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>corePoolSize</code>和<code>maximumPoolSize</code>都为1，意味着<code>SingleThreadExecutor</code>只有一个核心线程，其他的参数都和<code>FixedThreadPool</code>一样，这里就不赘述了。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Android消息机制之Handler</title>
    <url>/posts/21eb5c30.html</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>作为一个Android开发者，Handler的大名你一定听过。做Android开发肯定离不开Handler，它通常被我们用来连通主线程和子线程。</p>
<p>可以说只要有异步的地方一定有Handler。</p>
<p>那么，你了解过为什么Handler能连通主线程和子线程吗，也就是说，你了解过Handler背后的原理吗？</p>
<p>就让本文带你了解。</p>
<h1 id="Handler的基本用法"><a href="#Handler的基本用法" class="headerlink" title="Handler的基本用法"></a>Handler的基本用法</h1><p>按照惯例，我们首先看下Handler的一般用法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Handler</span> <span class="variable">mHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里接受并处理消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送消息</span></span><br><span class="line">mHandler.sendMessage(message);</span><br><span class="line">mHandler.post(runnable);</span><br></pre></td></tr></table></figure></p>
<p>也就是创建一个Handler对象，并重写handlerMessage方法，然后在需要的时候调用sendMessage方法传入一个message对象，或者调用post方法传入一个runnable对象。</p>
<p>那么我们从他的构造方法开始看起吧。</p>
<h1 id="从Handler构造方法入手"><a href="#从Handler构造方法入手" class="headerlink" title="从Handler构造方法入手"></a>从Handler构造方法入手</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析1.1</span></span><br><span class="line">    <span class="built_in">this</span>(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分析1-1-Handler-构造方法"><a href="#分析1-1-Handler-构造方法" class="headerlink" title="分析1.1 Handler # 构造方法"></a>分析1.1 Handler # 构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析1.1：实际上调用的又是另一个构造方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="comment">// 这个变量字面意思是找到内存泄漏，</span></span><br><span class="line">        <span class="comment">// 但是整个Handler中除了这块以及定义这个变量为false之外，</span></span><br><span class="line">        <span class="comment">// 就没有其他地方使用到过这个变量了，所以这块我也不太懂这个变量是怎么变为true的</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Handler</span>&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析1.2</span></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析1.3</span></span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取对象的mQueue属性，mQueue就是MessageQueue</span></span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分析1-2-Looper-myLooper"><a href="#分析1-2-Looper-myLooper" class="headerlink" title="分析1.2 Looper # myLooper()"></a>分析1.2 Looper # myLooper()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析1.2：Looper.myLopper()</span></span><br><span class="line"><span class="comment"> * 实际上调用的是ThreadLocal的get方法，然后返回该线程的Looper对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> Looper <span class="title function_">myLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ThreadLocal是一个数据存储类，他的特别之处在于他是线程间独立的，也就是说这个线程放入到ThreadLocal的数据，其它线程是获取不到的。sThreadLocal就是获取当前线程的Looper对象。详细可见我之前的博客。</p>
<h2 id="分析1-3-Looper-prepare"><a href="#分析1-3-Looper-prepare" class="headerlink" title="分析1.3 Looper # prepare()"></a>分析1.3 Looper # prepare()</h2><p>为什么说如果mLooper为空就抛异常呢，这是因为一个Handler必须和一个Looper绑定，并且要先初始化Looper才能去初始化Handler。初始化Looper就通过Looper的prepare方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析1.3：Looper.prepare()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">    prepare(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析1.4</span></span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个方法和myLooper方法类似，就是通过ThreadLocal设置Looper。</p>
<h2 id="分析1-4-Looper-构造方法"><a href="#分析1-4-Looper-构造方法" class="headerlink" title="分析1.4 Looper # 构造方法"></a>分析1.4 Looper # 构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析1.4：Looper的构造方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Looper的构造方法是私有的，也就是说外界并不能直接创建Looper方法，必须通过Looper.prepare方法来创建Looper对象，这样也就方便了保证一个线程只能有一个Looper对象。</p>
<p>在构造方法中，我们创建了一个MessageQueue对象。这个对象就是用来存放消息的消息队列。关于MessageQueue我们后面再来讲。</p>
<h1 id="消息是如何存放的"><a href="#消息是如何存放的" class="headerlink" title="消息是如何存放的"></a>消息是如何存放的</h1><p>上面就是Handler和Looper的一个构造方式，构造完成后，我们就要关注Handler是如何把消息放入MessageQueue中的，以及是如何从MessageQueue中取出的。</p>
<p>上面我们在讲Handler的基本用法的时候，讲到过sendMessage方法和post方法。我们先来看下这两个方法：</p>
<h2 id="Handler-sendMessage-amp-post"><a href="#Handler-sendMessage-amp-post" class="headerlink" title="Handler # sendMessage() &amp; post()"></a>Handler # sendMessage() &amp; post()</h2><p>其实这块先不上具体的方法实现，先说一下他们的方法调用流程：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sendMessage()</span><br><span class="line">    -&gt; sendMessageDelayed()</span><br><span class="line">        -&gt; sendMessageAtTime()</span><br><span class="line">            -&gt; enqueueMessage()</span><br><span class="line"></span><br><span class="line">post()</span><br><span class="line">    -&gt; sendMessageDelayed()</span><br><span class="line">        -&gt; sendMessageAtTime()</span><br><span class="line">            -&gt; enqueueMessage()</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这两个方法都会调用立马调用sendMessageDelayed():<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessageDelayed</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认都传入0</span></span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析2.1</span></span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="分析2-1-Handler-sendMessageAtTime"><a href="#分析2-1-Handler-sendMessageAtTime" class="headerlink" title="分析2.1 Handler # sendMessageAtTime()"></a>分析2.1 Handler # sendMessageAtTime()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析2.1：sendMessageAtTime()</span></span><br><span class="line"><span class="comment"> * 传入参数：</span></span><br><span class="line"><span class="comment"> *     msg：需要传递的消息</span></span><br><span class="line"><span class="comment"> *     uptimeMillis：更新时间，也就是系统从开机到目前经过的时候 + delayMillis(也就是0)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="built_in">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析2.2</span></span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分析2-2-Handler-enqueueMessage"><a href="#分析2-2-Handler-enqueueMessage" class="headerlink" title="分析2.2 Handler # enqueueMessage()"></a>分析2.2 Handler # enqueueMessage()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析2.2：enqueueMessage()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    msg.target = <span class="built_in">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// -&gt;&gt; 这块就将消息存放到MessageQueue队列中去</span></span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么消息就成功的从Handler中被存入了MessageQueue，那么消息什么时候从MessageQueue中被调出来呢?</p>
<h1 id="消息是如何取出的"><a href="#消息是如何取出的" class="headerlink" title="消息是如何取出的"></a>消息是如何取出的</h1><h2 id="Looper-loop"><a href="#Looper-loop" class="headerlink" title="Looper # loop()"></a>Looper # loop()</h2><p>Looper里面有一个loop方法，我们可以看下这个方法:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的Looper对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前线程的MessageQueue</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> me.mQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...省略中间代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 从消息队列中取出一个消息</span></span><br><span class="line">        <span class="comment">// -&gt;&gt; 分析3.1</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="comment">// 如果取出的消息为空，就退出。</span></span><br><span class="line">        <span class="comment">// 但是我之前说这个循环是个死循环？</span></span><br><span class="line">        <span class="comment">// 这是因为虽然会有这个if可能会导致循环退出，但是通过next方法取出消息的时候，如果没有消息了，next方法会阻塞线程，直到有新的消息进来</span></span><br><span class="line">        <span class="comment">// 这也就意味着，一般正常的遍历MessageQueue情况下，是不会有msg==null的。</span></span><br><span class="line">        <span class="comment">// 但是如果你调用了Looper的quit或者quitSafely方法，这个时候next会返回null，就会退出循环。</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...省略中间代码</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 传给Handler去处理消息</span></span><br><span class="line">            <span class="comment">// -&gt;&gt; 分析3.2</span></span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">                observer.messageDispatched(token, msg);</span><br><span class="line">            &#125;</span><br><span class="line">            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            <span class="comment">// ...省略中间代码</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// ...省略中间代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...省略中间代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="分析3-1-MessageQueue-next"><a href="#分析3-1-MessageQueue-next" class="headerlink" title="分析3.1 MessageQueue # next()"></a>分析3.1 MessageQueue # next()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析3.1 MessageQueue.next()</span></span><br><span class="line"><span class="comment"> * 作用：</span></span><br><span class="line"><span class="comment"> *     用于取出消息队列中的下一个消息</span></span><br><span class="line"><span class="comment"> * PS：</span></span><br><span class="line"><span class="comment"> *     看到这个next你或许就应该懂了，其实这个MessageQueue并不是咱们顾名思义以为的那个Queue，其实他的实现是一个链表 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="comment">// 如果Looper已经退出（调用了dispose方法后mPtr=0）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ptr</span> <span class="operator">=</span> mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录空闲时需要处理的IdleHandler数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析3.2.1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 刷新Binder命令</span></span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用native层，如果返回了就说明可以从队列中取出一条消息</span></span><br><span class="line">        <span class="comment">// 如果消息队列中没有消息就阻塞等待，靠enqueueMessage()中最后一步调用nativeWake()来唤醒该方法</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="comment">// 得到时间-从手机开机到现在调用经过的时间</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 得到队头</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="comment">// 判断这个message是不是barrier</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="comment">// 循环遍历出第一个异步消息，如果设置了barrier，就不能再执行同步消息了，除非将barrier移除。</span></span><br><span class="line">                <span class="comment">// 但是异步消息不受影响照样执行，所以在这里要找到异步消息</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果分发时间还没到</span></span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    <span class="comment">// 更新执行时间点</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 时间到了</span></span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有其他消息了</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="comment">// 正在退出了，返回null。</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="comment">// 判断如果这是第一次循环（只有第一次循环时会小于0）并且队列为空或还没到处理第一个的时间</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                <span class="comment">// 置为阻塞状态</span></span><br><span class="line">                mBlocked = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化最少四个要被执行的IdleHandler</span></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="comment">// 开始循环执行所有的IdleHandler并根据返回值判断是否保留</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// IdleHandler只会在消息队列阻塞之前执行一次，之后再不会执行，知道下一次被调用next()。</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        <span class="comment">// 当执行了IdleHandler后，会消耗一段时间，刺死可能已经到达执行消息的时间了，所以重置该变量再重新检查时间。</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析3-2-1"><a href="#分析3-2-1" class="headerlink" title="分析3.2.1"></a>分析3.2.1</h3><p>nextPollTimeoutMillis是一个变量，用于表示时间。</p>
<ul>
<li>如果nextPollTimeoutMillis = -1，则一直会阻塞不会超时</li>
<li>如果nextPollTimeoutMillis = 0，不会阻塞，立即返回</li>
<li>如果nextPollTimeoutMillis &gt; 0，最长阻塞nextPollTimeoutMillis毫秒，如果期间有程序唤醒会立即返回</li>
</ul>
<h2 id="分析3-2-Handler-dispatchMessage"><a href="#分析3-2-Handler-dispatchMessage" class="headerlink" title="分析3.2 Handler # dispatchMessage()"></a>分析3.2 Handler # dispatchMessage()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析3.2 Handler.dispatchMessage()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">    <span class="comment">// 先查看message自己callback有没有被设置，如果有那就交给自己的callback去处理</span></span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有message自己的callback，那就看看Handler有没有callback，</span></span><br><span class="line">        <span class="comment">// 如果有，那就交给Handler的Callback去处理，</span></span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果Handler自己还没有Callback，那就Handler自己处理</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以得到以下信息：<br>处理消息的方式有3个，分别为Message自己的Callback、Handler的Callback以及Handler自己。</p>
<ol>
<li>优先级最高的是Message自己的callback，这是一个Runnable对象，我们用Handler post一个Runnable的时候，其实就是把这个Runnable赋值个一个Message对象的callback，然后把Message对象发送给MessageQueue。</li>
<li>优先级第二的是Handler自己的mCallback，在我们创建一个Handler对象的使用可以传一个Handler.Callback对象给它并实现Callback里的handleMessage(msg)方法，作为我们的消息处理方法。</li>
<li>优先级最低的是Handler自己的handleMessage(msg)方法，这也是我们最常用的消息处理方法。</li>
</ol>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p>（图片来自于<a href="https://juejin.im/post/5c74b64a6fb9a049be5e22fc#heading-7">此处</a>）<br><img src="https://cdn.littlecorgi.top/mweb/2019-11-17/15739707276639.jpg" alt=""><br><img src="https://cdn.littlecorgi.top/mweb/2019-11-17/15739710069538.jpg" alt=""></p>
<h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h1><h2 id="1-为什么说Handler可能会导致内存泄漏"><a href="#1-为什么说Handler可能会导致内存泄漏" class="headerlink" title="1. 为什么说Handler可能会导致内存泄漏"></a>1. 为什么说Handler可能会导致内存泄漏</h2><p>只要你用Android Studio，并在Activity里面用过Handler，都会注意到一个地方，就是如果你直接创建Handler对象并重写handleMessage方法的话，AS一把都会报一个warning：<br><img src="https://cdn.littlecorgi.top/mweb/2019-11-17/15739712887055.jpg" alt=""><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This Handler class should be static or leaks might occur.</span><br><span class="line"></span><br><span class="line">该处理程序类应为静态，否则可能发生泄漏</span><br></pre></td></tr></table></figure></p>
<p>就是说如果直接这样写就可能会导致内存泄漏，但是如果你在不是Activity的类里面这样写又不会报warning，这是为什么呢？</p>
<p>因为Handler允许我们发送延时消息，但是如果在延时期间，用户关闭了Activity。这时Message持有Handler，而又因为Java的特性，内部类会持有外部类，也就是说Handler会持有Activity，这样就导致Activity泄漏了。</p>
<p>解决办法就是把Handler定义为静态内部类，并在内部持有Activity的弱引用，并及时移除所有消息：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SafeHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;MainActivity&gt; ref;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SafeHandler</span><span class="params">(MainActivity activity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ref = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-为什么主线程不需要创建Looper，而且主线程的Looper不许退出"><a href="#2-为什么主线程不需要创建Looper，而且主线程的Looper不许退出" class="headerlink" title="2. 为什么主线程不需要创建Looper，而且主线程的Looper不许退出"></a>2. 为什么主线程不需要创建Looper，而且主线程的Looper不许退出</h2><p>因为在主线程创建时会自动调用Looper的prepare方法，并调用loop方法。我们就可以直接在主线程使用Handler。</p>
<p>而为什么不能退出，是因为如果Looper退出了，那么主线程就会挂掉。Android也不许你手动退出主线程的Looper。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
        <tag>ThreadLocal</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Android消息机制之ThreadLocal</title>
    <url>/posts/64f0a9f6.html</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ThreadLocal是一个线程内部的数据储存类，通过他可以在指定的线程中存储数据。数据存储以后，只有在指定的线程中可以获取到存储的数据，对于其他线程来说则无法获取。</p>
<p>在源码中是这样写的：</p>
<blockquote>
<p>This class provides thread-local variables.  These variables differ from<br>their normal counterparts in that each thread that accesses one (via its<br>{@code get} or {@code set} method) has its own, independently initialized<br>copy of the variable.  {@code ThreadLocal} instances are typically private<br>static fields in classes that wish to associate state with a thread (e.g.,<br>a user ID or Transaction ID).</p>
</blockquote>
<p>翻译过来，就是说这个类提供线程局部变量，但是他和普通变量不同，他是每个线程都有自己的一个独立初始化的变量副本。而通过<code>get()</code>和<code>set()</code>方法就能得到和设置当前线程对应的该变量的值。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>接下来我们看一下示例代码，在一个Activity的onCreate方法中写入如下代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要添加的代码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;MainActivity&quot;</span>;</span><br><span class="line">    <span class="comment">// 需要添加的代码</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Boolean&gt; mBooleanThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要添加的代码</span></span><br><span class="line">        mBooleanThreadLocal.set(<span class="literal">true</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;[Thread#main]mBooleanThreadLocal=&quot;</span> + mBooleanThreadLocal.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要添加的代码</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;Thread#1&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                mBooleanThreadLocal.set(<span class="literal">false</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;[Thread#1]mBooleanThreadLocal=&quot;</span> + mBooleanThreadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 需要添加的代码</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;Thread#2&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;[Thread#2]mBooleanThreadLocal=&quot;</span> + mBooleanThreadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据我们上面说的ThreadLocal的特性，就可以猜出应该会输出：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Thread#main]mBooleanThreadLocal=<span class="literal">true</span></span><br><span class="line">[Thread#<span class="number">1</span>]mBooleanThreadLocal=<span class="literal">false</span></span><br><span class="line">[Thread#<span class="number">2</span>]mBooleanThreadLocal=<span class="literal">null</span></span><br></pre></td></tr></table></figure></p>
<p>然后运行输出的结果，不出所料，果然和上面一样。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>一般来说，当某些数据是以线程作为作用域并且不同线程具有不同的数据副本的时候，就可以考虑使用ThreadLocal。比如对于Handler来说，它需要获取当前线程的Looper，很显然Looper的作用域就是线程并且不同线程具有不同的Looper，这个时候通过ThreadLocal就可以轻松实现Looper在线程中的存取，如果不采用ThreadLocal，那么系统就必须提供一个全局的哈希表供Handler查找指定线程的Looper，这样一来就必须提供一个类似于LooperManager的类了，但是系统并没有这么做而是选择了ThreadLocal，这就是ThreadLocal的好处。</p>
<p>另一个使用场景就是复杂逻辑下的对象传递。比如监听器的传递，有些时候一个线程中的任务过于复杂，这可能表现为函数调用栈比较深以及代码入口的多样性，在这种情况下，我们又需要监听器能够贯穿整个线程的执行过程，这个时候可以怎么做呢？其实就可以采用ThreadLocal，采用ThreadLocal可以让监听器作为线程内的全局对象而存在，在线程内部只要通过get方法就可以获取到监听器。而如果不采用ThreadLocal，那么我们能想到的可能是如下两种方法：第一种方法是将监听器通过参数的形式在函数调用栈中进行传递，第二种方法就是将监听器作为静态变量供线程访问。上述这两种方法都是有局限性的。第一种方法的问题时当函数调用栈很深的时候，通过函数参数来传递监听器对象这几乎是不可接受的，这会让程序的设计看起来很糟糕。第二种方法是可以接受的，但是这种状态是不具有可扩充性的，比如如果同时有两个线程在执行，那么就需要提供两个静态的监听器对象，如果有10个线程在并发执行呢？提供10个静态的监听器对象？这显然是不可思议的，而采用ThreadLocal每个监听器对象都在自己的线程内部存储，根据就不会有方法2的这种问题。</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>作为一个存储数据的类，关键点就在get和set方法。</p>
<h2 id="ThreadLocal-set"><a href="#ThreadLocal-set" class="headerlink" title="ThreadLocal # set"></a>ThreadLocal # set</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 实际上存储数据的结构类型</span></span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析1</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 如果存在Map就直接set，没有就创建map并set</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// -&gt;&gt; 分析2</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析1：getMap()方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="comment">// 返回传入线程的ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析2：createMap()方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个新的ThreadLocalMap并将值传入</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你调用set方法时，就会拿到当前线程并得到当前线程的ThreadLocalMap，如果map不为空，那就直接把值传入map；如果map为空那就新建一个再传值。</p>
<p>这块我们就能懂为啥ThreadLocal能只操作自己线程里面的东西了，因为所有ThreadLocal都与他线程中的ThreadLocalMap有关。</p>
<p>那我们再来看看ThreadLocalMap。</p>
<h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><h3 id="属性变量"><a href="#属性变量" class="headerlink" title="属性变量"></a>属性变量</h3><p>先来看下ThreadLocalMap的一些变量。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储数据的结构为Entry，而且key是弱引用</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// table的初始容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// table用于存储数据</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子，用于扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置负载因子，默认为当前大小的2/3</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setThreshold</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下一个索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上一个索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">prevIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ThreadLocalMap-set"><a href="#ThreadLocalMap-set" class="headerlink" title="ThreadLocalMap # set()"></a>ThreadLocalMap # set()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">// 根据哈希算法找到对应节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前位置是否有数据，如果key值相同，就替换，如果不同则找空位放数据。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">//判断key值相同否，如果是直接覆盖 （第一种情况）</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前Entry对象对应Key值为null,则清空所有Key为null的数据（第二种情况）</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上情况都不满足，直接添加（第三种情况）</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先根据key通过哈希算法得到对应的i，然后再开始从这个i开始遍历，进行判断，由于下面三个判断比较复杂，所以我们分开来讲。</p>
<h4 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h4><p>这种情况下，key值相同，就需要将value替换掉。<br><img src="https://cdn.littlecorgi.top/mweb/2019-11-08/%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5.jpg" alt="第一种情况"></p>
<h4 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h4><p>这种情况比较复杂，先看下代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line">    <span class="comment">// 先往前进行判断，看是否能找到空的节点，找到了就更新slotToExpunge</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再往后遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前i节点的key和传入的key相同，那就进行替换</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果在整个扫描过程中（包括函数一开始的向前扫描与i之前的向后扫描）</span></span><br><span class="line"><span class="comment">             * 找到了之前的无效slot则以那个位置作为清理的起点，</span></span><br><span class="line"><span class="comment">             * 否则则以当前的i作为清理起点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            <span class="comment">// 进行一次连续段的清理，再做一次启发式清理</span></span><br><span class="line">            <span class="comment">// -&gt;&gt; 分析1</span></span><br><span class="line">            <span class="comment">// -&gt;&gt; 分析2</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前的slot已经无效，并且向前扫描过程中没有无效slot，则更新slotToExpunge为当前位置</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果key在table中不存在，则在原地放一个即可</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在探测过程中如果发现任何无效slot，则做一次清理（连续段清理+启发式清理）</span></span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析1</span></span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析2</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析1：expungeStaleEntry()</span></span><br><span class="line"><span class="comment"> * 作用：把连续段内所有无效的slot都清理一遍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析2：cleanSomeSlots()</span></span><br><span class="line"><span class="comment"> * 作用：遍历删除所有位置下key==null的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">cleanSomeSlots</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// -&gt;&gt; 分析3</span></span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>示意图如下：<br><img src="https://cdn.littlecorgi.top/mweb/2019-11-08/%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5.jpg" alt="第二种情况"></p>
<h4 id="第三种情况"><a href="#第三种情况" class="headerlink" title="第三种情况"></a>第三种情况</h4><p>第三种情况就是上面两种情况都不满足的情况，也就是需要插入的位置为null的时候，就直接扩大ThreadLocalMap，然后再插入：<br><img src="https://cdn.littlecorgi.top/mweb/2019-11-08/%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5.jpg" alt="第三种情况"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line"><span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line"><span class="comment">// -&gt;&gt; cleanSomeSlots见上面第二种情况的分析2</span></span><br><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析1</span></span><br><span class="line">    rehash();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析1：rehash()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// -&gt;&gt; expungeStaleEntries见上面第二种情况的分析1</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        <span class="comment">// -&gt;&gt; 分析2</span></span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析2：resize()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldLen</span> <span class="operator">=</span> oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newLen</span> <span class="operator">=</span> oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> <span class="title class_">Entry</span>[newLen];</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                e.value = <span class="literal">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadLocalMap-getEntry"><a href="#ThreadLocalMap-getEntry" class="headerlink" title="ThreadLocalMap # getEntry()"></a>ThreadLocalMap # getEntry()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// -&gt;&gt; 分析1</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析1：getEntryAfterMiss()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从当前往后一个个进行遍历，直至找到和key相等的然后返回</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadLocalMap-remove"><a href="#ThreadLocalMap-remove" class="headerlink" title="ThreadLocalMap # remove()"></a>ThreadLocalMap # remove()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            <span class="comment">// 显式断开弱引用</span></span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
        <tag>ThreadLocal</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Android编译变体</title>
    <url>/posts/9900843a.html</url>
    <content><![CDATA[<h1 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h1><p>我们都知道Android编译就是将我们自己写的Java文件编译成了.apk，但是他到底是如何将java编译成.apk的呢？</p>
<p>我们引入一张Google官方的流程图：<br><img src="https://cdn.littlecorgi.top/mweb/2020-08-16/15975726163198.jpg" alt=""></p>
<p>我们可以看到，一个APP编译的大致流程就是这样的：</p>
<ol>
<li>先将项目的源代码编译成dex文件(Android虚拟机可识别的字节码文件，至于为啥不是.class，最根本的原因就是Android并没有直接使用Java的虚拟机。并且单个dex文件可被引用的方法总数被限制为65536，如果我们的项目过于庞大超出这个限制时，可能会被打包成多个dex文件)，其中这个源代码除了我们自己写的代码之外还包括我们导入的依赖库的代码；并将其他除源文件之外比如资源文件等等所有文件都转成编译的资源。</li>
<li>APK打包器将dex文件和编译的资源组合成单个APK，不过必须先为APK签名才能将打包的应用安装在设备上。</li>
<li>APK打包器通过调试或者发布密钥库为APK签名：<ol>
<li>如果编译的版本是调试版本，打包器会使用调试密钥库为应用签名。AndroidStudio会自动使用调试密钥库配置新项目。</li>
<li>如果编译的版本是最终正式发布版本，则需要你自己提供签名信息，然后生成密钥用于打包。</li>
</ol>
</li>
<li>生成APK之前，Android首先会使用zipalign工具对应用进行优化。</li>
</ol>
<h1 id="认识Android项目结构"><a href="#认识Android项目结构" class="headerlink" title="认识Android项目结构"></a>认识Android项目结构</h1><p>一般情况下，我们在新建Android项目时，AndroidStudio会默认为我们创建一下文件：<br><img src="https://cdn.littlecorgi.top/mweb/2020-08-16/15975728777993.jpg" alt=""></p>
<p>其中最顶层是Project，而Project里面可以有多个module，module下面有sourceSet来存放我们编写的代码。<br>而我们对编译变体的操作主要就是在module的build.gradle中进行编辑。</p>
<h1 id="配置版本类型"><a href="#配置版本类型" class="headerlink" title="配置版本类型"></a>配置版本类型</h1><p>如果我们看一个AndroidStudio为我们创建的默认项目的app module的build.gradle，我们可以看到AndroidStudio默认为我们创建好的版本类型：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        minifyEnabled true</span><br><span class="line">        proguardFiles getDefaultProguardFile(&#x27;proguard-android-optimize.txt&#x27;), &#x27;proguard-rules.pro&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在buildTypes这个块中，又一个类型：release。</p>
<p>但是如果我们通过build variants进行查看的话，却会发现我们当前app这个module却又默认为debug这个类型，而如果我们打开选项框却又有debug和release两种类型。<br><img src="https://cdn.littlecorgi.top/blog/%E7%BC%96%E8%AF%91%E5%8F%98%E4%BD%931.png" alt=""></p>
<p>我们明明没有配置这个debug类型，那这为什么会有debug类型供我们选择呢？</p>
<p>这是因为Android Studio会默认为我们的应用创建一个debug类型，以供我们可以方便的对我们的app进行安装调试。</p>
<p>但是如果我们需要对debug类型进行些设置的话，我们也可以在buildType中添加debug项，然后在debug块中进行设置。比如我们想让debug的包的应用程序ID后面添加一个”debug”后缀：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        minifyEnabled true</span><br><span class="line">        proguardFiles getDefaultProguardFile(&#x27;proguard-android.txt&#x27;), &#x27;proguard-rules.pro&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    debug &#123;</span><br><span class="line">        applicationIdSuffix &quot;.debug&quot;</span><br><span class="line">        debuggable true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们如果需要生成debug的包，生成的包的应用程序ID后面就会多一个.debug的后缀。</p>
<p>除了可以设置应用程序ID之外，我们还可以设置是否生成可调式的apk(debugable)、是否启用Mutli-Dex等等(multiDexEnabled)。<br>具体buildTypes块中的可配置项，可以看此处-<a href="http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.BuildType.html">http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.BuildType.html</a></p>
<h1 id="配置产品特性"><a href="#配置产品特性" class="headerlink" title="配置产品特性"></a>配置产品特性</h1><p>创建产品特性和配置版本类型类似，也是在相应module的build.gradle中进行操作。</p>
<p>区别就是：</p>
<ol>
<li>版本类型故名思议就是打包成不同的版本以供不同类型调试的需求；而产品特性就是说我们可以根据我们应用业务上的需求将同一个项目打包成不同的产品，比方说免费版和付费版、普通版和lite版、国内版和海外版等等。</li>
<li>版本类型是在android - buildTypes中进行配置，主要是对代码编译时的处理或者优化进行配置；而产品特性是在andorid - productFlabors中进行配置，主要是用于指出我们的整个项目可以分成哪几个子项目，并且对应的子项目的特有的代码该写在哪个源集中。</li>
</ol>
<p>配置产品特性主要分两步走：flavorDimensions 和 productFlavors。</p>
<h2 id="flavorDimensions"><a href="#flavorDimensions" class="headerlink" title="flavorDimensions"></a>flavorDimensions</h2><p>这个属性主要是用来设定有哪几种类型维度。也就是说他指定的维度用于给下面的具体的产品特性进行归类。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flavorDimensions &quot;location&quot;, &quot;pay&quot;</span><br></pre></td></tr></table></figure><br>上面我就定义了两个维度，分别是</p>
<ul>
<li>区分APP投放地区的location（如果在中国投放则是CN版，如果美国投放则是US，日本投放则是JP等等）</li>
<li>区分用户是否需要付费使用的pay（基础版也就是非付费版stand和多功能版也就是付费版pro）</li>
</ul>
<h2 id="productFlavors"><a href="#productFlavors" class="headerlink" title="productFlavors"></a>productFlavors</h2><p>定义好了类型维度flavorDimensions，我们接下来就可以去定义估计的产品类型了。</p>
<p>基于我们上面定义的flavorDimensions。<br>我们首先需要location对用的类型：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flavorDimensions &quot;location&quot;, &quot;pay&quot;</span><br><span class="line"></span><br><span class="line">productFlavors &#123;</span><br><span class="line">    CN &#123;</span><br><span class="line">        dimension &quot;location&quot;</span><br><span class="line">        resConfigs &quot;zh&quot;  //让该版本的语言只支持中文</span><br><span class="line">    &#125;</span><br><span class="line">    US &#123;</span><br><span class="line">        dimension &quot;location&quot;</span><br><span class="line">        resConfigs &quot;en&quot;  //让该版本的语言只支持英文</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>这样我们就已经定义了两个属于location维度的类型，其中CN设定为只支持中文，US设定为只支持英文。这个时候在Sync一下，再打开Build Variants，就能看到如下信息：<br><img src="https://cdn.littlecorgi.top/blog/%E7%BC%96%E8%AF%91%E5%8F%98%E4%BD%932.png" alt=""></p>
<p>分别对应着我们刚刚定义好的产品特性和版本类型，对每个产品特性，都有每个类型的版本类型。</p>
<p>然后我们再对pay进行配置：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 29</span><br><span class="line">    buildToolsVersion &quot;29.0.2&quot;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        //...省略</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        //...省略</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flavorDimensions &quot;location&quot;, &quot;pay&quot;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        CN &#123;</span><br><span class="line">            dimension &quot;location&quot;</span><br><span class="line">            resConfigs &quot;zh&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        US &#123;</span><br><span class="line">            dimension &quot;location&quot;</span><br><span class="line">            resConfigs &quot;en&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        free &#123;</span><br><span class="line">            dimension &quot;pay&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        pro &#123;</span><br><span class="line">            dimension &quot;pay&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到我们在之前的基础上，又新定义了两个产品类型free和pro，他两属于pay这个类型维度。具体的区别我们可以在代码中去体现。老规矩，Sync之后看build variants：<br><img src="https://cdn.littlecorgi.top/blog/%E7%BC%96%E8%AF%91%E5%8F%98%E4%BD%933.png" alt=""></p>
<p>可以看到，现在我们的项目有8个build类型。<br>也就是我们设定的buildTypes和productFlavors排列组合组成的。</p>
<p>那这时可能会有个小问题，为什么是CNFreeDebug而不是FreeCNDebug或者DebugCNFree呢？</p>
<p>这块就涉及到一个优先级的问题。当gradle为每个编译变体或相应的APK命名时，属于较高优先级类型维度的产品特性会优先展示，然后再是较低的产品特性，最后才是版本类型。所以说，在flavorDimensions定义时，location定义在pay的前面，所以CN和US肯定在free和pro的前面。而版本类型在最后面，所以我们在buildTypes中定义的debug和release在最后面。</p>
<p>所以以上面的配置为例，我们总共有8个编译变体:<br>编译变体：[CN, US][free, pay][debug, release]</p>
<p>例如：</p>
<ul>
<li>编译变体：CN free debug</li>
<li>Apk：app-cn-free-debug.apk</li>
</ul>
<h2 id="variantFilter"><a href="#variantFilter" class="headerlink" title="variantFilter"></a>variantFilter</h2><p>有些时候，我们可能会不需要某些编译变体，这个时候variantFilter就得派上用场了。</p>
<p>我们先来看他的定义方法：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  variantFilter &#123; variant -&gt;</span><br><span class="line">      def names = variant.flavors*.name</span><br><span class="line">      // To check for a certain build type, use variant.buildType.name == &quot;&lt;buildType&gt;&quot;</span><br><span class="line">      if (names.contains(&quot;US&quot;) &amp;&amp; names.contains(&quot;free&quot;)) &#123;</span><br><span class="line">          // Gradle ignores any variants that satisfy the conditions above.</span><br><span class="line">          setIgnore(true)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上是Google官方给的例子，我就把产品特性名更改了下，简单来说就是当US和free组合在一起时，就忽略此编译变体。</p>
<h1 id="源集"><a href="#源集" class="headerlink" title="源集"></a>源集</h1><p>Android Studio 按逻辑关系将每个模块的源代码和资源分组为源集。模块的 main/ 源集包含其所有编译变体共用的代码和资源。其他源集目录是可选的，在您配置新的编译变体时，Android Studio 不会自动为您创建这些目录。不过，创建类似于 main/ 的源集有助于让 Gradle 只有在编译特定应用版本时才应使用的文件和资源井然有序：</p>
<ul>
<li>/src/main：所有的编译变体都会使用此源集</li>
<li>/src/buildType：此源集用于编写特定版本的专用代码和资源</li>
<li>/src/productFlavor：此源集用于编写特定编译类型专用的代码和资源</li>
<li>/src/productFlavorBuildType：此源集用于编写特定编译变体特定的代码和资源</li>
</ul>
<p>例如：<br>编译变体CNProRelease需要合并来自一下源集的代码和资源：</p>
<ul>
<li>/src/cnProRelease</li>
<li>/src/release</li>
<li>/src/pro</li>
<li>/src/cn</li>
<li>/src/main</li>
<li>依赖库<br>并且源集间的优先级就按从上到下的顺序排序，也就是说，cnProRelease的优先级是最高的，其次是release，其次再是产品特性，最后才是main和依赖库。所以说，如果这几个源集中有相同的变量或者资源，则以优先级高的源集中的为主。</li>
</ul>
<p>编译变体 &gt; 编译版本类型 &gt; 正式版类型 &gt; 主源集 &gt; 库依赖项</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>编译</tag>
        <tag>编译变体</tag>
      </tags>
  </entry>
  <entry>
    <title>Android网络请求1--HttpClient与HttpURLConnection</title>
    <url>/posts/eb898689.html</url>
    <content><![CDATA[<p>在早期的时候，Android上还没有像<code>Volley</code>、<code>OkHttp</code>、<code>Retrofit</code>这些优秀的开源库，如果想要使用网络请求的话，就只能自己封装<code>HttpClient</code>和<code>HttpURLConnection</code>。现在我们就来看下<code>Apache</code>的这两个类。<br><span id="more"></span></p>
<h1 id="1-HttpClient"><a href="#1-HttpClient" class="headerlink" title="1. HttpClient"></a>1. HttpClient</h1><h2 id="2-1-导入HttpClient"><a href="#2-1-导入HttpClient" class="headerlink" title="2.1 导入HttpClient"></a>2.1 导入HttpClient</h2><p>由于从Android 6.0 开始，谷歌就将HttpClient从Android中删除了，所以若现在想使用他，还得导入依赖：<br>在项目的<code>build.gradle</code>的<code>Android</code>代码块下加入依赖，示例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    useLibrary <span class="string">&#x27;org.apache.http.legacy&#x27;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-2-HttpClient的Get"><a href="#2-2-HttpClient的Get" class="headerlink" title="2.2 HttpClient的Get"></a>2.2 HttpClient的Get</h2><p>首先通过<code>DefaultHttpClient</code>来实例化一个<code>HttpClient</code>，并配置好参数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//创建HttpClient</span></span><br><span class="line"><span class="keyword">private</span> HttpClient <span class="title function_">createHttpClient</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">HttpParams</span> <span class="variable">mDefaultHttpParams</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicHttpParams</span>();</span><br><span class="line">    <span class="comment">//设置连接超时</span></span><br><span class="line">    HttpConnectionParams.setConnectionTimeout(mDefaultHttpParams, <span class="number">15000</span>);</span><br><span class="line">    <span class="comment">//设置请求超时</span></span><br><span class="line">    HttpConnectionParams.setSoTimeout(mDefaultHttpParams, <span class="number">15000</span>);</span><br><span class="line">    HttpConnectionParams.setTcpNoDelay(mDefaultHttpParams, <span class="literal">true</span>);</span><br><span class="line">    HttpProtocolParams.setVersion(mDefaultHttpParams, HttpVersion.HTTP_1_1);</span><br><span class="line">    HttpProtocolParams.setContentCharset(mDefaultHttpParams, HTTP.UTF_8);</span><br><span class="line">    <span class="comment">//持续握手</span></span><br><span class="line">    HttpProtocolParams.setUseExpectContinue(mDefaultHttpParams, <span class="literal">true</span>);</span><br><span class="line">    <span class="type">HttpClient</span> <span class="variable">mHttpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultHttpClient</span>(mDefaultHttpParams);</span><br><span class="line">    <span class="keyword">return</span> mHttpClient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接着创建<code>HttpGet</code>和<code>HttpClient</code>，请求网络并得到<code>HttpResponse</code>，并对<code>HttpResponse</code>进行处理：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">useHttpClientGet</span><span class="params">(String url)</span> &#123;</span><br><span class="line">    <span class="type">HttpGet</span> <span class="variable">mHttpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(url);</span><br><span class="line">    mHttpGet.addHeader(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">HttpClient</span> <span class="variable">mHttpClient</span> <span class="operator">=</span> createHttpClient();</span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">mHttpResponse</span> <span class="operator">=</span> mHttpClient.execute(mHttpGet);</span><br><span class="line">        <span class="type">HttpEntity</span> <span class="variable">mHttpEntity</span> <span class="operator">=</span> mHttpResponse.getEntity();</span><br><span class="line">        <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> mHttpResponse.getStatusLine().getStatusCode();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != mHttpEntity) &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">mInputStream</span> <span class="operator">=</span> mHttpEntity.getContent();</span><br><span class="line">            <span class="type">String</span> <span class="variable">respose</span> <span class="operator">=</span> converStreamToString(mInputStream);</span><br><span class="line">            Log.i(<span class="string">&quot;wangshu&quot;</span>, <span class="string">&quot;请求状态码:&quot;</span> + code + <span class="string">&quot;\n请求结果:\n&quot;</span> + respose);</span><br><span class="line">            mInputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>converStreamToString()</code>方法将请求结果转换成<code>String</code>类型：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">converStreamToString</span><span class="params">(InputStream is)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        sb.append(line + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">respose</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">    <span class="keyword">return</span> respose;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>最后开启线程访问:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        useHttpClientGet(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></p>
<h2 id="1-3-HttpClient的POST"><a href="#1-3-HttpClient的POST" class="headerlink" title="1.3 HttpClient的POST"></a>1.3 HttpClient的POST</h2><p>和GET差不多，只需要修改传递的参数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">useHttpClientPost</span><span class="params">(String url)</span> &#123;</span><br><span class="line">    <span class="type">HttpPost</span> <span class="variable">mHttpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(url);</span><br><span class="line">    mHttpPost.addHeader(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">HttpClient</span> <span class="variable">mHttpClient</span> <span class="operator">=</span> createHttpClient();</span><br><span class="line">        List&lt;NameValuePair&gt; postParams = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//要传递的参数</span></span><br><span class="line">        postParams.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;moon&quot;</span>));</span><br><span class="line">        postParams.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123&quot;</span>));</span><br><span class="line">        mHttpPost.setEntity(<span class="keyword">new</span> <span class="title class_">UrlEncodedFormEntity</span>(postParams));</span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">mHttpResponse</span> <span class="operator">=</span> mHttpClient.execute(mHttpPost);</span><br><span class="line">        <span class="type">HttpEntity</span> <span class="variable">mHttpEntity</span> <span class="operator">=</span> mHttpResponse.getEntity();</span><br><span class="line">        <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> mHttpResponse.getStatusLine().getStatusCode();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != mHttpEntity) &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">mInputStream</span> <span class="operator">=</span> mHttpEntity.getContent();</span><br><span class="line">            <span class="type">String</span> <span class="variable">respose</span> <span class="operator">=</span> converStreamToString(mInputStream);</span><br><span class="line">            Log.i(<span class="string">&quot;wangshu&quot;</span>, <span class="string">&quot;请求状态码:&quot;</span> + code + <span class="string">&quot;\n请求结果:\n&quot;</span> + respose);</span><br><span class="line">            mInputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="2-HttpURLConnection"><a href="#2-HttpURLConnection" class="headerlink" title="2. HttpURLConnection"></a>2. HttpURLConnection</h1><p><code>HttpURLConnection</code>较<code>HttpClient</code>来说更轻量，而且他<code>API</code>也比<code>HttpClient</code>简单。特别是<code>Android 6.0</code>将<code>HttpClient</code>移除之后，现在只能使用<code>HttpURLConnection</code>。</p>
<h2 id="2-1-HttpURLConnection的POST请求"><a href="#2-1-HttpURLConnection的POST请求" class="headerlink" title="2.1 HttpURLConnection的POST请求"></a>2.1 HttpURLConnection的POST请求</h2><p>首先我们创建一个UrlConnManager类，然后里面提供getHttpURLConnection()方法用于配置默认的参数并返回HttpURLConnection：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HttpURLConnection <span class="title function_">getHttpURLConnection</span><span class="params">(String url)</span>&#123;</span><br><span class="line">    HttpURLConnection mHttpURLConnection=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        URL mUrl=<span class="keyword">new</span> <span class="title class_">URL</span>(url);</span><br><span class="line">        mHttpURLConnection=(HttpURLConnection)mUrl.openConnection();</span><br><span class="line">        <span class="comment">//设置链接超时时间</span></span><br><span class="line">        mHttpURLConnection.setConnectTimeout(<span class="number">15000</span>);</span><br><span class="line">        <span class="comment">//设置读取超时时间</span></span><br><span class="line">        mHttpURLConnection.setReadTimeout(<span class="number">15000</span>);</span><br><span class="line">        <span class="comment">//设置请求参数</span></span><br><span class="line">        mHttpURLConnection.setRequestMethod(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line">        <span class="comment">//添加Header</span></span><br><span class="line">        mHttpURLConnection.setRequestProperty(<span class="string">&quot;Connection&quot;</span>,<span class="string">&quot;Keep-Alive&quot;</span>);</span><br><span class="line">        <span class="comment">//接收输入流</span></span><br><span class="line">        mHttpURLConnection.setDoInput(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//传递参数时需要开启</span></span><br><span class="line">        mHttpURLConnection.setDoOutput(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mHttpURLConnection ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为我们要发送POST请求，所以在UrlConnManager类中再写一个postParams()方法用来组织一下请求参数并将请求参数写入到输出流中：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postParams</span><span class="params">(OutputStream output,List&lt;NameValuePair&gt;paramsList)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    StringBuilder mStringBuilder=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (NameValuePair pair:paramsList)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!TextUtils.isEmpty(mStringBuilder))&#123;</span><br><span class="line">            mStringBuilder.append(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mStringBuilder.append(URLEncoder.encode(pair.getName(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        mStringBuilder.append(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">        mStringBuilder.append(URLEncoder.encode(pair.getValue(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    BufferedWriter writer=<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(output,<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    writer.write(mStringBuilder.toString());</span><br><span class="line">    writer.flush();</span><br><span class="line">    writer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来我们添加请求参数，调用postParams()方法将请求的参数组织好传给HttpURLConnection的输出流，请求连接并处理返回的结果：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">useHttpUrlConnectionPost</span><span class="params">(String url)</span> &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">mInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">HttpURLConnection</span> <span class="variable">mHttpURLConnection</span> <span class="operator">=</span> UrlConnManager.getHttpURLConnection(url);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;NameValuePair&gt; postParams = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//要传递的参数</span></span><br><span class="line">        postParams.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;moon&quot;</span>));</span><br><span class="line">        postParams.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123&quot;</span>));</span><br><span class="line">        UrlConnManager.postParams(mHttpURLConnection.getOutputStream(), postParams);</span><br><span class="line">        mHttpURLConnection.connect();</span><br><span class="line">        mInputStream = mHttpURLConnection.getInputStream();</span><br><span class="line">        <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> mHttpURLConnection.getResponseCode();</span><br><span class="line">        <span class="type">String</span> <span class="variable">respose</span> <span class="operator">=</span> converStreamToString(mInputStream);</span><br><span class="line">        Log.i(<span class="string">&quot;wangshu&quot;</span>, <span class="string">&quot;请求状态码:&quot;</span> + code + <span class="string">&quot;\n请求结果:\n&quot;</span> + respose);</span><br><span class="line">        mInputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>最后开启线程请求网络：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">useHttpUrlConnectionGetThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            useHttpUrlConnectionPost(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码</tag>
        <tag>kotlin</tag>
        <tag>Volley</tag>
      </tags>
  </entry>
  <entry>
    <title>Android网络请求2--解析Volley源码</title>
    <url>/posts/df8fd75e.html</url>
    <content><![CDATA[<blockquote>
<p>本文大篇幅参考<a href="https://www.jianshu.com/p/d8500e377f3e">此篇文章</a>，大家可以结合两篇文章看一下</p>
</blockquote>
<h1 id="1-Volley简介"><a href="#1-Volley简介" class="headerlink" title="1. Volley简介"></a>1. Volley简介</h1><p>在很早以前，如果Android开发者想使用网络请求的话，必须自己通过<code>HttpClient</code>或者<code>HttpURLConnection</code>编写代码来访问。但是他两的用法还是很复杂的，如果不适当的封装的话，就会有很多多余代码甚至效率降低。所以当时出现了很多第三方网络通信框架，但是都是第三方的，而谷歌官方一直没有作为。<br>最终在2013年，谷歌终于意识到了问题，于是他们推出了一个官方的全新的网络框架——Volley。Volley它又能非常简单的进行HTTP通信，又能轻松加载网络上的图片。他的设计目的就是应对数据量不大但是频发的网络操作，但是对于下载等需要大数据量的网络操作，他就不太适合。<br><span id="more"></span></p>
<h1 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h1><h2 id="2-1-从RequestQueue入手"><a href="#2-1-从RequestQueue入手" class="headerlink" title="2.1 从RequestQueue入手"></a>2.1 从RequestQueue入手</h2><p>如果你使用Volley的话，就会发现Volley不管进行什么操作，首先第一步就是先创建RequestQueue对象。<br>所以我们就可以认定他为Volley的入口。<br>创建RequestQueue的方法是<code>RequestQueue mQueue = Volley.newRequestQueue(getApplicationContext());</code>,我们就看看<code>newRequestQueue</code>干了什么：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title function_">newRequestQueue</span><span class="params">(Context context, BaseHttpStack stack)</span> &#123;</span><br><span class="line">    BasicNetwork network;</span><br><span class="line">    <span class="keyword">if</span> (stack == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">            network = <span class="keyword">new</span> <span class="title class_">BasicNetwork</span>(<span class="keyword">new</span> <span class="title class_">HurlStack</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在Android 2.3之前，HttpURLConnection是不可靠的。</span></span><br><span class="line">            <span class="comment">// 请参阅：http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span></span><br><span class="line">            <span class="comment">// 在将来的某个时候，我们将把minsdkversion移到Android 2.2之上，</span></span><br><span class="line">            <span class="comment">// 并可以删除这个回退（连同所有ApacheHTTP代码）。            </span></span><br><span class="line">            <span class="type">String</span> <span class="variable">userAgent</span> <span class="operator">=</span> <span class="string">&quot;volley/0&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">packageName</span> <span class="operator">=</span> context.getPackageName();</span><br><span class="line">                <span class="type">PackageInfo</span> <span class="variable">info</span> <span class="operator">=</span></span><br><span class="line">             context.getPackageManager().getPackageInfo(packageName, <span class="comment">/* flags= */</span> <span class="number">0</span>);</span><br><span class="line">                    userAgent = packageName + <span class="string">&quot;/&quot;</span> + info.versionCode;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        network =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BasicNetwork</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">HttpClientStack</span>(AndroidHttpClient.newInstance(userAgent)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        network = <span class="keyword">new</span> <span class="title class_">BasicNetwork</span>(stack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRequestQueue(context, network);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>调用方法后，先查看Android版本是否大于等于2.3，如果大于则调用基于<code>HttpURLConnection</code>的<code>HurlStack</code>，否则调用基于<code>HttpClient</code>的<code>HttpClientStack</code>。接下来创建<code>BasicNetwork</code>并调用<code>newRequestQueue(context, network)</code>方，我们再来看看这个<code>newRequestQueue()</code>方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RequestQueue <span class="title function_">newRequestQueue</span><span class="params">(Context context, Network network)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Context</span> <span class="variable">appContext</span> <span class="operator">=</span> context.getApplicationContext();</span><br><span class="line">    <span class="comment">// 对缓存目录使用惰性供应商，以便可以在主线程上调用newRequestQueue（），</span></span><br><span class="line">    <span class="comment">// 而不会导致严格的模式冲突。    </span></span><br><span class="line">    DiskBasedCache.<span class="type">FileSupplier</span> <span class="variable">cacheSupplier</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DiskBasedCache</span>.FileSupplier() &#123;</span><br><span class="line">                <span class="keyword">private</span> <span class="type">File</span> <span class="variable">cacheDir</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> File <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cacheDir == <span class="literal">null</span>) &#123;</span><br><span class="line">                        cacheDir = <span class="keyword">new</span> <span class="title class_">File</span>(appContext.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> cacheDir;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">    <span class="type">RequestQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestQueue</span>(<span class="keyword">new</span> <span class="title class_">DiskBasedCache</span>(cacheSupplier), network);</span><br><span class="line">    queue.start();</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，这个方法主要为Volley创建了一个硬盘缓存<code>DiskBasedCache</code>，然后通过这个磁盘缓存和<code>Network</code>创建了一个<code>RequestQueue</code>对象，并调用了<code>start()</code>方法，接下来我们看下<code>start()</code>方法:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    stop(); </span><br><span class="line">    <span class="comment">// 确保当前运行的所有调度程序都已停止。</span></span><br><span class="line">    <span class="comment">// 创建缓存调度器并开始它。</span></span><br><span class="line">    mCacheDispatcher = <span class="keyword">new</span> <span class="title class_">CacheDispatcher</span>(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">    mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建达到池大小的网络调度程序（和相应的线程）。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        <span class="type">NetworkDispatcher</span> <span class="variable">networkDispatcher</span> <span class="operator">=</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">NetworkDispatcher</span>(mNetworkQueue, mNetwork, mCache, mDelivery);</span><br><span class="line">        mDispatchers[i] = networkDispatcher;</span><br><span class="line">        networkDispatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>CacheDispatcher</code>是一个缓存调度线程，并调用了<code>start()</code>方法。在循环中调用<code>NetworkDispatcher</code>的<code>start()</code>方法。<code>NetworkDispatcher</code>是网络调度线程，默认情况下<code>mDispatchers.length</code>为4，默认开启了4个调度线程，外加1个缓存调度线程，总共5个线程。<br>接下来Volley会创建各种<code>Request</code>，并调用<code>RequestQueue</code>的<code>add()</code>方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Request&lt;T&gt; <span class="title function_">add</span><span class="params">(Request&lt;T&gt; request)</span> &#123;</span><br><span class="line">    <span class="comment">// 将请求标记为属于此队列，并将其添加到当前请求集。</span></span><br><span class="line">    request.setRequestQueue(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</span><br><span class="line">        <span class="comment">//mCurrentRequests是一个HashSet</span></span><br><span class="line">        mCurrentRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按添加的顺序处理请求。</span></span><br><span class="line">    request.setSequence(getSequenceNumber());</span><br><span class="line">    request.addMarker(<span class="string">&quot;add-to-queue&quot;</span>);</span><br><span class="line">    sendRequestEvent(request, RequestEvent.REQUEST_QUEUED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求是不可执行的，跳过缓存队列，然后直接进入网络。</span></span><br><span class="line">    <span class="keyword">if</span> (!request.shouldCache()) &#123;</span><br><span class="line">        mNetworkQueue.add(request);</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line">    mCacheQueue.add(request);</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这块地方的代码就很简单了，就是根据<code>request</code>的<code>shouldCache()</code>方法来返回<code>request</code>的<code>mShouldCache</code>属性来判断是否可以缓存，默认是可以的。如果能缓存，将此请求加入<code>mCacheQueue</code>队列，不再重复请求；不可以的话就将请求加入网络请求队列<code>mNetworkQueue</code>。</p>
<h2 id="2-2-CacheDispatcher缓存调度线程"><a href="#2-2-CacheDispatcher缓存调度线程" class="headerlink" title="2.2 CacheDispatcher缓存调度线程"></a>2.2 CacheDispatcher缓存调度线程</h2><p><code>RequestQueue</code>的<code>add()</code>方法并没有请求网络或者对缓存进行操作。当将请求添加到网络请求队 列或者缓存队列时，在后台的网络调度线程和缓存调度线程轮询各自的请求队列，若发现有请求任务则开 始执行。下面先看看缓存调度线程。</p>
<p>首先先来看看<code>CacheDispatcher</code>的<code>add()</code>方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) </span><br><span class="line">        VolleyLog.v(<span class="string">&quot;start new dispatcher&quot;</span>);</span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">    <span class="comment">// Process.THREAD_PRIORITY_BACKGROUND默认值为10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行阻塞调用以初始化缓存。</span></span><br><span class="line">    mCache.initialize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            processRequest();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 可能被打断了，因为是时候要退出了。</span></span><br><span class="line">            <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            VolleyLog.e(</span><br><span class="line">                    <span class="string">&quot;Ignoring spurious interrupt of CacheDispatcher thread; &quot;</span></span><br><span class="line">                            + <span class="string">&quot;use quit() to terminate it&quot;</span>);</span><br><span class="line">            <span class="comment">// 忽略cachedispatcher线程的假中断；</span></span><br><span class="line">            <span class="comment">// 使用quit（）终止它</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这块可以看出主要就是初始化了缓存队列，然后开了个死循环，一直调用<code>processRequest()</code>，我们来看看这个方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 从CacheQueue中取出一个可用的request</span></span><br><span class="line">    <span class="keyword">final</span> Request&lt;?&gt; request = mCacheQueue.take();</span><br><span class="line">    processRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(<span class="keyword">final</span> Request&lt;?&gt; request)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    request.addMarker(<span class="string">&quot;cache-queue-take&quot;</span>);</span><br><span class="line">    request.sendEvent(RequestQueue.RequestEvent.REQUEST_CACHE_LOOKUP_STARTED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//request如果被取消了，就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">            request.finish(<span class="string">&quot;cache-discard-canceled&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Cache.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> mCache.get(request.getCacheKey());</span><br><span class="line">        <span class="comment">// 没有缓存就把request添加到NetworkQueue中</span></span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">            request.addMarker(<span class="string">&quot;cache-miss&quot;</span>);</span><br><span class="line">            <span class="comment">// 没有缓存，并且等待队列中也没有此request，那么就直接加入到NetworkQueue中</span></span><br><span class="line">            <span class="keyword">if</span> (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">                mNetworkQueue.put(request);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果缓存过期了，也是一样把request添加到NetworkQueue中</span></span><br><span class="line">        <span class="keyword">if</span> (entry.isExpired()) &#123;</span><br><span class="line">            request.addMarker(<span class="string">&quot;cache-hit-expired&quot;</span>);</span><br><span class="line">            request.setCacheEntry(entry);</span><br><span class="line">            <span class="keyword">if</span> (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">                mNetworkQueue.put(request);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有缓存并且没有过期</span></span><br><span class="line">        request.addMarker(<span class="string">&quot;cache-hit&quot;</span>);</span><br><span class="line">        <span class="comment">// 根据缓存的内容解析</span></span><br><span class="line">        Response&lt;?&gt; response =</span><br><span class="line">                request.parseNetworkResponse(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">NetworkResponse</span>(entry.data, entry.responseHeaders));</span><br><span class="line">        request.addMarker(<span class="string">&quot;cache-hit-parsed&quot;</span>);</span><br><span class="line">        <span class="comment">// 是否需要更新</span></span><br><span class="line">        <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</span><br><span class="line">            <span class="comment">// 不需要更新，直接将结果调度到主线程</span></span><br><span class="line">            mDelivery.postResponse(request, response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            request.addMarker(<span class="string">&quot;cache-hit-refresh-needed&quot;</span>);</span><br><span class="line">            request.setCacheEntry(entry);</span><br><span class="line">            response.intermediate = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 判断是否有相同缓存键的任务在执行</span></span><br><span class="line">            <span class="keyword">if</span> (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">                <span class="comment">// 需要更新结果，先将结果调度到主线程，然后执行new runnable()&#123;&#125;</span></span><br><span class="line">                <span class="comment">// runnable中就是将request添加到NetworkQueue中，更新一下内容</span></span><br><span class="line">                mDelivery.postResponse(</span><br><span class="line">                        request,</span><br><span class="line">                        response,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    mNetworkQueue.put(request);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                    <span class="comment">// Restore the interrupted status</span></span><br><span class="line">                                    Thread.currentThread().interrupt();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// request已经加入到mWaitingRequests中</span></span><br><span class="line">                <span class="comment">// 直接把结果调度到主线程</span></span><br><span class="line">                mDelivery.postResponse(request, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        request.sendEvent(RequestQueue.RequestEvent.REQUEST_CACHE_LOOKUP_FINISHED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们在<code>processRequest</code>中可以看到有一个方法经常出现，那就是<code>mWaitingRequestManager.maybeAddToWaitingRequests(request)</code>，它的作用是判断当前这个<code>request</code>是否有存在相同缓存键的请求已经处于运行状态，如果有，那么就将这个<code>request</code>加入到一个等待队列中，等到相同缓存键的请求完成。</p>
<p>总结一下<code>CacheDispatcher</code>主要步骤：</p>
<ul>
<li>从<code>CacheQueue</code>中循环取出<code>request</code>；</li>
<li>如果缓存丢失，加入到<code>NetworkQueue</code>中；</li>
<li>如果缓存过期，加入到<code>NetworkQueue</code>中；</li>
<li>将缓存中的数据解析成<code>Response</code>对象；</li>
<li>如果不需要更新，直接将结果回调到主线程，回调操作等介绍完<code>NetworkDispatcher</code>之后一起深入剖析；</li>
<li>如果需要更新，先将结果回调到主线程，然后再将<code>request</code>加入到<code>NetworkQueue</code>中。</li>
</ul>
<p>下面来看看网络调度线程。</p>
<h2 id="2-3-NetWorkDispatcher网络调度线程"><a href="#2-3-NetWorkDispatcher网络调度线程" class="headerlink" title="2.3 NetWorkDispatcher网络调度线程"></a>2.3 NetWorkDispatcher网络调度线程</h2><p>NetworkDispatcher的run方法代码如下所示:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            processRequest();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 我们可能被打断了，因为是时候退出了。</span></span><br><span class="line">            <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            VolleyLog.e(</span><br><span class="line">                    <span class="string">&quot;Ignoring spurious interrupt of NetworkDispatcher thread; &quot;</span></span><br><span class="line">                            + <span class="string">&quot;use quit() to terminate it&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由此可以看出，<code>NetWordDispatch</code>和<code>CacheDispatch</code>非常类似。<br>他的<code>run()</code>方法和<code>CacheDispatch</code>的方法基本一样，这就不多做介绍，下面来看看他的<code>processRequest()</code>方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 从NetworkQueue中取出request</span></span><br><span class="line">    Request&lt;?&gt; request = mQueue.take();</span><br><span class="line">    processRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(Request&lt;?&gt; request)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTimeMs</span> <span class="operator">=</span> SystemClock.elapsedRealtime();</span><br><span class="line">    request.sendEvent(RequestQueue.RequestEvent.REQUEST_NETWORK_DISPATCH_STARTED);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        request.addMarker(<span class="string">&quot;network-queue-take&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果request被取消了，那么就不执行此request</span></span><br><span class="line">        <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">            request.finish(<span class="string">&quot;network-discard-cancelled&quot;</span>);</span><br><span class="line">            request.notifyListenerResponseNotUsable();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addTrafficStatsTag(request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还记得这个mNetwork么，它就是Volley.newRequestQueue()方法里的BasicNetwork对象，一会我们来看看mNetwork.performRequest()方法是如何得到NetworkResponse的</span></span><br><span class="line">        <span class="type">NetworkResponse</span> <span class="variable">networkResponse</span> <span class="operator">=</span> mNetwork.performRequest(request);</span><br><span class="line">        request.addMarker(<span class="string">&quot;network-http-complete&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// notModified是服务端返回304，hasHadResponseDelivered()是request已经回调过了</span></span><br><span class="line">        <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class="line">            request.finish(<span class="string">&quot;not-modified&quot;</span>);</span><br><span class="line">            request.notifyListenerResponseNotUsable();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将NetworkResponse解析成Response对象，在子线程中执行</span></span><br><span class="line">        Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class="line">        request.addMarker(<span class="string">&quot;network-parse-complete&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将request写入缓存</span></span><br><span class="line">        <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">            mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">            request.addMarker(<span class="string">&quot;network-cache-written&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        request.markDelivered();</span><br><span class="line">        <span class="comment">// 回调结果至主线程</span></span><br><span class="line">        mDelivery.postResponse(request, response);</span><br><span class="line">        request.notifyListenerResponseReceived(response);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 以下都是处理异常错误，然后也需要回调至主线程</span></span><br><span class="line">    <span class="keyword">catch</span> (VolleyError volleyError) &#123;</span><br><span class="line">        volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</span><br><span class="line">        parseAndDeliverNetworkError(request, volleyError);</span><br><span class="line">        request.notifyListenerResponseNotUsable();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        VolleyLog.e(e, <span class="string">&quot;Unhandled exception %s&quot;</span>, e.toString());</span><br><span class="line">        <span class="type">VolleyError</span> <span class="variable">volleyError</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolleyError</span>(e);</span><br><span class="line">        volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</span><br><span class="line">        mDelivery.postError(request, volleyError);</span><br><span class="line">        request.notifyListenerResponseNotUsable();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        request.sendEvent(RequestQueue.RequestEvent.REQUEST_NETWORK_DISPATCH_FINISHED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过<code>NetworkDispatcher.processRequest()</code>方法可以发现，主要分为以下几步：</p>
<ul>
<li>通过<code>BasicNetwork.performRequest(request)</code>得到<code>NetworkResponse</code>对象；</li>
<li>通过<code>request.parseNetworkResponse(networkResponse)</code>解析得到<code>Response</code>对象；</li>
<li>通过<code>mDelivery</code>将成功结果或者失败结果回调到主线程。</li>
</ul>
<p>现在我们依次来分析这三步：</p>
<ul>
<li>请求网络，得到<code>NetworkResponse</code><br>  我们看看<code>BasicNetwork</code>的<code>performRequest()</code>方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> NetworkResponse <span class="title function_">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">requestStart</span> <span class="operator">=</span> SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">byte</span>[] responseContents = <span class="literal">null</span>;</span><br><span class="line">        List&lt;Header&gt; responseHeaders = Collections.emptyList();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Gather headers.</span></span><br><span class="line">            Map&lt;String, String&gt; additionalRequestHeaders =</span><br><span class="line">                    getCacheHeaders(request.getCacheEntry());</span><br><span class="line">            httpResponse = mBaseHttpStack.executeRequest(request, additionalRequestHeaders);</span><br><span class="line">            <span class="type">int</span> <span class="variable">statusCode</span> <span class="operator">=</span> httpResponse.getStatusCode();</span><br><span class="line"></span><br><span class="line">            responseHeaders = httpResponse.getHeaders();</span><br><span class="line">            <span class="comment">// Handle cache validation.</span></span><br><span class="line">            <span class="keyword">if</span> (statusCode == HttpURLConnection.HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> request.getCacheEntry();</span><br><span class="line">                <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NetworkResponse</span>(</span><br><span class="line">                            HttpURLConnection.HTTP_NOT_MODIFIED,</span><br><span class="line">                            <span class="comment">/* data= */</span> <span class="literal">null</span>,</span><br><span class="line">                            <span class="comment">/* notModified= */</span> <span class="literal">true</span>,</span><br><span class="line">                            SystemClock.elapsedRealtime() - requestStart,</span><br><span class="line">                            responseHeaders);</span><br><span class="line">            &#125;</span><br><span class="line">                    …………省略</span><br></pre></td></tr></table></figure>
<p>通过上面源码可以看出，<code>BasicNetwork</code>就是封装了一下<code>NetworkResponse</code>，并没有涉及到网络请求，我们继续深入到<code>BaseHttpStack.executeRequest(request, additionalRequestHeaders)</code>源码中。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> HttpResponse <span class="title function_">executeRequest</span><span class="params">(</span></span><br><span class="line"><span class="params">        Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, AuthFailureError;</span><br></pre></td></tr></table></figure><br>这时发现这个<code>BaseHttpStack</code>就是一个抽象类，而这个<code>executeRequest()</code>也就是一个抽象方法。我当时就卡在这了，调用了一个抽象类的抽象方法，这咋操作嘛。然后我就好好再看了一遍，找到<code>BasicNetwork</code>的构造函数中对<code>mBaseHttpStck</code>定义的地方，发现这个是构造函数传进来的，然后就想到了在调用<code>Volley.newRequestQueue()</code>时，是根据Android版本传入了不同的<code>Stack</code>，那我们就来看看<code>HurlStack.executeRequest()</code>方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> HttpResponse <span class="title function_">executeRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, AuthFailureError &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> request.getUrl();</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.putAll(additionalHeaders);</span><br><span class="line">    <span class="comment">// request.getheaders（）优先于给定的附加（缓存）头.</span></span><br><span class="line">    map.putAll(request.getHeaders());</span><br><span class="line">    <span class="keyword">if</span> (mUrlRewriter != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">rewritten</span> <span class="operator">=</span> mUrlRewriter.rewriteUrl(url);</span><br><span class="line">        <span class="keyword">if</span> (rewritten == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;URL blocked by rewriter: &quot;</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        url = rewritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">URL</span> <span class="variable">parsedUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(url);</span><br><span class="line">    <span class="type">HttpURLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> openConnection(parsedUrl, request);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">keepConnectionOpen</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String headerName : map.keySet()) &#123;</span><br><span class="line">            connection.setRequestProperty(headerName, map.get(headerName));</span><br><span class="line">        &#125;</span><br><span class="line">        setConnectionParametersForRequest(connection, request);</span><br><span class="line">        <span class="comment">// 使用来自httpurlConnection的数据初始化httpResponse。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">responseCode</span> <span class="operator">=</span> connection.getResponseCode();</span><br><span class="line">        <span class="keyword">if</span> (responseCode == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果无法检索响应代码，getResponseCode（）将返回-1。</span></span><br><span class="line">            <span class="comment">// 向呼叫者发出信号，说明连接有问题。</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Could not retrieve response code from HttpUrlConnection.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!hasResponseBody(request.getMethod(), responseCode)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpResponse</span>(responseCode, convertHeaders(connection.getHeaderFields()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要保持连接打开，直到调用方使用流。包装流，以便close（）将断开连接。</span></span><br><span class="line">        keepConnectionOpen = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpResponse</span>(</span><br><span class="line">                responseCode,</span><br><span class="line">                convertHeaders(connection.getHeaderFields()),</span><br><span class="line">                connection.getContentLength(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UrlConnectionInputStream</span>(connection));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!keepConnectionOpen) &#123;</span><br><span class="line">            connection.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，主要就是借助了<code>HttpURLConnection</code>对象来请求网络，并根据不同的条件返回不同的<code>HttpResponse</code>对象。</p>
<ul>
<li>解析<code>NetworkResponse</code>, 得到<code>Response</code>：<br>解析过程是定义在<code>Request</code>类中，但是他是一个抽象类，不同的Request都有自己的实现，我们现在就以JsonRequest为例看看：<br>然后发现他又是一个抽象类，那我们就看看<code>JsonRequest</code>其中一个实现类<code>JsonObjectRequest</code>的<code>parseNetworkResponse()</code>方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Response&lt;JSONObject&gt; <span class="title function_">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>(</span><br><span class="line">                        response.data,</span><br><span class="line">                        HttpHeaderParser.parseCharset(response.headers, PROTOCOL_CHARSET));</span><br><span class="line">        <span class="keyword">return</span> Response.success(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">JSONObject</span>(jsonString), HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> Response.error(<span class="keyword">new</span> <span class="title class_">ParseError</span>(e));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JSONException je) &#123;</span><br><span class="line">        <span class="keyword">return</span> Response.error(<span class="keyword">new</span> <span class="title class_">ParseError</span>(je));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就不用多说了，根据返回来的<code>response</code>建了一个<code>String</code>然后把这个<code>String</code>放到<code>Response</code>里面去然后再返回去。</p>
<ul>
<li>回调主线程<br>回调主要是通过<code>Delivery</code>的<code>postResponse()</code>方法实现的，我们来看看这个方法,找过去又找到了一个<code>ResponseDelivery</code>抽象类，然后又得找他的实现类，这时大家应该记得<code>RequestQueue()</code>的时候初始化了一个<code>Delivery</code>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="type">int</span> threadPoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(</span><br><span class="line">            cache,</span><br><span class="line">            network,</span><br><span class="line">            threadPoolSize,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ExecutorDelivery</span>(<span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他返回了一个<code>ExecutorDelivery</code>，我们来看看这个类，然后就惊喜的发现，我们终于找到我们需要的东西了：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new response delivery interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler &#123;<span class="doctag">@link</span> Handler&#125; to post responses on</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> &#123;</span><br><span class="line">    <span class="comment">// Make an Executor that just wraps the handler.</span></span><br><span class="line">    mResponsePoster =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Executor</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">                        handler.post(command);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>知道了它的初始化，我们再来看看它是如何实现回调的：</p>
<p><code>Volley</code>中回调是通过<code>postResponse()</code>方法的 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span> &#123;</span><br><span class="line">    postResponse(request, response, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> &#123;</span><br><span class="line">    request.markDelivered();</span><br><span class="line">    request.addMarker(<span class="string">&quot;post-response&quot;</span>);</span><br><span class="line">    mResponsePoster.execute(<span class="keyword">new</span> <span class="title class_">ResponseDeliveryRunnable</span>(request, response, runnable));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>postResponse()</code>最终会调用<code>mResponsePoster</code>对象的<code>execute()</code>方法，传入了一个<code>ResponseDeliveryRunnable</code>对象，它实现了<code>Runnable</code>接口，<code>execute()</code>方法会通过<code>Handler.post(runnable)</code>将<code>ResponseDeliveryRunnable</code>放入消息队列。最后我们来看看这个<code>ResponseDeliveryRunnable</code>的<code>run()</code>方法在主线程中做了什么操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this request has canceled, finish it and don&#x27;t deliver.</span></span><br><span class="line">    <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</span><br><span class="line">        mRequest.finish(<span class="string">&quot;canceled-at-delivery&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</span><br><span class="line">        <span class="comment">// 执行成功的回调，在具体的Request实现类中，比如StringRequest就会调用listener.onResponse(string)回调</span></span><br><span class="line">        mRequest.deliverResponse(mResponse.result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 执行失败的回调，在request中，直接回调了listener.onErrorResponse(error)</span></span><br><span class="line">        mRequest.deliverError(mResponse.error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// intermediate默认为false，但是在CacheDispatcher的run()中，如果需要更新缓存，那么就会置为true</span></span><br><span class="line">    <span class="keyword">if</span> (mResponse.intermediate) &#123;</span><br><span class="line">        mRequest.addMarker(<span class="string">&quot;intermediate-response&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mRequest.finish(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传入了runnable不为空，那就就执行runnable.run()方法</span></span><br><span class="line">    <span class="comment">// 回忆下在CacheDispatcher的run()方法中，如果request有缓存，但是需要更新缓存的时候，mDelivery是不是调用的带runnable的方法</span></span><br><span class="line">    <span class="keyword">if</span> (mRunnable != <span class="literal">null</span>) &#123;</span><br><span class="line">        mRunnable.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-请求流程图"><a href="#3-请求流程图" class="headerlink" title="3 请求流程图"></a>3 请求流程图</h1><p>最后附上Volley的请求流程图<br><img src="https://cdn.littlecorgi.top/mweb/2019-07-23/VolleyRequestProcess.jpg" alt="VolleyRequestProcess"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码</tag>
        <tag>kotlin</tag>
        <tag>Volley</tag>
      </tags>
  </entry>
  <entry>
    <title>Android网络请求3--解析OkHttp源码</title>
    <url>/posts/151ac78a.html</url>
    <content><![CDATA[<h1 id="1-OkHttp简介"><a href="#1-OkHttp简介" class="headerlink" title="1. OkHttp简介"></a>1. OkHttp简介</h1><p><code>okhttp</code>是一个第三方类库，用于android中请求网络。</p>
<p>这是一个开源项目,是安卓端最火热的轻量级框架,由移动支付Square公司贡献。用于替代因移除了<code>HttpClient</code>而导致没用的<code>Volley</code>。</p>
<p>目前更多人选择了<code>Retrofit</code>。<br><span id="more"></span></p>
<h1 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h1><blockquote>
<p>本文对OkHttp的探讨全部基于目前的最新版OkHttp:4.0.1，而这个版本作者已经使用kotlin对源码进行了重写，所以有些小伙伴可能阅读稍微有点问题，但是别担心，本文中所涉及的源码阅读起来基本上和Java一样，所以请不会kotlin的小伙伴还是耐心看下去，不太懂的语法就百度下，同时我也会对某些语法作注释</p>
</blockquote>
<h2 id="2-1-OkHttp请求流程"><a href="#2-1-OkHttp请求流程" class="headerlink" title="2.1 OkHttp请求流程"></a>2.1 OkHttp请求流程</h2><h3 id="2-1-1-从请求处理开始分析"><a href="#2-1-1-从请求处理开始分析" class="headerlink" title="2.1.1 从请求处理开始分析"></a>2.1.1 从请求处理开始分析</h3><p>我们无论在使用<code>OkHttp</code>进行什么请求的时候都会创建<code>OkHttpClient</code>对象并调用他的<code>newCall()</code>方法，那我们就从这个方法看起：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Call &#123;</span><br><span class="line"><span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, forWebSocket = <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到返回了一个<code>RealCall</code>对象，所以也就意味着我们使用<code>OkHttpClient</code>对象调用的<code>execute()</code>操作实际上是<code>RealCall</code>的<code>execute()</code>操作，那我们就来看<code>RealCall</code>的<code>execute()</code>方法：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 添加同步锁</span></span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// check()是kotlin特有的一个方法，他本质上就是一个if，</span></span><br><span class="line">        <span class="comment">// 但是当他的判断语句是false的话，</span></span><br><span class="line">        <span class="comment">// 他就会抛出一个IllegalStateException异常，异常的内容就是后面的语句</span></span><br><span class="line">        check(!executed) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line">        executed = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// executed是一个布尔值，他的作用就是判断是不是执行过了，</span></span><br><span class="line">        <span class="comment">// 如果执行过了还执行了这个方法的话就抛异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// transmitter用于连接OKHTTP的应用程序和网络层，不用多管</span></span><br><span class="line">    transmitter.timeoutEnter()</span><br><span class="line">    transmitter.callStart()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这块又调用了<code>client.dispatcher</code>，然后找回去找到<code>OkHttpClient</code>的<code>dispatcher</code>对象，发现他就是<code>Dispatcher</code>类的一个对象，接着我们继续看<code>Dispatcher</code>类。</p>
<h3 id="2-1-2-Dispatcher任务调度"><a href="#2-1-2-Dispatcher任务调度" class="headerlink" title="2.1.2 Dispatcher任务调度"></a>2.1.2 Dispatcher任务调度</h3><p>进入<code>Dispatcher</code>类，我们可以看到如下成员变量定义:</p>
<blockquote>
<p>注：kotlin中一个成员变量的@get和@set分别对应了Java中get和set方法，所以这块我没有完完全全复制粘贴到这，我只取了定义部分</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最大并发请求数</span></span><br><span class="line"><span class="keyword">var</span> maxRequests = <span class="number">64</span></span><br><span class="line"><span class="comment">// 每个主机的最大请求数</span></span><br><span class="line"><span class="keyword">var</span> maxRequestsPerHost = <span class="number">5</span></span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="keyword">val</span> executorService: ExecutorService</span><br><span class="line"><span class="comment">// 将要运行的异步请求队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"><span class="comment">// 正在运行的异步请求队队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> runningAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"><span class="comment">// 正在运行的同步请求队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> runningSyncCalls = ArrayDeque&lt;RealCall&gt;()</span><br></pre></td></tr></table></figure>
<p>接下来我们看看<code>Dispatcher</code>的构造方法<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主构造方法，没写具体实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dispatcher</span> <span class="keyword">constructor</span>() &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(executorService: ExecutorService) : <span class="keyword">this</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.executorServiceOrNull = executorService</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以看到他将传进来的<code>executorService</code>传给了<code>executorServiceOrNull</code>，那我们来看看<code>executorServiceOrNull</code>的定义：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// executorServiceOrNull这个应该是因为kotlin的空安全检查特性而定义的，本质上就是executorService</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> executorServiceOrNull: ExecutorService? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@get:Synchronized</span></span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;executorService&quot;</span>) <span class="keyword">val</span> executorService: ExecutorService</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (executorServiceOrNull == <span class="literal">null</span>) &#123;</span><br><span class="line">            executorServiceOrNull = ThreadPoolExecutor(<span class="number">0</span>, <span class="built_in">Int</span>.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                SynchronousQueue(), threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>, <span class="literal">false</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> executorServiceOrNull!!</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>我们可以看到<code>executorService</code>的<code>set</code>方法，就是创建了一个线程池。再结合他有两个构造器就知道：如果没有给<code>Dispatcher</code>传入一个线程池他就会自己创建一个线程池。这个线程池适合执行大量且耗时较少的任务。</p>
<p>构造器我们看完了，我们就来看他的<code>enqueue()</code>方法：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        readyAsyncCalls.add(call)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span></span><br><span class="line">        <span class="comment">// the same host.</span></span><br><span class="line">        <span class="keyword">if</span> (!call.<span class="keyword">get</span>().forWebSocket) &#123;</span><br><span class="line">            <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host())</span><br><span class="line">            <span class="keyword">if</span> (existingCall != <span class="literal">null</span>)call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    promoteAndExecute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>来一个请求就把他添加到就绪请求队列中去，然后就来判断<code>forWebSocket</code>这个属性。看到这个属性我还迷了下，有点搞不懂她是干嘛的，然后经过我的一番搜索后，发现原来<code>OkHttp</code>还可以进行<code>WebSocket</code>通信，而这个属性就是为<code>WebSocket</code>通信准备的。于是我就到<code>RealCall</code>里面找在哪儿定义了这个属性了，然后我就发现了在<code>RealCall</code>的<code>newRealCall()</code>方法这块，这个方法传入的参数中有一个<code>Boolean</code>值名字就叫<code>forWebSocket</code>。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">newRealCall</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        client: <span class="type">OkHttpClient</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        originalRequest: <span class="type">Request</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        forWebSocket: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: RealCall &#123;</span><br><span class="line">        <span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">        <span class="keyword">return</span> RealCall(client, originalRequest, forWebSocket).apply &#123;</span><br><span class="line">            transmitter = Transmitter(client, <span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不知道大家有没有印象，咱们在上面说过，执行<code>OkHttpClient.newCall()</code>方法实际上是返回了一个<code>RealCall</code>对象，于是在那找到了这个的答案，<code>forWebSocket=false</code><br>所以说这个<code>if</code>咱们不用管，直接看<code>promoteAndExecute()</code>方法：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 不知道大家还记不记得咱们之前说的kotlin里面的check()语法，</span></span><br><span class="line">    <span class="comment">// 这个和check也一样，只不过抛出的是AssertionError异常</span></span><br><span class="line">    assert(!Thread.holdsLock(<span class="keyword">this</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mutableListOf是kotlin里面的可变list集合</span></span><br><span class="line">    <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">    <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// 最大容量</span></span><br><span class="line">                <span class="keyword">if</span> (asyncCall.callsPerHost().<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// 主机最大容量</span></span><br><span class="line"></span><br><span class="line">                i.remove()</span><br><span class="line">                asyncCall.callsPerHost().incrementAndGet()</span><br><span class="line">                executableCalls.add(asyncCall)</span><br><span class="line">                runningAsyncCalls.add(asyncCall)</span><br><span class="line">            &#125;</span><br><span class="line">        isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">        <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">        asyncCall.executeOn(executorService)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isRunning</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先将已就绪队列遍历一遍，判断正在运行的数量是不是大于定义的最大请求数，如果大于的话直接退出循环；如果不大于则在判断这个请求的主机请求数是不是大于定义的每个主机最大请求数，如果大于就跳过这个请求换下一个请求；不大于就把它调入正在运行的请求队列里面，直到遍历完成。然后判断还有没有正在运行的请求，如果有就<code>isRunning</code>置<code>true</code>。接着再取出<code>executableCalls</code>里的每一个元素，然后执行<code>executteOn()</code>方法。我们继续来看<code>AsyncCall</code>的<code>executeOn()</code>方法：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="type">ExecutorService</span>)</span></span> &#123;</span><br><span class="line">    assert(!Thread.holdsLock(client.dispatcher))</span><br><span class="line">    <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">this</span>)</span><br><span class="line">        success = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: RejectedExecutionException) &#123;</span><br><span class="line">        <span class="keyword">val</span> ioException = InterruptedIOException(<span class="string">&quot;executor rejected&quot;</span>)</span><br><span class="line">        ioException.initCause(e)</span><br><span class="line">        transmitter.noMoreExchanges(ioException)</span><br><span class="line">        responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, ioException)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            client.dispatcher.finished(<span class="keyword">this</span>) <span class="comment">// This call is no longer running!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这段代码就是在执行线程池中的线程，如果成功执行就将<code>success</code>置<code>true</code>，如果不成功，则抛异常并返回给<code>responseCallback</code>的<code>onFailure()</code>方法。并且如果没有成功执行也就是<code>success</code>为<code>false</code>，那么在<code>finally</code>中就会执行<code>client.dispatcher.finished()</code>方法:<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">finished</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">    call.callsPerHost().decrementAndGet()</span><br><span class="line">    finished(runningAsyncCalls, call)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>这个方法先将传入的<code>AsyncCall</code>的<code>callsPerHost</code>给减1，然后再调用了<code>finished()</code>方法，我们再来看这个<code>finished()</code>方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">finished</span><span class="params">(calls: <span class="type">Deque</span>&lt;<span class="type">T</span>&gt;, call: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> idleCallback: Runnable?</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> AssertionError(<span class="string">&quot;Call wasn&#x27;t in-flight!&quot;</span>)</span><br><span class="line">        idleCallback = <span class="keyword">this</span>.idleCallback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> isRunning = promoteAndExecute()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">        idleCallback.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他讲此次请求从<code>runningAsyncCalls</code>中移除，然后执行了<code>promoteAndExecute()</code>方法，咱们在上面说过这个方法，他的返回值就是判断当前这个运行队列中还有没有请求，如果还有就返回<code>true</code>，没有就<code>false</code>。接着一个<code>if</code>，判断<code>isRunning</code>和<code>idleCallback</code>的，那么如果当前这个请求还没有执行的话，就调用<code>run()</code>方法执行当前请求。这样每个请求都执行完毕了。<br>那我们再来看看他的<code>run()</code>方法：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">      threadName(<span class="string">&quot;OkHttp <span class="subst">$&#123;redactedUrl()&#125;</span>&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> signalledCallback = <span class="literal">false</span></span><br><span class="line">            transmitter.timeoutEnter()</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> response = getResponseWithInterceptorChain()</span><br><span class="line">                signalledCallback = <span class="literal">true</span></span><br><span class="line">                responseCallback.onResponse(<span class="keyword">this</span><span class="symbol">@RealCall</span>, response)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">                    <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">                    Platform.<span class="keyword">get</span>().log(INFO, <span class="string">&quot;Callback failure for <span class="subst">$&#123;toLoggableString()&#125;</span>&quot;</span>, e)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这块调用了一个<code>getResponseWithInterceptorChain()</code>方法，并返回了<code>response</code>，并将它返回给了<code>responseCallback.onResponse()</code>方法。如果失败了就将结果返回给<code>responseCallback.onFailure()</code>方法。最后调用<code>client.dispatcher.finished()</code>方法。</p>
<h3 id="2-1-3-Interceptor拦截器"><a href="#2-1-3-Interceptor拦截器" class="headerlink" title="2.1.3 Interceptor拦截器"></a>2.1.3 Interceptor拦截器</h3><h4 id="2-1-3-1-getResponseWithInterceptorChain-方法"><a href="#2-1-3-1-getResponseWithInterceptorChain-方法" class="headerlink" title="2.1.3.1 getResponseWithInterceptorChain()方法"></a>2.1.3.1 getResponseWithInterceptorChain()方法</h4><p>首先我们看看<code>getResponseWithInterceptorChain()</code>方法：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    interceptors += client.interceptors</span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">    interceptors += CacheInterceptor(client.cache)</span><br><span class="line">    interceptors += ConnectInterceptor</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        interceptors += client.networkInterceptors</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> chain = RealInterceptorChain(interceptors, transmitter, <span class="literal">null</span>, <span class="number">0</span>, originalRequest, <span class="keyword">this</span>,</span><br><span class="line">        client.connectTimeoutMillis, client.readTimeoutMillis, client.writeTimeoutMillis)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line">        <span class="keyword">if</span> (transmitter.isCanceled) &#123;</span><br><span class="line">            response.closeQuietly()</span><br><span class="line">            <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">throw</span> transmitter.noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">            transmitter.noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先就创建了一大堆的连接器并添加到<code>interceptors</code>集合中。然后创建了一个<code>RealInterceptorChain</code>对象，并调用了他的<code>proceed()</code>方法，接着主要目的就是讲<code>proceed()</code>返回的<code>response</code>给返回去。<br>那我们就来看看<code>RealInterceptorChain</code>的<code>proceed()</code>方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">return</span> proceed(request, transmitter, exchange)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>, transmitter: <span class="type">Transmitter</span>, exchange: <span class="type">Exchange</span>?)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size) <span class="keyword">throw</span> AssertionError()</span><br><span class="line"></span><br><span class="line">    calls++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class="line">    check(<span class="keyword">this</span>.exchange == <span class="literal">null</span> || <span class="keyword">this</span>.exchange.connection()!!.supportsUrl(request.url)) &#123;</span><br><span class="line">        <span class="string">&quot;network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must retain the same host and port&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class="line">    check(<span class="keyword">this</span>.exchange == <span class="literal">null</span> || calls &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="string">&quot;network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must call proceed() exactly once&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the next interceptor in the chain.</span></span><br><span class="line">    <span class="keyword">val</span> next = RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">        index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout)</span><br><span class="line">    <span class="keyword">val</span> interceptor = interceptors[index]</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;USELESS_ELVIS&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> response = interceptor.intercept(next) ?: <span class="keyword">throw</span> NullPointerException(</span><br><span class="line">        <span class="string">&quot;interceptor <span class="variable">$interceptor</span> returned null&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Confirm that the next interceptor made its required call to chain.proceed().</span></span><br><span class="line">    check(exchange == <span class="literal">null</span> || index + <span class="number">1</span> &gt;= interceptors.size || next.calls == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="string">&quot;network interceptor <span class="variable">$interceptor</span> must call proceed() exactly once&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    check(response.body != <span class="literal">null</span>) &#123; <span class="string">&quot;interceptor <span class="variable">$interceptor</span> returned a response with no body&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>首先就是一个<code>index</code>，<code>index</code>是<code>RealInterceptorChain</code>构造器中传入的参数，她是第四个参数，所以我们看<code>getResponseWithInterceptorChain()</code>方法中创建<code>RealInterceptorChain</code>对象时构造器的第四个传入的值为0。然后判断<code>index</code>的值是不是大于<code>interceptors</code>的大小，如果大于就抛异常，否则就继续一顿检查！！！然后再创建<code>RealInterceptorChain</code>对象，此时创建的对象传入的<code>index</code>为此时的<code>index+1</code>，然后再调用<code>interceptor</code>的<code>intercept()</code>方法，并返回<code>response</code>。<br><code>interceptor</code>的<code>intercept()</code>作用是当存在多个拦截器时都会在上面代码注释1处阻塞，并等待下一个拦截器的调用返回。</p>
<h4 id="2-1-3-2-Interceptor源码"><a href="#2-1-3-2-Interceptor源码" class="headerlink" title="2.1.3.2 Interceptor源码"></a>2.1.3.2 Interceptor源码</h4><p>那现在我们再来讲几个重要的拦截器吧。<br><code>OkHttp</code>中<code>Interceptor</code>的实现类有：</p>
<ol>
<li><code>ConnectInterceptor</code>：连接拦截器。 </li>
<li><code>CallServerInterceptor</code>：请求服务器拦截器 </li>
<li><code>CacheInterceptor</code>：缓存拦截器 </li>
<li><code>BridgeInterceptor</code>：桥梁拦截器。 </li>
</ol>
<p>其中较为重要的就是<code>ConnectInterceptor</code>和<code>CallServerInterceptor</code>，那我们来看看这两个。</p>
<h5 id="2-1-3-2-1-ConnectInterceptor"><a href="#2-1-3-2-1-ConnectInterceptor" class="headerlink" title="2.1.3.2.1 ConnectInterceptor"></a>2.1.3.2.1 ConnectInterceptor</h5><p>这个类主要用来实现网络请求连接。我们来看下他的<code>intercept</code>方法：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">val</span> request = realChain.request()</span><br><span class="line">    <span class="keyword">val</span> transmitter = realChain.transmitter()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">    <span class="keyword">val</span> doExtensiveHealthChecks = request.method != <span class="string">&quot;GET&quot;</span></span><br><span class="line">    <span class="keyword">val</span> exchange = transmitter.newExchange(chain, doExtensiveHealthChecks)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, transmitter, exchange)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个方法先将传入的<code>chain</code>对象造型成了<code>RealInterceptorChain</code>的对象，这个类我们在上面提到过，然后调用他的<code>response()</code>和<code>transmitter()</code>方法，分别得到当前<code>chain</code>的<code>response</code>和<code>transmitter</code>。然后执行了<code>request</code>的<code>method()</code>方法，判断<code>request</code>的类型是不是<code>GET</code>，如果是<code>doExtensiveHealthChecks</code>就为<code>false</code>，否则为<code>true</code>，接着把<code>doExtensiveHealthChecks</code>传入<code>transmitter的newExchange()</code>方法中去，这个方法我们等会再说，然后再调用了<code>proceed()</code>方法，这个方法我们在上面说过。</p>
<h5 id="2-1-3-2-2-CallServerInterceptor"><a href="#2-1-3-2-2-CallServerInterceptor" class="headerlink" title="2.1.3.2.2 CallServerInterceptor"></a>2.1.3.2.2 CallServerInterceptor</h5><p>这个类是网络请求的本质。它的<code>intercept</code>方法源码如下：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">val</span> exchange = realChain.exchange()</span><br><span class="line">    <span class="keyword">val</span> request = realChain.request()</span><br><span class="line">    <span class="keyword">val</span> requestBody = request.body</span><br><span class="line">    <span class="keyword">val</span> sentRequestMillis = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入请求头</span></span><br><span class="line">    exchange.writeRequestHeaders(request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> responseHeadersStarted = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> responseBuilder: Response.Builder? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 写入请求体信息</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果请求上有“expect:100 continue”头</span></span><br><span class="line">        <span class="comment">// 请等待“http/1.1 100 continue”响应，然后再传输请求主体.</span></span><br><span class="line">        <span class="comment">// 如果我们没有得到，返回我们得到的（例如4xx响应），而不传输请求体。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;100-continue&quot;</span>.equals(request.header(<span class="string">&quot;Expect&quot;</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">            exchange.flushRequest()</span><br><span class="line">            responseHeadersStarted = <span class="literal">true</span></span><br><span class="line">            exchange.responseHeadersStart()</span><br><span class="line">            responseBuilder = exchange.readResponseHeaders(<span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requestBody.isDuplex()) &#123;</span><br><span class="line">                <span class="comment">// 准备一个双工主体，以便应用程序稍后可以发送请求主体。</span></span><br><span class="line">                exchange.flushRequest()</span><br><span class="line">                <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">true</span>).buffer()</span><br><span class="line">                requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果满足“expect:100 continue”预期，则编写请求正文。</span></span><br><span class="line">                <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">false</span>).buffer()</span><br><span class="line">                requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">                bufferedRequestBody.close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            exchange.noRequestBody()</span><br><span class="line">            <span class="keyword">if</span> (!exchange.connection()!!.isMultiplexed) &#123;</span><br><span class="line">                <span class="comment">// 如果不满足“expect:100 continue”的要求，请防止重用HTTP/1连接。</span></span><br><span class="line">                <span class="comment">// 否则，我们仍然有义务传输请求主体以使连接保持一致状态。</span></span><br><span class="line">                exchange.noNewExchangesOnConnection()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        exchange.noRequestBody()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束请求</span></span><br><span class="line">    <span class="keyword">if</span> (requestBody == <span class="literal">null</span> || !requestBody.isDuplex()) &#123;</span><br><span class="line">        exchange.finishRequest()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!responseHeadersStarted) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">        responseBuilder = exchange.readResponseHeaders(<span class="literal">false</span>)!!</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取响应头信息</span></span><br><span class="line">    <span class="keyword">var</span> response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection()!!.handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">var</span> code = response.code</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="comment">// 服务器发送了一个100继续，即使我们没有请求。</span></span><br><span class="line">        <span class="comment">// 再次尝试读取实际响应</span></span><br><span class="line">        response = exchange.readResponseHeaders(<span class="literal">false</span>)!!</span><br><span class="line">            .request(request)</span><br><span class="line">            .handshake(exchange.connection()!!.handshake())</span><br><span class="line">            .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build()</span><br><span class="line">        code = response.code</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exchange.responseHeadersEnd(response)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// openResponseBody 获取响应体信息</span></span><br><span class="line">    response = <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">        <span class="comment">// 连接正在升级，但我们需要确保拦截器看到非空的响应主体。</span></span><br><span class="line">        response.newBuilder()</span><br><span class="line">            .body(EMPTY_RESPONSE)</span><br><span class="line">            .build()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response.newBuilder()</span><br><span class="line">                .body(exchange.openResponseBody(response))</span><br><span class="line">                .build()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;close&quot;</span>.equals(response.request.header(<span class="string">&quot;Connection&quot;</span>), ignoreCase = <span class="literal">true</span>) ||</span><br><span class="line">        <span class="string">&quot;close&quot;</span>.equals(response.header(<span class="string">&quot;Connection&quot;</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">            exchange.noNewExchangesOnConnection()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body?.contentLength() ?: -<span class="number">1L</span> &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ProtocolException(</span><br><span class="line">                <span class="string">&quot;HTTP <span class="variable">$code</span> had non-zero Content-Length: <span class="subst">$&#123;response.body?.contentLength()&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回一个响应</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>具体过程可以看代码中的注释，它主要是向服务器发送请求数据和接受服务器返回的数据。</p>
<h3 id="2-1-4-Transmiter"><a href="#2-1-4-Transmiter" class="headerlink" title="2.1.4 Transmiter"></a>2.1.4 Transmiter</h3><p><code>Transmitter</code>类是<code>OkHttp</code>的应用层和网络层的一个桥梁类。</p>
<p>我们先来看看该类的初始化：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transmitter</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> client: OkHttpClient,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> call: Call</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> connectionPool: RealConnectionPool = client.connectionPool.delegate</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> eventListener: EventListener = client.eventListenerFactory.create(call)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> timeout = <span class="keyword">object</span> : AsyncTimeout() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">timedOut</span><span class="params">()</span></span> &#123;</span><br><span class="line">            cancel()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.apply &#123;</span><br><span class="line">        timeout(client.callTimeoutMillis.toLong(), MILLISECONDS)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><code>Transmitter</code>主要的一些成员变量就这些，首先构造器中传入了两个参数，一个<code>OkHttpClient</code>，一个<code>Call</code>。然后又创建了一个连接池<code>connectionPool</code>，还有一个监听器，我们可以通过扩展这个类来监听程序的<code>HTTP</code>的调用数量、大小和持续时间。</p>
<h3 id="2-1-5-RealConnection"><a href="#2-1-5-RealConnection" class="headerlink" title="2.1.5 RealConnection"></a>2.1.5 RealConnection</h3><p>我们先看看他的一些属性：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealConnection</span>(</span><br><span class="line">    <span class="keyword">val</span> connectionPool: RealConnectionPool,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> route: Route</span><br><span class="line">) : Http2Connection.Listener(), Connection &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下字段由connect（）初始化，从不重新分配。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 底层socket</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> rawSocket: Socket? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用层套接字。如果此连接不使用SSL，则可以是[sslsocket]分层在[rawsocket]上，也可以是[rawsocket]本身。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 应用层socket</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> socket: Socket? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 握手</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> handshake: Handshake? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//  协议</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> protocol: Protocol? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// http2的连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> http2Connection: Http2Connection? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 与服务器交互的输入输出流</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> source: BufferedSource? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> sink: BufferedSink? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟踪连接状态下的字段由连接池保护。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果为true，则不能在此连接上创建新的交换。一旦是true的，这总是true的。</span></span><br><span class="line"><span class="comment">     * 由[ConnectionPool]监视。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> noNewExchanges = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立可能由于所选路由而导致的流时出现问题的次数。由[ConnectionPool]保护。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> routeFailureCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> successCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> refusedStreamCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此连接可以承载的最大并发流数。</span></span><br><span class="line"><span class="comment">     * 如果“allocations.size（）&lt;allocationlimit”，则可以在此连接上创建新流。     </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> allocationLimit = <span class="number">1</span></span><br></pre></td></tr></table></figure><br>接下来我们看看他的<code>connect()</code>方法：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    writeTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    pingIntervalMillis: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    connectionRetryEnabled: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    call: <span class="type">Call</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    eventListener: <span class="type">EventListener</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    check(protocol == <span class="literal">null</span>) &#123; <span class="string">&quot;already connected&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线路的选择</span></span><br><span class="line">    <span class="keyword">var</span> routeException: RouteException? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> connectionSpecs = route.address.connectionSpecs</span><br><span class="line">    <span class="keyword">val</span> connectionSpecSelector = ConnectionSpecSelector(connectionSpecs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (route.address.sslSocketFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ConnectionSpec.CLEARTEXT !<span class="keyword">in</span> connectionSpecs) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RouteException(UnknownServiceException(</span><br><span class="line">                <span class="string">&quot;CLEARTEXT communication not enabled for client&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> host = route.address.url.host</span><br><span class="line">        <span class="keyword">if</span> (!Platform.<span class="keyword">get</span>().isCleartextTrafficPermitted(host)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RouteException(UnknownServiceException(</span><br><span class="line">                <span class="string">&quot;CLEARTEXT communication to <span class="variable">$host</span> not permitted by network security policy&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Protocol.H2_PRIOR_KNOWLEDGE <span class="keyword">in</span> route.address.protocols) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RouteException(UnknownServiceException(</span><br><span class="line">                <span class="string">&quot;H2_PRIOR_KNOWLEDGE cannot be used with HTTPS&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接开始</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果要求隧道模式，建立通道连接，通常不是这种</span></span><br><span class="line">            <span class="keyword">if</span> (route.requiresTunnel()) &#123;</span><br><span class="line">                connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener)</span><br><span class="line">                <span class="keyword">if</span> (rawSocket == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 我们无法连接隧道，但适当关闭了我们的资源。</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 一般都走这条逻辑了，实际上很简单就是socket的连接</span></span><br><span class="line">                connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// https的建立</span></span><br><span class="line">            establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)</span><br><span class="line">            eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">            socket?.closeQuietly()</span><br><span class="line">            rawSocket?.closeQuietly()</span><br><span class="line">            socket = <span class="literal">null</span></span><br><span class="line">            rawSocket = <span class="literal">null</span></span><br><span class="line">            source = <span class="literal">null</span></span><br><span class="line">            sink = <span class="literal">null</span></span><br><span class="line">            handshake = <span class="literal">null</span></span><br><span class="line">            protocol = <span class="literal">null</span></span><br><span class="line">            http2Connection = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">            eventListener.connectFailed(call, route.socketAddress, route.proxy, <span class="literal">null</span>, e)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (routeException == <span class="literal">null</span>) &#123;</span><br><span class="line">                routeException = RouteException(e)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                routeException.addConnectException(e)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> routeException</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (route.requiresTunnel() &amp;&amp; rawSocket == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> RouteException(ProtocolException(</span><br><span class="line">            <span class="string">&quot;Too many tunnel connections attempted: <span class="variable">$MAX_TUNNEL_ATTEMPTS</span>&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> http2Connection = <span class="keyword">this</span>.http2Connection</span><br><span class="line">    <span class="keyword">if</span> (http2Connection != <span class="literal">null</span>) &#123;</span><br><span class="line">        synchronized(connectionPool) &#123;</span><br><span class="line">            allocationLimit = http2Connection.maxConcurrentStreams()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先检查是否已经建立连接，如果已经建立就抛异常，没有的话就继续。接着就得到了<code>ConnectionSpecs</code>，然后根据他建立了一个<code>connectionSpecSelector</code>集合。接着判断是不是安全连接，也就是ssl连接，如果不是的话就判断了一些属性，先确定是不是明文然后再确定主机能不能接受明文操作。接着就开始连接，判断是不是要进行隧道通信，如果是就调用<code>connectTunnel()</code>建立隧道通信，如果不是就调用<code>connectSocket()</code>建立普通的通信。然后通过<code>establishProtocol()</code>建立协议。如果是<code>HTTP/2</code>就设置相关属性。</p>
<p>然后我们就来看看他具体如何实现的，先看看<code>connectSocket()</code>方法：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">connectSocket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    call: <span class="type">Call</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    eventListener: <span class="type">EventListener</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> proxy = route.proxy</span><br><span class="line">    <span class="keyword">val</span> address = route.address</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据代理类型选择socket类型是代理还是直连</span></span><br><span class="line">    <span class="keyword">val</span> rawSocket = <span class="keyword">when</span> (proxy.type()) &#123;</span><br><span class="line">        Proxy.Type.DIRECT, Proxy.Type.HTTP -&gt; address.socketFactory.createSocket()!!</span><br><span class="line">        <span class="keyword">else</span> -&gt; Socket(proxy)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.rawSocket = rawSocket</span><br><span class="line"></span><br><span class="line">    eventListener.connectStart(call, route.socketAddress, proxy)</span><br><span class="line">    rawSocket.soTimeout = readTimeout</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 连接socket，之所以这样写是因为支持不同的平台</span></span><br><span class="line">        <span class="comment">// 里面实际上是  socket.connect(address, connectTimeout);</span></span><br><span class="line">        Platform.<span class="keyword">get</span>().connectSocket(rawSocket, route.socketAddress, connectTimeout)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: ConnectException) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ConnectException(<span class="string">&quot;Failed to connect to <span class="subst">$&#123;route.socketAddress&#125;</span>&quot;</span>).apply &#123;</span><br><span class="line">            initCause(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的Try/Catch块是一种避免Android 7.0崩溃的伪黑客方法</span></span><br><span class="line">    <span class="comment">// More details:</span></span><br><span class="line">    <span class="comment">// https://github.com/square/okhttp/issues/3245</span></span><br><span class="line">    <span class="comment">// https://android-review.googlesource.com/#/c/271775/</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 得到输入／输出流</span></span><br><span class="line">        source = rawSocket.source().buffer()</span><br><span class="line">        sink = rawSocket.sink().buffer()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (npe: NullPointerException) &#123;</span><br><span class="line">        <span class="keyword">if</span> (npe.message == NPE_THROW_WITH_NULL) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IOException(npe)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先先判断连接类型，如果是直连或者<code>HTTP</code>连接就直连，否则的话走<code>Socket</code>代理，然后通过<code>eventListener.connectStart()</code>方法创建连接，再设定超时-&gt;完成连接-&gt;创建用于I/O的<code>source</code>和<code>sink</code>。</p>
<p>我们接着再来看<code>connectTunnel()</code>方法：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">connectTunnel</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    writeTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    call: <span class="type">Call</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    eventListener: <span class="type">EventListener</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tunnelRequest: Request = createTunnelRequest()</span><br><span class="line">    <span class="keyword">val</span> url = tunnelRequest.url</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until MAX_TUNNEL_ATTEMPTS) &#123;</span><br><span class="line">        connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">        tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url)</span><br><span class="line">            ?: <span class="keyword">break</span> <span class="comment">// 已成功创建隧道。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代理决定在身份验证质询后关闭连接。</span></span><br><span class="line">        <span class="comment">// 我们需要创建一个新的连接，但这次需要使用身份验证凭据。</span></span><br><span class="line">        rawSocket?.closeQuietly()</span><br><span class="line">        rawSocket = <span class="literal">null</span></span><br><span class="line">        sink = <span class="literal">null</span></span><br><span class="line">        source = <span class="literal">null</span></span><br><span class="line">        eventListener.connectEnd(call, route.socketAddress, route.proxy, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>大体就是先创建隧道请求，然后建立<code>socket</code>连接，再发送请求建立隧道。</p>
<h1 id="3-请求流程图"><a href="#3-请求流程图" class="headerlink" title="3. 请求流程图"></a>3. 请求流程图</h1><p>那我们最后来总结下</p>
<h2 id="3-1-同步请求是如何操作的？"><a href="#3-1-同步请求是如何操作的？" class="headerlink" title="3.1 同步请求是如何操作的？"></a>3.1 同步请求是如何操作的？</h2><p><img src="https://cdn.littlecorgi.top/mweb/2019-07-26/OkHttpSync.jpg" alt="OkHttpSyn"></p>
<h2 id="3-2-异步请求是如何操作的？"><a href="#3-2-异步请求是如何操作的？" class="headerlink" title="3.2 异步请求是如何操作的？"></a>3.2 异步请求是如何操作的？</h2><p><img src="https://cdn.littlecorgi.top/mweb/2019-07-26/OkHttpAsync.jpg" alt="OkHttpAsyn"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码</tag>
        <tag>kotlin</tag>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title>Android源码之SharedPreferences</title>
    <url>/posts/24e17cf4.html</url>
    <content><![CDATA[<h1 id="SharedPreferences源码分析"><a href="#SharedPreferences源码分析" class="headerlink" title="SharedPreferences源码分析"></a>SharedPreferences源码分析</h1><h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>SharedPreferences可以说是Android中最常用的一种存数据到文件的方式。他的数据是以键值对的方式存储在 <code>~/data/data/包名/shared_prefs</code> 这个文件夹中的。</p>
<p>这个存储框架是非常轻量级的，如果我们需要存一些小数据或者是一个小型的可序列化的Bean实体类的，使用SharedPreferences是最明智的选择。</p>
<span id="more"></span>
<h1 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h1><h2 id="1-1-获取SharedPreferences"><a href="#1-1-获取SharedPreferences" class="headerlink" title="1.1 获取SharedPreferences"></a>1.1 获取SharedPreferences</h2><p>在使用SharedPreferences前，我们得先获取到它。</p>
<p>由于SharedPreferences是Android内置的一个框架，所以我们想要获取到它非常的简单，不需要导入任何依赖，直接写代码就行。下面我们就来介绍下获取对象的三个方式：</p>
<h3 id="1-1-1-Context-getSharedPreferences"><a href="#1-1-1-Context-getSharedPreferences" class="headerlink" title="1.1.1 Context # getSharedPreferences()"></a>1.1.1 Context # getSharedPreferences()</h3><p>首先就是可以说是最常用的方法，通过Context的<code>getSharedPreferences()</code> 方法去获取到SharedPreferences对象。由于是通过Context获取的，所以基本上Android的所有场景我们都可以通过这个方法获取到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> SharedPreferences <span class="title function_">getSharedPreferences</span> <span class="params">(String name, </span></span><br><span class="line"><span class="params">                <span class="type">int</span> mode)</span></span><br></pre></td></tr></table></figure>
<p>这个方法接收两个参数，分别是<code>name</code>和<code>mode</code>：</p>
<ul>
<li><code>name</code>：name就是我们要存储的SharedPreferences本地文件的名字，这个可以自定义。但是如果使用同样的name的话，永远只能获取到同一个SharedPreferences的对象。</li>
<li><code>mode</code>：mode就是我们要获取的这个SharedPreferences的访问模式，Android给我们提供了挺多的模式的，但是由于其余的模式或多或少存在着安全隐患(因为其他应用也可以直接获取到)，所以就全部都弃用了，现在就只有一个<code>MODE_PRIVATE</code>模式。</li>
</ul>
<p>此外，这个方法是线程安全的。</p>
<p><code>Mode</code>的可选参数：</p>
<ul>
<li><code>MODE_PRIVATE</code>：私有模式，该SharedPreferences只会被调用他的APP去使用，其他的APP无法获取到这个SharedPreferences。</li>
<li><del><code>MODE_WORLD_READABLE</code></del>：API17被弃用。使用这个模式，所有的APP都可以对这个SharedPreferences进行读操作。所以这个模式被Android官方严厉警告禁止使用（It is strongly discouraged），并推荐使用<code>ContentProvider</code>、<code>BroadcastReceiver</code>和<code>Service</code>。</li>
<li><del><code>MODE_WORLD_WRITEABLE</code></del>：API17被弃用。和上面类似，这个是可以被所有APP进行写操作。同样也是被严厉警告禁止使用。</li>
<li><del><code>MODE_MULTI_PROCESS</code></del>：API23被弃用。使用了这个模式，允许多个进程对同一个SharedPreferences进行操作，但是后来也被启用了，原因是因为在某些Android版本下，这个模式不能可靠的运行，官方建议如果多进程建议使用<code>ContentProvider</code>去操作。在后面我们会说为啥多进程下不可靠。</li>
</ul>
<h3 id="1-1-2-Activity-getPreferences"><a href="#1-1-2-Activity-getPreferences" class="headerlink" title="1.1.2 Activity # getPreferences()"></a>1.1.2 Activity # getPreferences()</h3><p>这个方法只能在Activity中或者通过Activity对象去使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SharedPreferences <span class="title function_">getPreferences</span> <span class="params">(<span class="type">int</span> mode)</span></span><br></pre></td></tr></table></figure>
<p>这个方法需要传入一个<code>mode</code>参数，这个参数和上面的<code>context#getSharedPreferences()</code>的<code>mode</code>参数是一样的。其实这个方法和上面Context的那个方法是一样的，他两都是调用的<code>SharedPreferences getSharedPreferences(String name, int mode)</code>。只不过Context的需要你去指定文件名，而这个方法你不需要手动去指定，而是会自动将当前Activity的类名作为了文件名。</p>
<h3 id="1-1-3-PreferencesManager-getDefaultSharedPreferences"><a href="#1-1-3-PreferencesManager-getDefaultSharedPreferences" class="headerlink" title="1.1.3 PreferencesManager # getDefaultSharedPreferences()"></a>1.1.3 PreferencesManager # getDefaultSharedPreferences()</h3><p>这个一般用在Android的设置页面上，或者说，我们也只有在构建设置页面的时候才会去使用这个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SharedPreferences <span class="title function_">getDefaultSharedPreferences</span> <span class="params">(Context context)</span></span><br></pre></td></tr></table></figure>
<p>他承接一个context参数，并自动将当前应用的报名作为前缀来命名文件。</p>
<h2 id="1-2-存数据"><a href="#1-2-存数据" class="headerlink" title="1.2 存数据"></a>1.2 存数据</h2><p>如果需要往SharedPreferences中存储数据的话，我们并不能直接对SharedPreferences对象进行操作，因为SharedPreferences没有提供存储或者修改数据的接口。</p>
<p>如果想要对SharedPreferences存储的数据进行修改，需要通过<code>SharedPreferences.edit()</code>方法去获取到SharedPreferences.Editor对象来进行操作。</p>
<p>获取到Editor对象后，我们就可以调用他的<code>putXXX()</code>方法进行存储了，存储之后一定记得通过<code>apply()</code>和<code>commit()</code>方法去将数据提交。</p>
<p>至于<code>commit</code>和<code>apply</code>的区别我们后面会说。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//步骤1：创建一个SharedPreferences对象</span></span><br><span class="line"> SharedPreferences sharedPreferences= getSharedPreferences(<span class="string">&quot;data&quot;</span>,Context.MODE_PRIVATE);</span><br><span class="line"> <span class="comment">//步骤2： 实例化SharedPreferences.Editor对象</span></span><br><span class="line"> SharedPreferences.<span class="type">Editor</span> <span class="variable">editor</span> <span class="operator">=</span> sharedPreferences.edit();</span><br><span class="line"> <span class="comment">//步骤3：将获取过来的值放入文件</span></span><br><span class="line"> editor.putString(<span class="string">&quot;name&quot;</span>, “Tom”);</span><br><span class="line"> editor.putInt(<span class="string">&quot;age&quot;</span>, <span class="number">28</span>);</span><br><span class="line"> editor.putBoolean(<span class="string">&quot;marrid&quot;</span>,<span class="literal">false</span>);</span><br><span class="line"> <span class="comment">//步骤4：提交               </span></span><br><span class="line"> editor.commit();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 删除指定数据</span></span><br><span class="line"> editor.remove(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"> editor.commit();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 清空数据</span></span><br><span class="line"> editor.clear();</span><br><span class="line"> editor.commit();</span><br></pre></td></tr></table></figure>
<h2 id="1-3-取数据"><a href="#1-3-取数据" class="headerlink" title="1.3 取数据"></a>1.3 取数据</h2><p>取值就很简单了，构建出SharedPreferences的对象后，就直接调用SharedPreferences的<code>getXXX()</code>方法就行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SharedPreferences</span> <span class="variable">sharedPreferences</span> <span class="operator">=</span> getSharedPreferences(<span class="string">&quot;data&quot;</span>, Context .MODE_PRIVATE);</span><br><span class="line"><span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> sharedPreferences.getString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h1><h2 id="2-1-获取SharedPreferences实例"><a href="#2-1-获取SharedPreferences实例" class="headerlink" title="2.1 获取SharedPreferences实例"></a>2.1 获取SharedPreferences实例</h2><p>我们上面说到，获取SharedPreferences实例最常用的方法就是<code>Context#getSharedPreferences()</code>。那我们就从这个方法入手，看到底是怎么获取到SharedPreferences实例的。</p>
<p>我们先看下这个方法的实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextWrapper</span> <span class="keyword">extends</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    Context mBase;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SharedPreferences <span class="title function_">getSharedPreferences</span><span class="params">(String name, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mBase.getSharedPreferences(name, mode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到他又调用了Context的<code>getSharedPreferences()</code>方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> SharedPreferences <span class="title function_">getSharedPreferences</span><span class="params">(String name, <span class="meta">@PreferencesMode</span> <span class="type">int</span> mode)</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后我们就会惊喜的发现，这是一个抽象方法。我开始还想去找一个<code>ContextWrapper</code>的构造的地方，看看<code>mBase</code>传入的是啥，后来找了一圈没找到，直接上网搜索，立马得到答案：<code>ContextImpl</code>，这个可以说是<code>Context</code>在Android中的唯一实现类，所有的操作又得经过这个类。那么我们就来看下这个类中的<code>getSharedPreferences()</code>方法的实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SharedPreferences <span class="title function_">getSharedPreferences</span><span class="params">(String name, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">    <span class="comment">// At least one application in the world actually passes in a null</span></span><br><span class="line">    <span class="comment">// name.  This happened to work because when we generated the file name</span></span><br><span class="line">    <span class="comment">// we would stringify it to &quot;null.xml&quot;.  Nice. </span></span><br><span class="line">            <span class="comment">// ps:这个nice很精髓😂</span></span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</span><br><span class="line">            Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">            name = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File file;</span><br><span class="line">    <span class="comment">// 加了一个类锁，保证同步</span></span><br><span class="line">    <span class="keyword">synchronized</span> (ContextImpl.class) &#123;</span><br><span class="line">        <span class="comment">// mSharedPrefsPaths是一个保存了name和file对应关系的ArrayMap</span></span><br><span class="line">        <span class="keyword">if</span> (mSharedPrefsPaths == <span class="literal">null</span>) &#123;</span><br><span class="line">            mSharedPrefsPaths = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据name从里面找有没有缓存的file</span></span><br><span class="line">        file = mSharedPrefsPaths.get(name);</span><br><span class="line">        <span class="comment">// 如果没有，那就调用getSharedPreferencesPath去找</span></span><br><span class="line">        <span class="keyword">if</span> (file == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// -&gt;&gt;&gt; 重点1. getSharedPreferencesPath(name)</span></span><br><span class="line">            file = getSharedPreferencesPath(name);</span><br><span class="line">            <span class="comment">// 并保存到mSharedPrefsPaths</span></span><br><span class="line">            mSharedPrefsPaths.put(name, file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取到file后，再调用getSharedPreferences</span></span><br><span class="line">    <span class="keyword">return</span> getSharedPreferences(file, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重点1. ContextImpl # getSharedPreferencesPath(String name)</span></span><br><span class="line"><span class="comment"> *   根据PreferencesDir和name.xml去创建了这个文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> File <span class="title function_">getSharedPreferencesPath</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> makeFilename(getPreferencesDir(), name + <span class="string">&quot;.xml&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那我们在看下<code>getSharedPreferences(File file, int mode)</code>的实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SharedPreferences <span class="title function_">getSharedPreferences</span><span class="params">(File file, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">    <span class="comment">// SharedPreferences唯一实现类SharedPreferencesImpl的实例</span></span><br><span class="line">    SharedPreferencesImpl sp;</span><br><span class="line">    <span class="comment">// 同样的加类锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (ContextImpl.class) &#123;</span><br><span class="line">        <span class="comment">// 构造了一个File-SharedPreferencesImpl对应关系的ArrayMap</span></span><br><span class="line">        <span class="comment">// 调用getSharedPreferencesCacheLocked方法区获取cahce</span></span><br><span class="line">        <span class="comment">// -&gt;&gt;&gt; 重点1</span></span><br><span class="line">        <span class="keyword">final</span> ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked();</span><br><span class="line">        <span class="comment">// 从file-SharedPreferencesImpl键值对中根据当前file去过去SharedPreferencesImpl实例</span></span><br><span class="line">        sp = cache.get(file);</span><br><span class="line">        <span class="comment">// 如果没有，那就需要新建一个</span></span><br><span class="line">        <span class="keyword">if</span> (sp == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 检查mode，如果是MODE_WORLD_WRITEABLE或者MODE_MULTI_PROCESS则直接抛异常</span></span><br><span class="line">            checkMode(mode);</span><br><span class="line">            <span class="keyword">if</span> (getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isCredentialProtectedStorage()</span><br><span class="line">                        &amp;&amp; !getSystemService(UserManager.class)</span><br><span class="line">                                .isUserUnlockingOrUnlocked(UserHandle.myUserId())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;SharedPreferences in credential encrypted &quot;</span></span><br><span class="line">                            + <span class="string">&quot;storage are not available until after user is unlocked&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用构造方法去构造SharedPreferencesImpl对象</span></span><br><span class="line">            sp = <span class="keyword">new</span> <span class="title class_">SharedPreferencesImpl</span>(file, mode);</span><br><span class="line">            <span class="comment">// 将对象和file的键值对存入cache中</span></span><br><span class="line">            cache.put(file, sp);</span><br><span class="line">            <span class="keyword">return</span> sp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((mode &amp; Context.MODE_MULTI_PROCESS) != <span class="number">0</span> ||</span><br><span class="line">        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        <span class="comment">// If somebody else (some other process) changed the prefs</span></span><br><span class="line">        <span class="comment">// file behind our back, we reload it.  This has been the</span></span><br><span class="line">        <span class="comment">// historical (if undocumented) behavior.</span></span><br><span class="line">        sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重点1. ContextImap # getSharedPreferencesCacheLocked()</span></span><br><span class="line"><span class="comment"> *   根据当前的包名，去获取到由此应用创建的File-SharedPreferencesImpl的Map对象，</span></span><br><span class="line"><span class="comment"> *       而这个对象里面就存放了这个应用创建的所有的SharedPreferencesImpl和File的对应关系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GuardedBy(&quot;ContextImpl.class&quot;)</span></span><br><span class="line"><span class="keyword">private</span> ArrayMap&lt;File, SharedPreferencesImpl&gt; <span class="title function_">getSharedPreferencesCacheLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果sSharedPrefsCache为空就构造一个ArrayMap</span></span><br><span class="line">    <span class="comment">// sSharedPrefsCache就是一个存放String-String, ArrayMap&lt;File, SharedPreferencesImpl&gt;的Map</span></span><br><span class="line">    <span class="comment">// 换句话说，也就是存放包名-packagePrefs对应关系的Map</span></span><br><span class="line">    <span class="keyword">if</span> (sSharedPrefsCache == <span class="literal">null</span>) &#123;</span><br><span class="line">        sSharedPrefsCache = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取包名</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">packageName</span> <span class="operator">=</span> getPackageName();</span><br><span class="line">    <span class="comment">// 到sSharedPrefsCache中找</span></span><br><span class="line">    ArrayMap&lt;File, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefsCache.get(packageName);</span><br><span class="line">    <span class="comment">// 如果找不到，就构建一个然后存进去</span></span><br><span class="line">    <span class="keyword">if</span> (packagePrefs == <span class="literal">null</span>) &#123;</span><br><span class="line">        packagePrefs = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;&gt;();</span><br><span class="line">        sSharedPrefsCache.put(packageName, packagePrefs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找得到就返回</span></span><br><span class="line">    <span class="keyword">return</span> packagePrefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-2-构建SharedPreferencesImpl"><a href="#2-2-构建SharedPreferencesImpl" class="headerlink" title="2.2 构建SharedPreferencesImpl"></a>2.2 构建SharedPreferencesImpl</h2><h3 id="2-2-1-SharedPreferencesImpl构造方法"><a href="#2-2-1-SharedPreferencesImpl构造方法" class="headerlink" title="2.2.1 SharedPreferencesImpl构造方法"></a>2.2.1 SharedPreferencesImpl构造方法</h3><p>我们先来看下这个类的构造方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">SharedPreferencesImpl(File file, <span class="type">int</span> mode) &#123;</span><br><span class="line">    mFile = file;</span><br><span class="line">    <span class="comment">// file的备份文件</span></span><br><span class="line">    mBackupFile = makeBackupFile(file);</span><br><span class="line">    mMode = mode;</span><br><span class="line">    <span class="comment">// 从磁盘加载的标志，当需要从磁盘加载时将其设为true，这样如果有其他线程也调用了SharedPreferences的加载方法时，就会因为其为true而直接返回也就不执行加载方法</span></span><br><span class="line">    <span class="comment">// 保证了全局只有一个线程在加载</span></span><br><span class="line">    mLoaded = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// SharedPreferences中的数据</span></span><br><span class="line">    mMap = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 保存的错误信息</span></span><br><span class="line">    mThrowable = <span class="literal">null</span>;</span><br><span class="line">    startLoadFromDisk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初始化参数后立马调用了<code>startLoadFromDisk()</code>方法：</p>
<h3 id="2-2-2-startLoadFromDisk"><a href="#2-2-2-startLoadFromDisk" class="headerlink" title="2.2.2 startLoadFromDisk()"></a>2.2.2 startLoadFromDisk()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startLoadFromDisk</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        mLoaded = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开启一个新线程来加载数据</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;SharedPreferencesImpl-load&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            loadFromDisk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-3-loadFromDIsk"><a href="#2-2-3-loadFromDIsk" class="headerlink" title="2.2.3 loadFromDIsk()"></a>2.2.3 loadFromDIsk()</h3><p><code>loadFromDisk()</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadFromDisk</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 如果已经家在过了，就直接退出</span></span><br><span class="line">        <span class="keyword">if</span> (mLoaded) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果备份文件已经存在，那就删除源文件，并将备份文件替换为源文件</span></span><br><span class="line">        <span class="keyword">if</span> (mBackupFile.exists()) &#123;</span><br><span class="line">            mFile.delete();</span><br><span class="line">            mBackupFile.renameTo(mFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Debugging</span></span><br><span class="line">    <span class="keyword">if</span> (mFile.exists() &amp;&amp; !mFile.canRead()) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Attempt to read preferences file &quot;</span> + mFile + <span class="string">&quot; without permission&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储聚的map</span></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 文件信息，对应的是C语言stat.h中的struct stat</span></span><br><span class="line">    <span class="type">StructStat</span> <span class="variable">stat</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过文件路径去构建StructStat对象</span></span><br><span class="line">        stat = Os.stat(mFile.getPath());</span><br><span class="line">        <span class="keyword">if</span> (mFile.canRead()) &#123;</span><br><span class="line">            <span class="comment">// 从XML中把数据读出来，并把数据转化成Map类型</span></span><br><span class="line">            <span class="type">BufferedInputStream</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                str = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(mFile), <span class="number">16</span> * <span class="number">1024</span>);</span><br><span class="line">                map = (Map&lt;String, Object&gt;) XmlUtils.readMapXml(str);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">&quot;Cannot read &quot;</span> + mFile.getAbsolutePath(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                IoUtils.closeQuietly(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</span><br><span class="line">        <span class="comment">// An errno exception means the stat failed. Treat as empty/non-existing by</span></span><br><span class="line">        <span class="comment">// ignoring.</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        thrown = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        mLoaded = <span class="literal">true</span>;</span><br><span class="line">        mThrowable = thrown;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// It&#x27;s important that we always signal waiters, even if we&#x27;ll make</span></span><br><span class="line">        <span class="comment">// them fail with an exception. The try-finally is pretty wide, but</span></span><br><span class="line">        <span class="comment">// better safe than sorry.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (thrown == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 文件里拿到的数据为空就重建，存在就赋值</span></span><br><span class="line">                <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将数据存储放置到具体类的一个全局变量中</span></span><br><span class="line">                    <span class="comment">// 稍微记一下这个关键点</span></span><br><span class="line">                    mMap = map;</span><br><span class="line">                    mStatTimestamp = stat.st_mtim;</span><br><span class="line">                    mStatSize = stat.st_size;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// In case of a thrown exception, we retain the old map. That allows</span></span><br><span class="line">            <span class="comment">// any open editors to commit and store updates.</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            mThrowable = t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>到目前来说，就完成的SharedPreferencesImpl的构建过程。</p>
<h2 id="2-3-读数据-SharedPreferences-getXXX"><a href="#2-3-读数据-SharedPreferences-getXXX" class="headerlink" title="2.3 读数据 SharedPreferences # getXXX()"></a>2.3 读数据 SharedPreferences # getXXX()</h2><p>相对来说，读数据涉及到的方法比写数据简单得多，所以我们先来看下读数据：<br>我们以<code>getString()</code>为例</p>
<h3 id="2-3-1-getString"><a href="#2-3-1-getString" class="headerlink" title="2.3.1 getString"></a>2.3.1 getString</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getString</span><span class="params">(String key, <span class="meta">@Nullable</span> String defValue)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 见2.3.2</span></span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">        <span class="comment">// 从map中获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> (String)mMap.get(key);</span><br><span class="line">        <span class="comment">// 如果获取到数据，就返回数据，否则返回方法参数中给定的默认值</span></span><br><span class="line">        <span class="keyword">return</span> v != <span class="literal">null</span> ? v : defValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-awaitLoadedLocked"><a href="#2-3-2-awaitLoadedLocked" class="headerlink" title="2.3.2 awaitLoadedLocked"></a>2.3.2 awaitLoadedLocked</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GuardedBy(&quot;mLock&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">awaitLoadedLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有加载过，则进行加载</span></span><br><span class="line">    <span class="keyword">if</span> (!mLoaded) &#123;</span><br><span class="line">        <span class="comment">// Raise an explicit StrictMode onReadFromDisk for this</span></span><br><span class="line">        <span class="comment">// thread, since the real read will be in a different</span></span><br><span class="line">        <span class="comment">// thread and otherwise ignored by StrictMode.</span></span><br><span class="line">        BlockGuard.getThreadPolicy().onReadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有加载过，则等待</span></span><br><span class="line">    <span class="keyword">while</span> (!mLoaded) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mLock.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mThrowable != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(mThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法简单点来说就是如果<code>mLoad</code>不为true也就是没有加载完成的话，就等待加载完成。</p>
<h2 id="2-4-写数据"><a href="#2-4-写数据" class="headerlink" title="2.4 写数据"></a>2.4 写数据</h2><h3 id="2-4-1-SharedPreferences-Editor"><a href="#2-4-1-SharedPreferences-Editor" class="headerlink" title="2.4.1 SharedPreferences.Editor"></a>2.4.1 SharedPreferences.Editor</h3><p>但是光构建了对象还不够，我们还得能对她进行操作。我们前面说到过，SharedPreferences并不提供修改的功能，如果你想对她进行修改，必须通过<code>SharedPreferences.Editor</code>来实现。</p>
<p>我们来看下<code>SharedPreferences.edit()</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Editor <span class="title function_">edit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> remove the need to call awaitLoadedLocked() when</span></span><br><span class="line">    <span class="comment">// requesting an editor.  will require some work on the</span></span><br><span class="line">    <span class="comment">// Editor, but then we should be able to do:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//      context.getSharedPreferences(..).edit().putString(..).apply()</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// ... all without blocking.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// -&gt;&gt;&gt; 重点1</span></span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建了一个EditorImpl的对象，</span></span><br><span class="line">    <span class="comment">// 但是这块需要注意下，我们想对SharedPreferences进行修改，就必须调用edit()方法，就会去构建一个新的EditorImpl对象</span></span><br><span class="line">    <span class="comment">// 所以为了避免不必要的开销，我们在使用时最好一次性完成对数据的操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EditorImpl</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重点1：SharedPreferencesImpl # awaitLoadedLocked()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GuardedBy(&quot;mLock&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">awaitLoadedLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mLoaded) &#123;</span><br><span class="line">        <span class="comment">// Raise an explicit StrictMode onReadFromDisk for this</span></span><br><span class="line">        <span class="comment">// thread, since the real read will be in a different</span></span><br><span class="line">        <span class="comment">// thread and otherwise ignored by StrictMode.</span></span><br><span class="line">        BlockGuard.getThreadPolicy().onReadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!mLoaded) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果还没有加载完成，就进入等待状态</span></span><br><span class="line">            mLock.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mThrowable != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(mThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-4-2-EditorImpl"><a href="#2-4-2-EditorImpl" class="headerlink" title="2.4.2 EditorImpl"></a>2.4.2 EditorImpl</h3><h4 id="2-4-2-1-putXXX"><a href="#2-4-2-1-putXXX" class="headerlink" title="2.4.2.1 putXXX()"></a>2.4.2.1 putXXX()</h4><p>那我们再来看下<code>putXXX()</code>方法，我们以<code>putString()</code>来举例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EditorImpl</span> <span class="keyword">implements</span> <span class="title class_">Editor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">mEditorLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存数据的HashMap</span></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;mEditorLock&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; mModified = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;mEditorLock&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">mClear</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Editor <span class="title function_">putString</span><span class="params">(String key, <span class="meta">@Nullable</span> String value)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line">            mModified.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><code>putString()</code>方法很简单，直接将数据put到存数据的HashMap中去就行了。或者说，所有的<code>putXXX()</code>都是这么简单。</p>
<p>但是，如果我们想将修改提交到SharedPreferences里面去的话，还需要调用<code>apply()</code>或者<code>commit()</code>方法，那我们现在来看下这两个方法。</p>
<h4 id="2-4-2-2-apply"><a href="#2-4-2-2-apply" class="headerlink" title="2.4.2.2 apply()"></a>2.4.2.2 apply()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 见2.2.3.4</span></span><br><span class="line">    <span class="comment">// 构建了一个MemoryCommitResult的对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">MemoryCommitResult</span> <span class="variable">mcr</span> <span class="operator">=</span> commitToMemory();</span><br><span class="line">    <span class="comment">// 新建一个线程，因为数据操作是很耗时的</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">awaitCommit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 进入等待状态</span></span><br><span class="line">                    mcr.writtenToDiskLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG &amp;&amp; mcr.wasWritten) &#123;</span><br><span class="line">                    Log.d(TAG, mFile.getName() + <span class="string">&quot;:&quot;</span> + mcr.memoryStateGeneration</span><br><span class="line">                            + <span class="string">&quot; applied after &quot;</span> + (System.currentTimeMillis() - startTime)</span><br><span class="line">                            + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将awaitCommit添加到Queue的Word中去</span></span><br><span class="line">    QueuedWork.addFinisher(awaitCommit);</span><br><span class="line"></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">postWriteRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 执行操作，并从QueuedWord中删除</span></span><br><span class="line">                awaitCommit.run();</span><br><span class="line">                QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    SharedPreferencesImpl.<span class="built_in">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Okay to notify the listeners before it&#x27;s hit disk</span></span><br><span class="line">    <span class="comment">// because the listeners should always get the same</span></span><br><span class="line">    <span class="comment">// SharedPreferences instance back, which has the</span></span><br><span class="line">    <span class="comment">// changes reflected in memory.</span></span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-2-3-commit"><a href="#2-4-2-3-commit" class="headerlink" title="2.4.2.3 commit()"></a>2.4.2.3 commit()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">commit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 见2.2.3.4</span></span><br><span class="line">    <span class="comment">// 构建了一个MemoryCommitResult对象</span></span><br><span class="line">    <span class="type">MemoryCommitResult</span> <span class="variable">mcr</span> <span class="operator">=</span> commitToMemory();</span><br><span class="line">    <span class="comment">// 将内存数据同步到文件</span></span><br><span class="line">    <span class="comment">// 见</span></span><br><span class="line">    SharedPreferencesImpl.<span class="built_in">this</span>.enqueueDiskWrite(</span><br><span class="line">        mcr, <span class="literal">null</span> <span class="comment">/* sync write on this thread okay */</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 进入等待状态, 直到写入文件的操作完成</span></span><br><span class="line">        mcr.writtenToDiskLatch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, mFile.getName() + <span class="string">&quot;:&quot;</span> + mcr.memoryStateGeneration</span><br><span class="line">                    + <span class="string">&quot; committed after &quot;</span> + (System.currentTimeMillis() - startTime)</span><br><span class="line">                    + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知监听则, 并在主线程回调onSharedPreferenceChanged()方法</span></span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">    <span class="comment">// 返回文件操作的结果数据</span></span><br><span class="line">    <span class="keyword">return</span> mcr.writeToDiskResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-2-4-commitToMemory"><a href="#2-4-2-4-commitToMemory" class="headerlink" title="2.4.2.4 commitToMemory()"></a>2.4.2.4 commitToMemory()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns true if any changes were made</span></span><br><span class="line"><span class="keyword">private</span> MemoryCommitResult <span class="title function_">commitToMemory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 当前Memory的状态，其实也就是当需要提交数据到内存的时候，他的值就加一</span></span><br><span class="line">    <span class="type">long</span> memoryStateGeneration;</span><br><span class="line">    List&lt;String&gt; keysModified = <span class="literal">null</span>;</span><br><span class="line">    Set&lt;OnSharedPreferenceChangeListener&gt; listeners = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 存数据的Map</span></span><br><span class="line">    Map&lt;String, Object&gt; mapToWriteToDisk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (SharedPreferencesImpl.<span class="built_in">this</span>.mLock) &#123;</span><br><span class="line">        <span class="comment">// We optimistically don&#x27;t make a deep copy until</span></span><br><span class="line">        <span class="comment">// a memory commit comes in when we&#x27;re already</span></span><br><span class="line">        <span class="comment">// writing to disk.</span></span><br><span class="line">        <span class="comment">// 如果有数据待被提交到硬盘</span></span><br><span class="line">        <span class="keyword">if</span> (mDiskWritesInFlight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// We can&#x27;t modify our mMap as a currently</span></span><br><span class="line">            <span class="comment">// in-flight write owns it.  Clone it before</span></span><br><span class="line">            <span class="comment">// modifying it.</span></span><br><span class="line">            <span class="comment">// noinspection unchecked</span></span><br><span class="line">            mMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;(mMap);</span><br><span class="line">        &#125;</span><br><span class="line">        mapToWriteToDisk = mMap;</span><br><span class="line">        <span class="comment">// 2.2.3.5的关键点</span></span><br><span class="line">        mDiskWritesInFlight++;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasListeners</span> <span class="operator">=</span> mListeners.size() &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (hasListeners) &#123;</span><br><span class="line">            keysModified = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">            listeners = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;OnSharedPreferenceChangeListener&gt;(mListeners.keySet());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">changesMade</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果mClear为true，就清空mapToWriteToDisk</span></span><br><span class="line">            <span class="keyword">if</span> (mClear) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mapToWriteToDisk.isEmpty()) &#123;</span><br><span class="line">                    changesMade = <span class="literal">true</span>;</span><br><span class="line">                    mapToWriteToDisk.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                mClear = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">k</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">                <span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">                <span class="comment">// &quot;this&quot; is the magic value for a removal mutation. In addition,</span></span><br><span class="line">                <span class="comment">// setting a value to &quot;null&quot; for a given key is specified to be</span></span><br><span class="line">                <span class="comment">// equivalent to calling remove on that key.</span></span><br><span class="line">                <span class="keyword">if</span> (v == <span class="built_in">this</span> || v == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!mapToWriteToDisk.containsKey(k)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mapToWriteToDisk.remove(k);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mapToWriteToDisk.containsKey(k)) &#123;</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">existingValue</span> <span class="operator">=</span> mapToWriteToDisk.get(k);</span><br><span class="line">                        <span class="keyword">if</span> (existingValue != <span class="literal">null</span> &amp;&amp; existingValue.equals(v)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mapToWriteToDisk.put(k, v);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                changesMade = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (hasListeners) &#123;</span><br><span class="line">                    keysModified.add(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mModified.clear();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (changesMade) &#123;</span><br><span class="line">                mCurrentMemoryStateGeneration++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            memoryStateGeneration = mCurrentMemoryStateGeneration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MemoryCommitResult</span>(memoryStateGeneration, keysModified, listeners,</span><br><span class="line">            mapToWriteToDisk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码刚开始看的时候有点晕，但是看完后就瞬间懂了，这段代码主要执行了一下的功能：</p>
<ul>
<li>将<code>mMap</code>赋值给<code>mapToWriteToDisk</code></li>
<li>当<code>mClear</code>为true的时候，清空<code>mapToWriteToDisk</code></li>
<li>遍历<code>mModified</code>，<code>mModified</code>也就是我们上面说到的保存本次edit的数据的HashMap<ul>
<li>当当前的<code>value</code>为null或者<code>this</code>的时候，移除对应的k</li>
</ul>
</li>
<li>构建了一个<code>MemoryCommitResult</code>对象</li>
</ul>
<h4 id="2-4-2-5-SharedPreferencesImpl-enqueueDiskWrite"><a href="#2-4-2-5-SharedPreferencesImpl-enqueueDiskWrite" class="headerlink" title="2.4.2.5 SharedPreferencesImpl # enqueueDiskWrite()"></a>2.4.2.5 SharedPreferencesImpl # enqueueDiskWrite()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueueDiskWrite</span><span class="params">(<span class="keyword">final</span> MemoryCommitResult mcr,</span></span><br><span class="line"><span class="params">                              <span class="keyword">final</span> Runnable postWriteRunnable)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isFromSyncCommit</span> <span class="operator">=</span> (postWriteRunnable == <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">writeToDiskRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mWritingToDiskLock) &#123;</span><br><span class="line">                    <span class="comment">// 这个方法这块就不讲了，太长了，大家感兴趣可以看下</span></span><br><span class="line">                    <span class="comment">// 主要功能就是</span></span><br><span class="line">                    <span class="comment">//  1. 当没有key没有改变，则直接返回了；否则执行下一步</span></span><br><span class="line">                    <span class="comment">//  2. 将mMap全部信息写入文件，如果写入成功则删除备份文件，如果写入失败则删除mFile</span></span><br><span class="line">                    writeToFile(mcr, isFromSyncCommit);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    <span class="comment">// 当写入成功后，将标志位减1</span></span><br><span class="line">                    mDiskWritesInFlight--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 此时postWriteRunnable为null不执行该方法</span></span><br><span class="line">                <span class="keyword">if</span> (postWriteRunnable != <span class="literal">null</span>) &#123;</span><br><span class="line">                    postWriteRunnable.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Typical #commit() path with fewer allocations, doing a write on</span></span><br><span class="line">    <span class="comment">// the current thread.</span></span><br><span class="line">    <span class="comment">// 如果是commit则进入</span></span><br><span class="line">    <span class="keyword">if</span> (isFromSyncCommit) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">wasEmpty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="comment">// 由于commitToMemory会让mDiskWritesInFlight+1，则wasEmpty为true</span></span><br><span class="line">            wasEmpty = mDiskWritesInFlight == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (wasEmpty) &#123;</span><br><span class="line">            <span class="comment">// 在执行一遍上面的操作，保证将commit的内容也保存</span></span><br><span class="line">            writeToDiskRunnable.run();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是apply()方法，则会将任务放入单线程的线程池中去执行</span></span><br><span class="line">    QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以从这个方法我们可以看到：</p>
<ul>
<li><code>commit()</code>是直接同步执行的，有数据就存入磁盘</li>
<li><code>apply()</code>是先将<code>awaitCommit</code>放入<code>QueuedWork</code>，然后在单线程的线程池中去执行，执行完毕后再将<code>awaitCommit</code>从<code>QeueudWork</code>中移除。</li>
</ul>
<h1 id="3-知识点"><a href="#3-知识点" class="headerlink" title="3. 知识点"></a>3. 知识点</h1><h2 id="3-1-apply和commit的区别"><a href="#3-1-apply和commit的区别" class="headerlink" title="3.1 apply和commit的区别"></a>3.1 apply和commit的区别</h2><ul>
<li>apply没有返回值, commit有返回值能知道修改是否提交成功</li>
<li>apply是将修改提交到内存，再异步提交到磁盘文件; commit是同步的提交到磁盘文件;</li>
<li>多并发的提交commit时，需等待正在处理的commit数据更新到磁盘文件后才会继续往下执行，从而降低效率; 而apply只是原子更新到内存，后调用apply函数会直接覆盖前面内存数据，从一定程度上提高很多效率。</li>
</ul>
<h2 id="3-2-多进程的问题"><a href="#3-2-多进程的问题" class="headerlink" title="3.2 多进程的问题"></a>3.2 多进程的问题</h2><p>我们前面说到了，SP提供了多进程访问，虽说没有像World模式那样会直接抛异常，但是官方不建议多进程下使用SP。</p>
<p>那么我们不禁会好奇，多进程下访问SP会有什么问题呢？</p>
<p>探究这个问题，我们得先回到<code>ContextImpl#getSharedPreferences(File file, int mode)</code>方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SharedPreferences <span class="title function_">getSharedPreferences</span><span class="params">(File file, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">    <span class="comment">// ...前面的代码省略的，如果大家想回忆下，可以跳转到2.1节</span></span><br><span class="line">    <span class="keyword">if</span> ((mode &amp; Context.MODE_MULTI_PROCESS) != <span class="number">0</span> ||</span><br><span class="line">        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        <span class="comment">// If somebody else (some other process) changed the prefs</span></span><br><span class="line">        <span class="comment">// file behind our back, we reload it.  This has been the</span></span><br><span class="line">        <span class="comment">// historical (if undocumented) behavior.</span></span><br><span class="line">        <span class="comment">// -&gt;&gt;&gt; 重点1</span></span><br><span class="line">        sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重点1 SharedPreferencesImpl # startReloadIfChangedUnexpectedly()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">startReloadIfChangedUnexpectedly</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> wait for any pending writes to disk?</span></span><br><span class="line">        <span class="comment">// -&gt;&gt;&gt; 重点2</span></span><br><span class="line">        <span class="keyword">if</span> (!hasFileChangedUnexpectedly()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// -&gt;&gt;&gt; 重点3</span></span><br><span class="line">        startLoadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重点2 SharedPreferencesImpl # hasFileChangedUnexpectedly()</span></span><br><span class="line"><span class="comment"> *  如果文件发生了预期之外的修改，也就是说有其他进程在修改，就返回true，否则false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasFileChangedUnexpectedly</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 如果mDiskWritesInFlight大于0，就证明是在当前进程中修改的，那就不用重新读取</span></span><br><span class="line">        <span class="keyword">if</span> (mDiskWritesInFlight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If we know we caused it, it&#x27;s not unexpected.</span></span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">&quot;disk write in flight, not unexpected.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> StructStat stat;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Metadata operations don&#x27;t usually count as a block guard</span></span><br><span class="line"><span class="comment">         * violation, but we explicitly want this one.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BlockGuard.getThreadPolicy().onReadFromDisk();</span><br><span class="line">        stat = Os.stat(mFile.getPath());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">return</span> !stat.st_mtim.equals(mStatTimestamp) || mStatSize != stat.st_size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重点3 SharedPreferencesImpl # startLoadFromDisk()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startLoadFromDisk</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        mLoaded = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;SharedPreferencesImpl-load&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// -&gt;&gt;&gt; 重点4，这块代码可以回到2.2.3看一下</span></span><br><span class="line">            loadFromDisk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以看到：每次获取SharedPreferences实例的时候尝试从磁盘中加载数据，并且是在异步线程中，因此一个线程的修改最终会反映到另一个线程，但不能立即反映到另一个进程，所以通过SharedPreferences无法实现多进程同步。</p>
<p><code>loadFromDisk()</code>方法中我们最需要关注的是这一段：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果备份文件已经存在，那就删除源文件，并将备份文件替换为源文件</span></span><br><span class="line"><span class="keyword">if</span> (mBackupFile.exists()) &#123;</span><br><span class="line">    mFile.delete();</span><br><span class="line">    mBackupFile.renameTo(mFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这块判断了<code>mBackupFile</code>是否存在，那<code>mBackupFile</code>我们是在哪创建的呢？<br>整个SharedPreferencesImpl中有两处：</p>
<ul>
<li>构造方法：会调用<code>makeBackupFile()</code>给传入的<code>file</code>构造一个<code>mBackupFile</code></li>
<li>writeToFile()：在写入到磁盘的文件时，如果没有<code>mBackupFile</code>，就会根据当前的<code>mFile</code>重命名为<code>mBackupFile</code></li>
</ul>
<p>而<code>writeToFile()</code>在<code>enqueueDiskWrite()</code>中被调用，这个方法太长了，我截取下关键信息：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GuardedBy(&quot;mWritingToDiskLock&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeToFile</span><span class="params">(MemoryCommitResult mcr, <span class="type">boolean</span> isFromSyncCommit)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">fileExists</span> <span class="operator">=</span> mFile.exists();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Rename the current file so it may be used as a backup during the next read</span></span><br><span class="line">    <span class="keyword">if</span> (fileExists) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">backupFileExists</span> <span class="operator">=</span> mBackupFile.exists();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!backupFileExists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mFile.renameTo(mBackupFile)) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;Couldn&#x27;t rename file &quot;</span> + mFile</span><br><span class="line">                      + <span class="string">&quot; to backup file &quot;</span> + mBackupFile);</span><br><span class="line">                mcr.setDiskWriteResult(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mFile.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attempt to write the file, delete the backup and return true as atomically as</span></span><br><span class="line">    <span class="comment">// possible.  If any exception occurs, delete the new file; next time we will restore</span></span><br><span class="line">    <span class="comment">// from the backup.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">str</span> <span class="operator">=</span> createFileOutputStream(mFile);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</span><br><span class="line"></span><br><span class="line">        writeTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        FileUtils.sync(str);</span><br><span class="line"></span><br><span class="line">        fsyncTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        str.close();</span><br><span class="line">        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">StructStat</span> <span class="variable">stat</span> <span class="operator">=</span> Os.stat(mFile.getPath());</span><br><span class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                mStatTimestamp = stat.st_mtim;</span><br><span class="line">                mStatSize = stat.st_size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            fstatTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Writing was successful, delete the backup file if there is one.</span></span><br><span class="line">        mBackupFile.delete();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><br>所以我们大致总结下这个方法的功能：</p>
<ul>
<li>如果源文件<code>mFIle</code>存在并且备份文件<code>mBackupFile</code>不存在，就将源文件重命名为备份文件，如果源文件存在并且备份文件存在，就删除源文件</li>
<li>重新创建源文件<code>mFile</code>，并将内容写进去</li>
<li>删除<code>mBackupFile</code></li>
</ul>
<p>结合一下<code>loadFromDisk()</code>和<code>writeToFile()</code>两个方法，我们可以推测出：当存在两个进程，一个读进程，一个写进程，由于只有在创建<code>SharedPreferencesImpl</code>的时候创建了一个备份进程，此时读进程会将源文件删除，并将备份文件重命名为源文件，这样的结果就是，读进程永远只会看到写之前的内容。并且由于写文件需要调用<code>createFileOutputStream(mFile)</code>，但是这个时候由于源文件被读进程删除了，所以导致写进程的<code>mFIle</code>没有了引用，也就会创建失败，导致修改的数据无法更新到文件上，进而导致数据丢失。</p>
<h2 id="3-3-建议优化"><a href="#3-3-建议优化" class="headerlink" title="3.3 建议优化"></a>3.3 建议优化</h2><ul>
<li>不要在SP中存储较大的key或者value</li>
<li>只是用MODE_PRIVATE模式，其它模式都不要使用(也被弃用了)</li>
<li>可以的话，尽量获取一次Editor然后提交所有的数据</li>
<li>不要高频使用apply，因为他每次都会新建一个线程；使用commit的时需谨慎，因为他在主线程中操作(对，就是主线程，主线程并不是只能更新UI，但是还是就把主线程当做更新UI的为好，我们的耗时操作最好不要在主线程中)</li>
<li>如果需要在多进程中存储数据，建议使用ContentProvider</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码</tag>
        <tag>SharedPreferences</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title>Android网络请求4--解析Retrofit源码</title>
    <url>/posts/a2a8de56.html</url>
    <content><![CDATA[<h1 id="1-Retrofit简介"><a href="#1-Retrofit简介" class="headerlink" title="1. Retrofit简介"></a>1. Retrofit简介</h1><ul>
<li><a href="https://github.com/square/retrofit">Retrofit - github</a></li>
<li><a href="https://square.github.io/retrofit/">Retrofit - Doc</a></li>
</ul>
<p><code>Retrofit</code>是Square公司的又一力作，针对Android网络请求的框架，遵循<code>Restful</code>设计风格，底层基于<code>OkHttp</code>。<br><span id="more"></span></p>
<p>他对比其他框架</p>
<ul>
<li>性能最好</li>
<li>封装程度高，拓展性差</li>
<li>简介易用，代码简单</li>
<li>解耦彻底</li>
<li>可以非常方便的与RxJava连用</li>
</ul>
<h1 id="2-Retrofit用法（异步）"><a href="#2-Retrofit用法（异步）" class="headerlink" title="2. Retrofit用法（异步）"></a>2. Retrofit用法（异步）</h1><h2 id="2-1-添加依赖"><a href="#2-1-添加依赖" class="headerlink" title="2.1 添加依赖"></a>2.1 添加依赖</h2><p>可以在Retrofit Github库页面里面找到最新版本号，我写这篇博客时最新版导入方式</p>
<p>在你项目的app的<code>build.gradle</code>里面添加<br><code>implementation &#39;com.squareup.retrofit2:retrofit:2.6.1&#39;</code></p>
<p>同时，如果你需要配套的数据转换器还需要导入以下的依赖</p>
<ul>
<li>Gson: <code>com.squareup.retrofit2:converter-gson</code></li>
<li>Jackson: <code>com.squareup.retrofit2:converter-jackson</code></li>
<li>Moshi: <code>com.squareup.retrofit2:converter-moshi</code></li>
<li>Protobuf: <code>com.squareup.retrofit2:converter-protobuf</code></li>
<li>Wire: <code>com.squareup.retrofit2:converter-wire</code></li>
<li>Simple XML: <code>com.squareup.retrofit2:converter-simplexml</code></li>
<li>Scalars (primitives, boxed, and String): <code>com.squareup.retrofit2:converter-scalars</code></li>
</ul>
<h2 id="2-2-添加网络权限"><a href="#2-2-添加网络权限" class="headerlink" title="2.2 添加网络权限"></a>2.2 添加网络权限</h2><p>在你APP的AndroidManifest.xml里添加<br><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</code></p>
<h2 id="2-3-创建-接收服务器返回数据-的类"><a href="#2-3-创建-接收服务器返回数据-的类" class="headerlink" title="2.3 创建 接收服务器返回数据 的类"></a>2.3 创建 接收服务器返回数据 的类</h2><p><em>Reception.java</em><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">puublic <span class="keyword">class</span> <span class="title class_">Reception</span> &#123;</span><br><span class="line">    <span class="comment">// 根据返回数据的格式和数据解析方式定义</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-4-创建-用于描述网络请求-的接口"><a href="#2-4-创建-用于描述网络请求-的接口" class="headerlink" title="2.4 创建 用于描述网络请求 的接口"></a>2.4 创建 用于描述网络请求 的接口</h2><p><em>GetRequest_Interface.interface</em><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GetRequest_Interface</span> &#123;</span><br><span class="line">    <span class="meta">@GET(&quot;openapi.do?keyfrom=Yanzhikai&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car&quot;)</span></span><br><span class="line">    Call&lt;Translation&gt;  <span class="title function_">getCall</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// @GET注解的作用:采用Get方法发送网络请求</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// getCall() = 接收网络请求数据的方法</span></span><br><span class="line">    <span class="comment">// 其中返回类型为Call&lt;*&gt;，*是接收数据的类（即上面定义的Translation类）</span></span><br><span class="line">    <span class="comment">// 如果想直接获得Responsebody中的内容，可以定义网络请求返回值为Call&lt;ResponseBody&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-5-创建Retrofit实例"><a href="#2-5-创建Retrofit实例" class="headerlink" title="2.5 创建Retrofit实例"></a>2.5 创建Retrofit实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Retrofit</span> <span class="variable">retrofit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">               .baseUrl(<span class="string">&quot;http://fanyi.youdao.com/&quot;</span>) <span class="comment">// 设置网络请求的Url地址</span></span><br><span class="line">               .addConverterFactory(GsonConverterFactory.create()) <span class="comment">// 设置数据解析器</span></span><br><span class="line">               .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) <span class="comment">// 支持RxJava平台</span></span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure>
<h2 id="2-6-创建网络请求接口实例"><a href="#2-6-创建网络请求接口实例" class="headerlink" title="2.6 创建网络请求接口实例"></a>2.6 创建网络请求接口实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 网络请求接口 的实例</span></span><br><span class="line"><span class="type">GetRequest_Interface</span> <span class="variable">request</span> <span class="operator">=</span> retrofit.create(GetRequest_Interface.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对 发送请求 进行封装</span></span><br><span class="line">Call&lt;Reception&gt; call = request.getCall();</span><br></pre></td></tr></table></figure>
<h2 id="2-7-发送网络请求"><a href="#2-7-发送网络请求" class="headerlink" title="2.7 发送网络请求"></a>2.7 发送网络请求</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送网络请求(异步)</span></span><br><span class="line">call.enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>&lt;Translation&gt;() &#123;</span><br><span class="line">    <span class="comment">//请求成功时回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call&lt;Translation&gt; call, Response&lt;Translation&gt; response)</span> &#123;</span><br><span class="line">        <span class="comment">//请求处理,输出结果</span></span><br><span class="line">        response.body().show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求失败时候的回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call&lt;Translation&gt; call, Throwable throwable)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="2-8-处理返回数据"><a href="#2-8-处理返回数据" class="headerlink" title="2.8 处理返回数据"></a>2.8 处理返回数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送网络请求(异步)</span></span><br><span class="line">call.enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>&lt;Translation&gt;() &#123;</span><br><span class="line">    <span class="comment">//请求成功时回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call&lt;Translation&gt; call, Response&lt;Translation&gt; response)</span> &#123;</span><br><span class="line">        <span class="comment">// 对返回数据进行处理</span></span><br><span class="line">        response.body().show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求失败时候的回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call&lt;Translation&gt; call, Throwable throwable)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>由于本文的核心不是讲用法，所以关于用法这块，我并没有多讲，大家若想多了解，可以看此博客：<a href="https://blog.csdn.net/carson_ho/article/details/73732076">这是一份很详细的 Retrofit 2.0 使用教程（含实例讲解）</a></p>
<h1 id="3-Retrofit源码"><a href="#3-Retrofit源码" class="headerlink" title="3. Retrofit源码"></a>3. Retrofit源码</h1><h2 id="3-1-Retrofit对象构造源码"><a href="#3-1-Retrofit对象构造源码" class="headerlink" title="3.1 Retrofit对象构造源码"></a>3.1 Retrofit对象构造源码</h2><p>应对一个框架的源码首先从使用它的地方开始，我们先来看<code>Retrofit</code>的创建代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Retrofit</span> <span class="variable">retrofit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">       .baseUrl(<span class="string">&quot;http://fanyi.youdao.com/&quot;</span>)</span><br><span class="line">       .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">       .build();</span><br></pre></td></tr></table></figure></p>
<p>我们可以把它分为5个部分来分析源码：<br><img src="https://user-gold-cdn.xitu.io/2018/3/7/161fdeda6c0120c1?imageslim" alt="源码分析步骤"></p>
<p>我们首先来看第一步</p>
<h3 id="3-1-1-步骤1：Retrofit类"><a href="#3-1-1-步骤1：Retrofit类" class="headerlink" title="3.1.1 步骤1：Retrofit类"></a>3.1.1 步骤1：Retrofit类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Retrofit</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 网络请求工厂</span></span><br><span class="line">    <span class="keyword">final</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">    <span class="comment">// 请求的Url地址</span></span><br><span class="line">    <span class="keyword">final</span> HttpUrl baseUrl;</span><br><span class="line">    <span class="comment">// 数据转换器工厂的集合</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories;</span><br><span class="line">    <span class="comment">// 网络请求适配器工厂的集合</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories;</span><br><span class="line">    <span class="comment">// 回调</span></span><br><span class="line">    <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">    <span class="comment">// 是否提前对业务接口中的注解进行验证转换的标志位</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line">    Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,</span><br><span class="line">        List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; callAdapterFactories,</span><br><span class="line">        <span class="meta">@Nullable</span> Executor callbackExecutor, <span class="type">boolean</span> validateEagerly) &#123;</span><br><span class="line">        <span class="built_in">this</span>.callFactory = callFactory;</span><br><span class="line">        <span class="built_in">this</span>.baseUrl = baseUrl;</span><br><span class="line">        <span class="built_in">this</span>.converterFactories = converterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">        <span class="built_in">this</span>.callAdapterFactories = callAdapterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">        <span class="built_in">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">        <span class="built_in">this</span>.validateEagerly = validateEagerly;</span><br><span class="line">    &#125;</span><br><span class="line">    ...<span class="comment">// 省略后面的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Retrofit</code>的构造方法需要一次性把需要的数据全部准备好。<br>而且这块有特别多的工厂，使用了工厂模式。这个我们之后再讲，接下来看步骤2：</p>
<h3 id="3-1-2-步骤2：Builder-方法"><a href="#3-1-2-步骤2：Builder-方法" class="headerlink" title="3.1.2 步骤2：Builder()方法"></a>3.1.2 步骤2：Builder()方法</h3><p>我们先来看下<code>Builder()</code>方法的源码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Platform.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用了<code>Rlatform.get()</code>方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Platform <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PLATFORM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>PLATFORM</code>的定义就在上面：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Platform</span> <span class="variable">PLATFORM</span> <span class="operator">=</span> findPlatform();</span><br></pre></td></tr></table></figure></p>
<p>我们再来看下<code>findPlatform()</code>方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Platform <span class="title function_">findPlatform</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;android.os.Build&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Android</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Platform</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这块创建了一个<code>Android</code>对象，接着返回了传入<code>true</code>创建的<code>Platform</code>对象。我们再来看下<code>Android</code>类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Android</span> <span class="keyword">extends</span> <span class="title class_">Platform</span> &#123;</span><br><span class="line">    Android() &#123;</span><br><span class="line">        <span class="built_in">super</span>(Build.VERSION.SDK_INT &gt;= <span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> Executor <span class="title function_">defaultCallbackExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回一个默认的回调方法执行器</span></span><br><span class="line">        <span class="comment">// 该执行器作用：切换线程（子-&gt;&gt;主线程），并在主线程（UI线程）中执行回调方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MainThreadExecutor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">        <span class="comment">// 获取与Android 主线程绑定的Handler </span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="comment">// 该Handler是上面获取的与Android 主线程绑定的Handler </span></span><br><span class="line">            <span class="comment">// 在UI线程进行对网络请求返回数据处理等操作。</span></span><br><span class="line">            handler.post(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-1-3-步骤3：baseUrl-方法"><a href="#3-1-3-步骤3：baseUrl-方法" class="headerlink" title="3.1.3 步骤3：baseUrl()方法"></a>3.1.3 步骤3：baseUrl()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Builder <span class="title function_">baseUrl</span><span class="params">(String baseUrl)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(baseUrl, <span class="string">&quot;baseUrl == null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> baseUrl(HttpUrl.get(baseUrl));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后还是调用了一个<code>baseUrl()</code>方法，我们来看看这个<code>baseUrl()</code>方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Builder <span class="title function_">baseUrl</span><span class="params">(HttpUrl baseUrl)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(baseUrl, <span class="string">&quot;baseUrl == null&quot;</span>);</span><br><span class="line">    <span class="comment">// 把URL参数分割成几个路径碎片</span></span><br><span class="line">    List&lt;String&gt; pathSegments = baseUrl.pathSegments();</span><br><span class="line">    <span class="comment">// 检测最后一个碎片来检查URL参数是不是以&quot;/&quot;结尾,不是就抛出异常	</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(pathSegments.get(pathSegments.size() - <span class="number">1</span>))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;baseUrl must end in /: &quot;</span> + baseUrl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.baseUrl = baseUrl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>步骤3用于设置网络请求的<code>Url</code></p>
<h3 id="3-1-4-步骤4：addConverterFactory-方法"><a href="#3-1-4-步骤4：addConverterFactory-方法" class="headerlink" title="3.1.4 步骤4：addConverterFactory()方法"></a>3.1.4 步骤4：addConverterFactory()方法</h3><p>我们先来看看<code>GsonConverterFactory.create()</code>方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> GsonConverterFactory <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> <span class="title class_">Gson</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>又调用了另一个<code>create()</code>方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> GsonConverterFactory <span class="title function_">create</span><span class="params">(Gson gson)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (gson == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;gson == null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GsonConverterFactory</span>(gson);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果传入的<code>gson</code>为空就报异常，不为空就调用<code>GsonConverterFactory</code>的构造方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">GsonConverterFactory</span><span class="params">(Gson gson)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.gson = gson;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以这个方法本质就是返回了一个<code>gson</code>对象给了<code>addConverterFactory()</code>方法，那我们再来看看这个方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 为对象的序列化和反序列化添加转换器工厂。 */</span></span><br><span class="line"><span class="keyword">public</span> Builder <span class="title function_">addConverterFactory</span><span class="params">(Converter.Factory factory)</span> &#123;</span><br><span class="line">    converterFactories.add(Objects.requireNonNull(factory, <span class="string">&quot;factory == null&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>步骤4创建了一个含有<code>Gson</code>实例的<code>GsonConverterFactory</code>对象，并放入了<code>ConverterFactory</code>。</p>
<h3 id="3-1-5-步骤5：build-方法"><a href="#3-1-5-步骤5：build-方法" class="headerlink" title="3.1.5 步骤5：build()方法"></a>3.1.5 步骤5：build()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Retrofit <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (baseUrl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Base URL required.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 配置网络请求执行器</span></span><br><span class="line">    okhttp3.Call.<span class="type">Factory</span> <span class="variable">callFactory</span> <span class="operator">=</span> <span class="built_in">this</span>.callFactory;</span><br><span class="line">    <span class="comment">// 如果没有指定callFactory，则创建OkHttpClient</span></span><br><span class="line">    <span class="keyword">if</span> (callFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        callFactory = <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 配置回调执行器</span></span><br><span class="line">    <span class="type">Executor</span> <span class="variable">callbackExecutor</span> <span class="operator">=</span> <span class="built_in">this</span>.callbackExecutor;</span><br><span class="line">    <span class="keyword">if</span> (callbackExecutor == <span class="literal">null</span>) &#123;</span><br><span class="line">        callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置网络请求适配器工厂</span></span><br><span class="line">    List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.callAdapterFactories);</span><br><span class="line">    callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置数据转换器工厂</span></span><br><span class="line">    List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">        <span class="number">1</span> + <span class="built_in">this</span>.converterFactories.size() + platform.defaultConverterFactoriesSize());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先添加内置转换器工厂。这可以防止重写它的行为，但也可以确保在使用使用使用所有类型的转换器时正确的行为。</span></span><br><span class="line">    converterFactories.add(<span class="keyword">new</span> <span class="title class_">BuiltInConverters</span>());</span><br><span class="line">    converterFactories.addAll(<span class="built_in">this</span>.converterFactories);</span><br><span class="line">    converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">        unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按前面配置的变量，将<code>Retrofit</code>所有的变量都配置好，最后完成创建<code>Retrofit</code>实例。</p>
<p>到这Retrofit的创建部分就完了。<br>Retrofit通过建造者模式创建了一个Retrofit实例：</p>
<ul>
<li>请求工厂callFactory：默认是OkHttpClient</li>
<li>数据转换器工厂converterFactories</li>
<li>网络请求适配器工厂callAdapterFactories：默认是ExecutorCallAdapterFactory</li>
<li>回调执行器callbackExecutor</li>
</ul>
<p><img src="https://cdn.littlecorgi.top/mweb/Retrofit对象构建流程.jpg" alt="Retrofit对象构建流程"></p>
<h2 id="3-2-创建网络请求接口的实例"><a href="#3-2-创建网络请求接口的实例" class="headerlink" title="3.2 创建网络请求接口的实例"></a>3.2 创建网络请求接口的实例</h2><p>大致创建方法如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- Reception.java --&gt;</span><br><span class="line">puublic <span class="keyword">class</span> <span class="title class_">Reception</span> &#123;</span><br><span class="line">    <span class="comment">// 根据返回数据的格式和数据解析方式定义</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- GetRequest_Interface.interface --&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GetRequest_Interface</span> &#123;</span><br><span class="line">    <span class="meta">@GET(&quot;openapi.do?keyfrom=Yanzhikai&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car&quot;)</span></span><br><span class="line">    Call&lt;Translation&gt;  <span class="title function_">getCall</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// @GET注解的作用:采用Get方法发送网络请求</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// getCall() = 接收网络请求数据的方法</span></span><br><span class="line">    <span class="comment">// 其中返回类型为Call&lt;*&gt;，*是接收数据的类（即上面定义的Translation类）</span></span><br><span class="line">    <span class="comment">// 如果想直接获得Responsebody中的内容，可以定义网络请求返回值为Call&lt;ResponseBody&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- MainActivity.java --&gt;</span><br><span class="line"><span class="comment">// 创建 网络请求接口 的实例</span></span><br><span class="line"><span class="type">GetRequest_Interface</span> <span class="variable">request</span> <span class="operator">=</span> retrofit.create(GetRequest_Interface.class);</span><br><span class="line"><span class="comment">//对 发送请求 进行封装</span></span><br><span class="line">Call&lt;Reception&gt; call = request.getCall();</span><br></pre></td></tr></table></figure></p>
<p>我们先看看<code>retrofit.create()</code>干了啥：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> &#123;</span><br><span class="line">    validateServiceInterface(service);</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Platform</span> <span class="variable">platform</span> <span class="operator">=</span> Platform.get();</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method,</span></span><br><span class="line"><span class="params">                    <span class="meta">@Nullable</span> Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                <span class="comment">// 如果该方法是来自对象的方法，则推迟到正常调用。</span></span><br><span class="line">                <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">                    <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> loadServiceMethod(method).invoke(args != <span class="literal">null</span> ? args : emptyArgs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先调用了<code>validateServiceInterface()</code>这个方法，我们来看看这个方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">validateServiceInterface</span><span class="params">(Class&lt;?&gt; service)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是接口就抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (!service.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;API declarations must be interfaces.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造了一个容量下限为1的空双向队列来存储数据</span></span><br><span class="line">    Deque&lt;Class&lt;?&gt;&gt; check = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 添加到队列</span></span><br><span class="line">    check.add(service);</span><br><span class="line">    <span class="keyword">while</span> (!check.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 将队列的正向第一个元素移除</span></span><br><span class="line">        Class&lt;?&gt; candidate = check.removeFirst();</span><br><span class="line">        <span class="comment">// getTypeParameters()的作用是得到泛型类型，如果泛型的数量不为0的话进入</span></span><br><span class="line">        <span class="keyword">if</span> (candidate.getTypeParameters().length != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Type parameters are unsupported on &quot;</span>)</span><br><span class="line">                .append(candidate.getName());</span><br><span class="line">            <span class="keyword">if</span> (candidate != service) &#123;</span><br><span class="line">                message.append(<span class="string">&quot; which is an interface of &quot;</span>)</span><br><span class="line">                    .append(service.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(message.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.addAll(check, candidate.getInterfaces());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">        <span class="type">Platform</span> <span class="variable">platform</span> <span class="operator">=</span> Platform.get();</span><br><span class="line">        <span class="keyword">for</span> (Method method : service.getDeclaredMethods()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!platform.isDefaultMethod(method) &amp;&amp; !Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">                loadServiceMethod(method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>获取到<code>Platform</code>（平台），然后再遍历接口中的方法，调用<code>loadServiceMethod()</code>方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">        result = serviceMethodCache.get(method);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            result = ServiceMethod.parseAnnotations(<span class="built_in">this</span>, method);</span><br><span class="line">            serviceMethodCache.put(method, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个方法主要就是通过<code>serviceMethodCache</code>来存储转换为<code>ServiceMethod</code>类型的<code>Method</code>。</p>
<p>那我们在回过去看<code>InvocationHandler</code>的<code>invoke()</code>方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Platform</span> <span class="variable">platform</span> <span class="operator">=</span> Platform.get();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 如果该方法是来自对象的方法，则推迟到正常调用。</span></span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loadServiceMethod(method).invoke(args != <span class="literal">null</span> ? args : emptyArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>两个if先不管，先看最后的<code>return</code>，可以看到他调用了一个<code>loadServiceMethod()</code>方法，而这个方法在前面就说过，主要就返回了一个<code>ServiceMethod</code>。那我们接着来看<code>invoke()</code>方法：<br>按住<code>command+鼠标左键</code>进入后，显示的是：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ServiceMethod</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; ServiceMethod&lt;T&gt; <span class="title function_">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> &#123;</span><br><span class="line">    <span class="type">RequestFactory</span> <span class="variable">requestFactory</span> <span class="operator">=</span> RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line"></span><br><span class="line">    <span class="type">Type</span> <span class="variable">returnType</span> <span class="operator">=</span> method.getGenericReturnType();</span><br><span class="line">    <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(method,</span><br><span class="line">          <span class="string">&quot;Method return type must not include a type variable or wildcard: %s&quot;</span>, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Service methods cannot return void.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="meta">@Nullable</span> T <span class="title function_">invoke</span><span class="params">(Object[] args)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个<code>invoke()</code>根本就是个抽象方法啊，然后我又回去找看看有没有说是哪个继承自<code>ServiceMethod</code>的类实现了这个方法，结果也没找到，最后想到了AndroidStudio可以<code>command+左键</code>找实现了这个类的地方啊。于是我就点了下这个类，结果成功找到了<code>HttpServiceMethod</code>这个类，他是<code>ServiceMethod</code>的子类中唯一一个实现了<code>invoke()</code>方法的：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> ReturnT <span class="title function_">invoke</span><span class="params">(Object[] args)</span> &#123;</span><br><span class="line">    Call&lt;ResponseT&gt; call = <span class="keyword">new</span> <span class="title class_">OkHttpCall</span>&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">    <span class="keyword">return</span> adapt(call, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到这块他创建了一个OkHttpCall对象，此处不做详解，可以看我关于OkHttp的一篇博客：<a href="https://www.littlecorgi.top/posts/151ac78a.html">Android网络请求3—解析OkHttp源码</a>。然后调用了adapt方法，我们来看看这个方法:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="meta">@Nullable</span> ReturnT <span class="title function_">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span>;</span><br></pre></td></tr></table></figure><br>这又是一个抽象方法。只不过好的是，这个方法下面我们就找到了他的实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CallAdapted</span>&lt;ResponseT, ReturnT&gt; <span class="keyword">extends</span> <span class="title class_">HttpServiceMethod</span>&lt;ResponseT, ReturnT&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;</span><br><span class="line"></span><br><span class="line">    CallAdapted(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,</span><br><span class="line">            Converter&lt;ResponseBody, ResponseT&gt; responseConverter,</span><br><span class="line">            CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter) &#123;</span><br><span class="line">        <span class="built_in">super</span>(requestFactory, callFactory, responseConverter);</span><br><span class="line">        <span class="built_in">this</span>.callAdapter = callAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">protected</span> ReturnT <span class="title function_">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> callAdapter.adapt(call);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可是他又返回给了一个<code>CallAdapter</code>接口的实现类的<code>adapt()</code>方法。。。。艹</p>
<p>所以，这块我就不懂了，我不知道他到底咋实现这个的这个方法的，我看了《Android进阶之光》和其它很多博客，他们都是老版本的<code>Retrofit</code>，<code>create()</code>方法不同，而且调用的<code>adapt()</code>方法也不同。。。</p>
<p><img src="https://¡cdn.littlecorgi.top/mweb/Retrofit网络请求接口创建.jpg" alt="Retrofit网络请求接口创建"></p>
<h2 id="3-3-网络请求"><a href="#3-3-网络请求" class="headerlink" title="3.3 网络请求"></a>3.3 网络请求</h2><p>网络请求这块Retrofit实际上就是用OkHttp实现的，所以这块我就不在这多说了，大家要了解的可以看我之前写的博客：<a href="https://www.littlecorgi.top/posts/151ac78a.html">Android网络请求3—解析OkHttp源码</a>。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码</tag>
        <tag>kotlin</tag>
        <tag>OkHttp</tag>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title>Aria2macOS安装</title>
    <url>/posts/4f46fdbb.html</url>
    <content><![CDATA[<blockquote>
<p>对不起大家，在我配置好这个软件之后，我兴冲冲的打开了github想下载下ssr4.0forWindows，迫不及待想感受下aria2的快感，结果发现我错了。<br>下载速度就才几十k/s，那一瞬间，我感触很多，我突然想到我昨晚的迅雷下载同样的资源同样的网同样的vpn下大几百k/s 的速度，然后又看到了此时我给予希望的aria，我陷入了沉思，或许这就是人生吧。<br>突然觉得macOS迅雷，也还挺好看的，也挺好用的，完全没有广告，要下载打开，下载完了就退出，唯一问题就是Chrome的迅雷拓展似乎太灵敏了点，我啥都没点就莫名其妙弹出下载页面，除了这个，似乎非常完美。<br>所以，在我配置好aria2并写下这篇博客后的不到1个小时时间，我卸载了aira2，并重新用上了迅雷。所以，我最后只想说一句，财大nb！财大nb！财大nb！对不起，走错片场了，重来，IDM牛逼！IDM牛逼！IDM牛逼！<br>如果哪位牛逼的大哥看到了这篇博客，记得帮我给IDM说声，一个Windows的IDM正版用户急需IDM macOS版！！！</p>
</blockquote>
<span id="more"></span>
<h1 id="下载Aira2"><a href="#下载Aira2" class="headerlink" title="下载Aira2"></a>下载Aira2</h1><h2 id="通过github安装"><a href="#通过github安装" class="headerlink" title="通过github安装"></a>通过github安装</h2><ul>
<li>打开github主页 <a href="https://github.com/aria2/aria2/releases">aria2/aria2-Release</a></li>
<li>找到对应的系统下载安装即可</li>
</ul>
<h2 id="通过Homebrew安装"><a href="#通过Homebrew安装" class="headerlink" title="通过Homebrew安装"></a>通过Homebrew安装</h2><p>终端输入命令<code>brew install aria2</code>安装即可。<br>没有安装Homebrew的同学可以搜索安装Homebrew即可。</p>
<blockquote>
<p>这个软件是没有图形界面的，所以安装好之后在启动台里面是找不到Aria2的图标的</p>
</blockquote>
<h1 id="配置Aira2"><a href="#配置Aira2" class="headerlink" title="配置Aira2"></a>配置Aira2</h1><h2 id="先创建Aria2的配置文件"><a href="#先创建Aria2的配置文件" class="headerlink" title="先创建Aria2的配置文件"></a>先创建Aria2的配置文件</h2><p>Aria2提供了两种工作模式：</p>
<ol>
<li>直接命令行模式下载<br> 不太推荐这种，因为命令行下下载比较繁琐，而且也不太好操作</li>
<li>RPC模式<br> 在这种方式，Aria2启动之后就会以后台的方式运行，你就可以通过WebUI或者安装客户端的方式来使用图形界面控制Aria2.<br>但是这种方式下需要配置文件，现在就告诉大家如何配置：<br>首先创建文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir /.aria2</span><br><span class="line">cd /.aria2</span><br><span class="line">touch aria2.conf</span><br></pre></td></tr></table></figure>
<p>然后打开Finder，使用快捷键<code>Shift+Cmd+G</code>弹出路径输入框，接着复制粘贴<code>~/.aria2/</code>回车就进入了<code>.aria2</code>文件夹，你就会看到里面的<code>aria2.conf</code>文件，接着用文本编辑器打开，复制粘贴以下内容<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#用户名</span><br><span class="line">#rpc-user=user</span><br><span class="line">#密码</span><br><span class="line">#rpc-passwd=passwd</span><br><span class="line">#上面的认证方式不建议使用,建议使用下面的token方式</span><br><span class="line">#设置加密的密钥</span><br><span class="line">#rpc-secret=token</span><br><span class="line">#允许rpc</span><br><span class="line">enable-rpc=true</span><br><span class="line">#允许所有来源, web界面跨域权限需要</span><br><span class="line">rpc-allow-origin-all=true</span><br><span class="line">#允许外部访问，false的话只监听本地端口</span><br><span class="line">rpc-listen-all=true</span><br><span class="line">#RPC端口, 仅当默认端口被占用时修改</span><br><span class="line">#rpc-listen-port=6800</span><br><span class="line">#最大同时下载数(任务数), 路由建议值: 3</span><br><span class="line">max-concurrent-downloads=5</span><br><span class="line">#断点续传</span><br><span class="line">continue=true</span><br><span class="line">#同服务器连接数</span><br><span class="line">max-connection-per-server=5</span><br><span class="line">#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要</span><br><span class="line">min-split-size=10M</span><br><span class="line">#单文件最大线程数, 路由建议值: 5</span><br><span class="line">split=10</span><br><span class="line">#下载速度限制</span><br><span class="line">max-overall-download-limit=0</span><br><span class="line">#单文件速度限制</span><br><span class="line">max-download-limit=0</span><br><span class="line">#上传速度限制</span><br><span class="line">max-overall-upload-limit=0</span><br><span class="line">#单文件速度限制</span><br><span class="line">max-upload-limit=0</span><br><span class="line">#断开速度过慢的连接</span><br><span class="line">#lowest-speed-limit=0</span><br><span class="line">#验证用，需要1.16.1之后的release版本</span><br><span class="line">#referer=*</span><br><span class="line">#文件保存路径, 默认为当前启动位置</span><br><span class="line">dir=/Users/xxx/Downloads</span><br><span class="line">#文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本</span><br><span class="line">#disk-cache=0</span><br><span class="line">#另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?)</span><br><span class="line">#enable-mmap=true</span><br><span class="line">#文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长</span><br><span class="line">#所需时间 none &lt; falloc ? trunc « prealloc, falloc和trunc需要文件系统和内核支持</span><br><span class="line">file-allocation=prealloc</span><br><span class="line"></span><br><span class="line">#开启BT下载</span><br><span class="line">enable-dht=true</span><br><span class="line">bt-enable-lpd=true</span><br><span class="line">enable-peer-exchange=true</span><br><span class="line"># bt-tracker 更新，解决Aria2 BT下载速度慢没速度的问题</span><br><span class="line">udp://tracker.coppersurfer.tk:6969/announce,http://tracker.internetwarriors.net:1337/announce,udp://tracker.opentrackr.org:1337/announce,udp://9.rarbg.to:2710/announce,udp://9.rarbg.me:2710/announce,udp://tracker.openbittorrent.com:80/announce,http://tracker3.itzmx.com:6961/announce,http://tracker1.itzmx.com:8080/announce,udp://exodus.desync.com:6969/announce,udp://retracker.lanta-net.ru:2710/announce,udp://tracker.torrent.eu.org:451/announce,udp://tracker.tiny-vps.com:6969/announce,udp://bt.xxx-tracker.com:2710/announce,udp://tracker2.itzmx.com:6961/announce,udp://tracker.cyberia.is:6969/announce,udp://open.demonii.si:1337/announce,udp://explodie.org:6969/announce,udp://denis.stalker.upeer.me:6969/announce,udp://open.stealth.si:80/announce,http://tracker4.itzmx.com:2710/announce</span><br></pre></td></tr></table></figure></p>
<p>不用更改啥，也不建议更改啥，大家可以看一下上面的配置内容，至少记得每一项大致是个啥，因为等会配置图形界面需要这些信息。</p>
<p>最后面的BT下载的<code>bt-tracker</code>大家配置记得到这个页面更新：<a href="https://raw.githubusercontent.com/ngosang/trackerslist/master/trackers_best.txt">https://raw.githubusercontent.com/ngosang/trackerslist/master/trackers_best.txt</a></p>
<p>然后再把内容复制粘贴过去。</p>
<p>下载路径你可以自己选择，可以就把<code>/Users/xxx/Downloads</code>中的<code>xxx</code>换成你自己的macOS用户名即可。</p>
<h1 id="启动Aria2-RPC模式"><a href="#启动Aria2-RPC模式" class="headerlink" title="启动Aria2 RPC模式"></a>启动Aria2 RPC模式</h1><p>终端输入<code>aria2c --conf-path=&quot;/Users/xxx/.aria2/aria2.conf&quot; -D</code>就可以启动了。一样的，xxx是你的用户名。</p>
<h1 id="进入图形界面"><a href="#进入图形界面" class="headerlink" title="进入图形界面"></a>进入图形界面</h1><p>Aria2有很多第三方图形界面，客户端有，但是我没用过所以我不做介绍，在这主要介绍WebUI。</p>
<h2 id="YAAW插件"><a href="#YAAW插件" class="headerlink" title="YAAW插件"></a>YAAW插件</h2><ol>
<li>在chrome的拓展中心搜索<code>YAAW</code>，然后安装即可，接着就会出现YAAM的插件</li>
<li>点击打开它，就会进入YAAW的WebUI。<br><img src="https://cdn.littlecorgi.top/mweb/15647112624749.jpg" alt=""></li>
<li>点击右上角的🔧图标，进入设置界面<br><img src="https://cdn.littlecorgi.top/mweb/15647113330438.jpg" alt=""></li>
<li>如果你上面的<code>aria2.conf</code>是直接复制粘贴的我的话，照着我图中的填写就可以了，然后就可以使用了。找到需要下载的资源右键然后选择YAAW就会自动开始下载。</li>
</ol>
<h2 id="AriaNg-WebUI"><a href="#AriaNg-WebUI" class="headerlink" title="AriaNg WebUI"></a>AriaNg WebUI</h2><p>这个比上面那个好看点，缺点是没有插件，你只能复制下载链接手动新建下载任务</p>
<ol>
<li>在浏览器中输入网址 <code>http://ariang.mayswind.net/latest/#!/downloading</code><br><img src="https://cdn.littlecorgi.top/mweb/15647115205711.jpg" alt=""></li>
</ol>
<ol>
<li>点击AriaNg设置<br><img src="https://cdn.littlecorgi.top/mweb/15647115637006.jpg" alt=""></li>
<li>一样，如果你上面的<code>aria2.conf</code>是直接复制粘贴的我的话，照着我图中的填写就可以了，然后就可以使用了。</li>
<li>你可以点击Aria2状态，看看是不是已连接，如果不是就看看有没有哪儿和<code>aria2.conf</code>设置的不一样。<br><img src="https://cdn.littlecorgi.top/mweb/15647116500131.jpg" alt=""></li>
</ol>
<h1 id="关闭Aria2"><a href="#关闭Aria2" class="headerlink" title="关闭Aria2"></a>关闭Aria2</h1><p>这个好像官方没有方法关闭，于是我们就用最简单粗暴的方法。</p>
<ol>
<li>终端输入<code>ps aux|grep aria2</code>得到Aria2的进程号</li>
<li>然后输入<code>kill number</code>调用系统命令直接杀死这个进程，<code>number</code>改为上面的到的进程号即可。</li>
</ol>
<h1 id="配置自启动"><a href="#配置自启动" class="headerlink" title="配置自启动"></a>配置自启动</h1><h2 id="创建sh文件"><a href="#创建sh文件" class="headerlink" title="创建sh文件"></a>创建sh文件</h2><p>进入到希望保存的目录下，新建一个文件<code>aria2.sh</code>：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch aria2.sh</span><br></pre></td></tr></table></figure><br>然后输入下面的代码并保存：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;start aria2 server&quot;</span><br><span class="line">aria2c --conf-path=&quot;/Users/xxx/.aria2/aria2.conf&quot; -D</span><br><span class="line">echo &quot;exiting&quot;</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></p>
<h2 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h2><ol>
<li>给<code>aria2.sh</code>文件执行权限：<code>chmod +x aria2.sh</code></li>
<li>让<code>aria2.sh</code>默认用自己常用的terminal工具打开。右键文件 －&gt; 显示简介：设置“打开方式-&gt;所有应用程序”为自己的terminal即可。</li>
</ol>
<h2 id="添加到开机启动项"><a href="#添加到开机启动项" class="headerlink" title="添加到开机启动项"></a>添加到开机启动项</h2><ol>
<li>在<code>Mac</code>桌面顶部菜单中，点击苹果图标，在弹出的菜单中，点击进入系统偏好设置。</li>
<li>在打开系统偏好设置后，然后点击进入用户与群组设置选项。</li>
<li>然后在用户与群组设置界面，先在左侧选择登陆用户-当前用户，然后在右侧切换到登录项</li>
<li>然后点下面的+进行添加，选择刚才我们创建的文件aria2.sh，并勾选隐藏。<br>这样 aria2 就可以在每次开机的时候自启动了。</li>
</ol>
<h3 id="最后，Aria2卸载方式"><a href="#最后，Aria2卸载方式" class="headerlink" title="最后，Aria2卸载方式"></a>最后，Aria2卸载方式</h3><p>终端下执行<code>sudo pkgutil --forget aria2</code>以及<code>sudo pkgutil --forget aria2.path</code>，然后上面创建的<code>.aria2</code>文件夹</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Aria2</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter入门并开发天气预报APP(1)——Flutter安装</title>
    <url>/posts/4bf666bf.html</url>
    <content><![CDATA[<h1 id="Flutter是什么"><a href="#Flutter是什么" class="headerlink" title="Flutter是什么"></a>Flutter是什么</h1><p>Flutter是由谷歌推出的一个移动UI框架，可以让开发者快速的在Android和iOS上构建高质量的原生用户界面。</p>
<span id="more"></span>
<p>通过它来编写APP的好处在于：</p>
<ul>
<li>它内置了Android的Material Design风格和iOS的Cupertino风格的UI；</li>
<li>它通过Dart语言编写，只需要编写一份代码就能在Android和iOS设备上得到同样的运行效果；</li>
<li>他有热重载功能，只需要运行APP后，代码更改一点然后点击热重载键就能快速显示出修改后的界面。</li>
</ul>
<h1 id="使用镜像安装"><a href="#使用镜像安装" class="headerlink" title="使用镜像安装"></a>使用镜像安装</h1><p>由于一些众所周知的原因，Flutter在国内访问有时候会受到限制，因此Flutter官方为国内开发者搭建了临时镜像，大家可以将下面的环境变量添加到系统中：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line"><span class="built_in">export</span> FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br></pre></td></tr></table></figure><br>由于我用的是macOS，因此我就只演示macOS的。<br>如果有Linux的用户则和macOS 的安装方式类似，甚至可以说一样；<br>但是对于Windows用于，需要大家桌面右键此<code>电脑-&gt;属性-&gt;弹出页面左侧栏的高级系统设置-&gt;环境变量</code>，在下面的系统环境变量栏中点击新建，变量名输入上面等号左边的大写内容，不要export，值输入等号右边的内容，输入一组之后再点击新建接着输入下一组。<br><img src="https://img-blog.csdn.net/20180616140532293?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ExMjAzOTkxNjg2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Windows下的环境变量配置"></p>
<p>接下来我们开始说macOS。</p>
<h2 id="首先你得确定你用的是什么shell"><a href="#首先你得确定你用的是什么shell" class="headerlink" title="首先你得确定你用的是什么shell"></a>首先你得确定你用的是什么shell</h2><p>如果你没更改过你macOS终端设置，那么你默认就是<code>bash</code>，但是如果你更改过，比方说我就换成了<code>zsh</code>，那么我觉得你应该知道在哪设置环境变量。</p>
<h2 id="如果你是bash"><a href="#如果你是bash" class="headerlink" title="如果你是bash"></a>如果你是bash</h2><p>首先打开你macOS的终端，在启动台里面可以找到，接着对<code>bash</code>的环境变量进行设置，输入<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><br>回车，进入<code>.bash_profile</code>文件的编辑页面，然后按下键盘<code>I键</code>，进入vim的编辑模式，然后直接把上面的export环境变量赋值粘贴进去。然后按下<code>Esc键</code>退出vim的编辑模式，然后直接输入<code>:wq</code>回车保存并退出。<br>接着输入<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><br>让刚刚配置的环境变量生效即可。<br><img src="https://cdn.littlecorgi.top/mweb/2019-10-08/bash%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="bash配置环境变量"></p>
<h2 id="如果你是zsh"><a href="#如果你是zsh" class="headerlink" title="如果你是zsh"></a>如果你是zsh</h2><p>首先打开你macOS的终端，在启动台里面可以找到，接着对<code>zsh</code>的环境变量进行设置，输入<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><br>回车，进入<code>.zshrc</code>文件的编辑页面，找到如图所示部分（重点在于有<code># export MANPATH=&quot;/Usrs/......</code>的地方，因为我还有其它的环境变量，所以你的可能和我的不同）：<br><img src="https://cdn.littlecorgi.top/mweb/2019-10-08/zshrc.png" alt="zshr"></p>
<p>在<code># export</code>下面，按下键盘<code>I键</code>，进入vim的编辑模式，然后直接把上面的export环境变量赋值粘贴进去。<br>见我图中最下面标红的那地方，至于最后一行<code>export PATH=~/development/flutter/bin:$PATH</code>先不管。然后按下<code>Esc键</code>退出vim的编辑模式，然后直接输入<code>:wq</code>回车保存并退出。<br>接着输入<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><br>让刚刚配置的环境变量生效即可。<br><img src="https://cdn.littlecorgi.top/mweb/2019-10-08/zsh%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="zsh配置环境变量"></p>
<h1 id="下载Flutter-SDK"><a href="#下载Flutter-SDK" class="headerlink" title="下载Flutter SDK"></a>下载Flutter SDK</h1><h2 id="先去Flutter的官网去下载你对应系统的Flutter-SDK"><a href="#先去Flutter的官网去下载你对应系统的Flutter-SDK" class="headerlink" title="先去Flutter的官网去下载你对应系统的Flutter SDK"></a>先去Flutter的官网去下载你对应系统的Flutter SDK</h2><ol>
<li>打开官网下载页：<a href="https://flutter.dev/docs/development/tools/sdk/releases">Flutter SDK release</a></li>
<li>选择你的系统对应的目录，然后默认选择Stable channel下载。(*Master channel这个是直接从github获取的github上的最新版，也就是说Flutter的开发者他写了点什么改了点什么都会里面在这个版本上显示出来，所以这个版本意味着非常不稳定，可能bug很多；Dev channel是开发版，Master channel经过一定测试之后的版本会发布到Dev channel上，但是不是大量的测试，所以可能还是不太稳定；Beta channel是测试版，每月发布一次，会把上个月所释放的所有Dev channel中最稳定的版本释放到Beta channel上，但是相对来说还是有点不稳定，适合想尝鲜的开发者；State channel是标准版，当Flutter维护人员认为某个版本足够稳定之后，就会发送到这个版本上去，一般开发者最好还是使用这个版本)</li>
</ol>
<h2 id="解压安装包到你想要的目录"><a href="#解压安装包到你想要的目录" class="headerlink" title="解压安装包到你想要的目录"></a>解压安装包到你想要的目录</h2><p>例如<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Linux/macOS</span><br><span class="line">cd ~/development</span><br><span class="line">unzip ~/Downloads/flutter_macos_v0.5.1-beta.zip</span><br></pre></td></tr></table></figure></p>
<h2 id="添加Fluuter路径到环境变量中"><a href="#添加Fluuter路径到环境变量中" class="headerlink" title="添加Fluuter路径到环境变量中"></a>添加Fluuter路径到环境变量中</h2><p>回顾第2项，把如下内容添加到环境变量中去<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/你上一步flutter解压的目录/flutter/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></p>
<h2 id="运行Flutter-doctor"><a href="#运行Flutter-doctor" class="headerlink" title="运行Flutter doctor"></a>运行Flutter doctor</h2><p>如果是macOS/Linux，直接在终端中输入<code>flutter doctor</code>即可。<br>如果是Windows，则右键开始，选择PowerShell，然后输入<code>flutter doctor</code>即可。</p>
<p>这个命令的功能是检查你的Flutter是否正常安装。</p>
<p>如果正常安装的话会出现如下信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Doctor summary (to see all details, run flutter doctor -v):</span><br><span class="line">[✓] Flutter (Channel stable, v1.9.1+hotfix.4, on Mac OS X 10.13.6 17G65, locale zh-Hans-CN)</span><br><span class="line"> </span><br><span class="line">[✓] Android toolchain - develop <span class="keyword">for</span> Android devices (Android SDK version 29.0.1)</span><br><span class="line">[✗] Xcode - develop <span class="keyword">for</span> iOS and macOS</span><br><span class="line">    ✗ Xcode installation is incomplete; a full installation is necessary <span class="keyword">for</span> iOS development.</span><br><span class="line">      Download at: https://developer.apple.com/xcode/download/</span><br><span class="line">      Or install Xcode via the App Store.</span><br><span class="line">      Once installed, run:</span><br><span class="line">        sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer</span><br><span class="line">    ✗ CocoaPods not installed.</span><br><span class="line">        CocoaPods is used to retrieve the iOS and macOS platform side<span class="string">&#x27;s plugin code that responds to</span></span><br><span class="line"><span class="string">        your plugin usage on the Dart side.</span></span><br><span class="line"><span class="string">        Without CocoaPods, plugins will not work on iOS or macOS.</span></span><br><span class="line"><span class="string">        For more info, see https://flutter.dev/platform-plugins</span></span><br><span class="line"><span class="string">      To install:</span></span><br><span class="line"><span class="string">        sudo gem install cocoapods</span></span><br><span class="line"><span class="string">        pod setup</span></span><br><span class="line"><span class="string">[✓] Android Studio (version 3.5)</span></span><br><span class="line"><span class="string">[!] IntelliJ IDEA Community Edition (version 2019.2.3)</span></span><br><span class="line"><span class="string">    ✗ Flutter plugin not installed; this adds Flutter specific functionality.</span></span><br><span class="line"><span class="string">    ✗ Dart plugin not installed; this adds Dart specific functionality.</span></span><br><span class="line"><span class="string">[✓] VS Code (version 1.38.1)</span></span><br><span class="line"><span class="string">[✓] Connected device (1 available)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">! Doctor found issues in 2 categories.</span></span><br></pre></td></tr></table></figure></p>
<p>我的电脑运行之后会出现两个错误，因为Flutter doctor会自动检查电脑中所有能运行Flutter的编辑器或者IDE，然后判断他们配没配置Flutter。我的电脑是因为没有安装Xcode以及我没有在IDEA中配置Flutter，所以我这两项出错。</p>
<p>其实你只要保证除了IDE之外的项目都是正常的就行了，如果有错的话直接把报错信息放到百度里面进行搜索就可以了。至于IDE项目，如果你是iOS开发者，则保证Xcode或者是AppCode啥的前面是✔️就行了的，至于你电脑上的其它例如IDEA或者vscode啥的可以不用管；如果你是Android开发者，则保证你常用的IDE如Android Studio前面是✔️就行了的，至于你电脑上的其它例如IDEA或者vscode啥的可以不用管。</p>
<p>总而言之，确保除了IDE之外的其它项前面是对勾，然后确定一个你常用的写代码的工具前面有对勾就行了，如果你除了IDE之外的其它项有问题，就把错误信息直接百度；如果是你常用的IDE前面没对勾，那就百度你常用的IDE+Flutter来参考别人的配置教程。</p>
<hr>
<p><em>由于我没有用过xcode所以就不讲xcode如何配置Flutter了，就分别讲如何在AndroidStudio和vscode配置Flutter。</em></p>
<hr>
<h1 id="Android-Studio配置Flutter"><a href="#Android-Studio配置Flutter" class="headerlink" title="Android Studio配置Flutter"></a>Android Studio配置Flutter</h1><ol>
<li><p>打开你Android Studio的<code>设置/首选项/Preferences</code>，然后选择<code>Plugins</code>，在<code>Marketplace</code>里面搜索<code>Flutter</code>：    <img src="https://cdn.littlecorgi.top/mweb/2019-10-08/Androidstudio%20Flutter.png" alt="Androidstudio Flutte"></p>
</li>
<li><p>接着点击<code>INSTALL</code>安装就行了，并且安装Flutter插件会自动顺带安装Dart插件，如果没有安装Dart插件，你就一样的搜索<code>Dart</code>然后安装即可；</p>
</li>
<li>安装完成并重启Android Studio之后，仍然打开<code>设置/首选项/Preferences</code>，选择<code>Languages &amp; Frameworks</code>-&gt;<code>Flutter</code>，在最上面的SDK中的<code>Flutter SDK path</code>选择你第三步Flutter SDK解压缩的路径，不出意外的话下面<code>Version</code>会自动显示你Flutter SDK的版本，并且<code>Languages &amp; Frameworks</code>-&gt;<code>Dart</code>里面的<code>Dart SDK path</code>也会自动出现。<br> <img src="https://cdn.littlecorgi.top/mweb/2019-10-08/Android%20Studio%20Flutter%20Setting.png" alt="Android Studio Flutter Setting"></li>
<li>接着和之前一样运行<code>flutter doctor</code>,看看Android Studio前面有没有✔️，正常情况下是会有的。</li>
</ol>
<h1 id="vscode-配置Flutter"><a href="#vscode-配置Flutter" class="headerlink" title="vscode 配置Flutter"></a>vscode 配置Flutter</h1><ol>
<li><p>在vscode拓展里面搜索Flutter和Dart，安装；<img src="https://cdn.littlecorgi.top/mweb/2019-10-08/vscode%20Flutter.png" alt="vscode Flutte"></p>
</li>
<li><p>接着和之前一样运行<code>flutter doctor</code>,看看vscode前面有没有✔️，正常情况下是会有的。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter入门并开发天气预报APP(2)——Flutter计数器Demo</title>
    <url>/posts/956d1e66.html</url>
    <content><![CDATA[<p>本文样例都是使用的AndroidStudio，如果你使用Xcode或者vscode，代码都是一样的，只是IDE创建项目的方式以及运行按键位置不同而已。</p>
<span id="more"></span>
<h1 id="创建Flutter项目"><a href="#创建Flutter项目" class="headerlink" title="创建Flutter项目"></a>创建Flutter项目</h1><p>AndroidStudio中选择<code>File</code>-&gt;<code>New</code>-&gt;<code>New Flutter Project</code>-&gt;<code>Flutter Application</code>-&gt;<code>NEXT</code>。接着填写你的项目名称等一系列信息后就创建成功了，我们就会看到AndroidStudio已经为我们创建好了一个Demo，接着连上你的手机或者打开你的虚拟机，按下AndroidStudio的运行键，不一会儿，你就会惊喜的发现你的手机上就有一个Flutter计数器Demo了。<br><img src="https://cdn.littlecorgi.top/mweb/2019-10-09/%E8%AE%A1%E6%95%B0%E5%99%A8%E8%BF%90%E8%A1%8CDemo.png" alt="计数器运行Demo"></p>
<h1 id="介绍下AndroidStudio界面"><a href="#介绍下AndroidStudio界面" class="headerlink" title="介绍下AndroidStudio界面"></a>介绍下AndroidStudio界面</h1><p><img src="https://cdn.littlecorgi.top/mweb/2019-10-09/AndroidStudio%E7%95%8C%E9%9D%A2.png" alt="AndroidStudio界面"><br>这是我的AndroidStudio界面，接下来我分三个部分介绍下AndroidStudio的大致界面。</p>
<h2 id="控制区"><a href="#控制区" class="headerlink" title="控制区"></a>控制区</h2><p><img src="https://cdn.littlecorgi.top/mweb/2019-10-09/%E6%8E%A7%E5%88%B6%E5%8C%BA.png" alt="控制区"></p>
<p>一次介绍每一个按钮的功能。</p>
<ol>
<li>第一个是用来选择运行设备的，比方说我现在就选的是我的虚拟机，然后我按下运行后就可以将项目运行到我的虚拟机上而不会运行到连着我的电脑的手机上去；</li>
<li>第二个是选择运行哪个Flutter module，如果你同一个项目里面有多个module，你就可以在此选择你想要运行的module；</li>
<li>第三个灰色的选项框我也没弄懂她是干嘛的，我至今都没能选择过，一直都是灰的；</li>
<li>绿色的三角形，大家熟知，运行键；</li>
<li>红色的瓢虫，大家熟知，debug键；</li>
<li>不知道干嘛的；</li>
<li>FlutterAPP的性能监视器；</li>
<li>闪电，这个是重点，也是Flutter的一大特性，热重载键，他能做到不需要重新编译代码就能将你修改的代码的效果在你的APP上显示出来；</li>
<li>不知道干嘛的；</li>
<li>红色的正方形，停止运行按钮。</li>
</ol>
<h2 id="Run运行区"><a href="#Run运行区" class="headerlink" title="Run运行区"></a>Run运行区</h2><p><img src="https://cdn.littlecorgi.top/mweb/2019-10-09/Run%E8%BF%90%E8%A1%8C%E5%8C%BA.png" alt="Run运行区"><br>就是Flutter的信息显示区，类似于AndroidStudio的Logcat，能显示FlutterAPP运行中的一些信息。</p>
<h2 id="Flutter-Outline-Flutter-Inspector区"><a href="#Flutter-Outline-Flutter-Inspector区" class="headerlink" title="Flutter Outline/Flutter Inspector区"></a>Flutter Outline/Flutter Inspector区</h2><p><img src="https://cdn.littlecorgi.top/mweb/2019-10-09/Flutter%20Outline.png" alt="Flutter Outline"><br><img src="https://cdn.littlecorgi.top/mweb/2019-10-09/Flutter%20Inspector.png" alt="Flutter Inspecto"><br>用于显示当前界面的一些构建信息。</p>
<h1 id="Flutter项目结构"><a href="#Flutter项目结构" class="headerlink" title="Flutter项目结构"></a>Flutter项目结构</h1><p><img src="https://cdn.littlecorgi.top/mweb/2019-10-09/Flutter%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" alt="Flutter项目结构"></p>
<p>我们挑一些重要的说一下：</p>
<ol>
<li>.idea文件夹，AndroidStudio识别项目的必备文件夹，不用管；</li>
<li>Android文件夹，存放Flutter构建的Android项目的文件夹；</li>
<li>ios文件夹，存放Flutter构建的iOS项目的文件夹；</li>
<li>lib文件夹，存放Flutter项目和资源的文件夹；</li>
<li>pubspec.yaml文件，存放Flutter项目相关信息，如项目名称、版本、依赖等等，类似于Android项目的build.gradle文件。</li>
</ol>
<h1 id="main-dart文件"><a href="#main-dart文件" class="headerlink" title="main.dart文件"></a>main.dart文件</h1><p>我们通过讲这个文件来给大家大致介绍下Flutter项目代码结构。</p>
<p>全部源代码在此<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: MyHomePage(title: <span class="string">&#x27;Flutter Demo Home Page&#x27;</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  MyHomePage(&#123;Key key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _incrementCounter() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _counter++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(</span><br><span class="line">              <span class="string">&#x27;You have pushed the button this many times:&#x27;</span>,</span><br><span class="line">            ),</span><br><span class="line">            Text(</span><br><span class="line">              <span class="string">&#x27;<span class="subst">$_counter</span>&#x27;</span>,</span><br><span class="line">              style: Theme.of(context).textTheme.display1,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        tooltip: <span class="string">&#x27;Increment&#x27;</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>首先我们看最开始的<code>import</code>区。</p>
<p>这块相当于C/C++的<code>include</code>，反而不像java的<code>import</code>。我为什么这么说呢，你想一下，你写java程序的时候，你是需要哪个类就直接在代码中输入类名，然后IDE会自动给你显示有这个类的所有的包，然后让你选包去导入；而写dart是需要你先导入包，才能在代码中写这个包中的类，如果你没有先导入包而直接到下面写的话，IDE是不会提示你这个类可能会在哪个包中，而是直接报错，这点和C/C++比较类似。</p>
<p>那我们为什么导入的是<code>flutter/material.dart</code>这个包呢？我在第一节里面说过，Flutter他内置了Android的Material Design风格和iOS的Cupertino风格的UI；所以这块就是导入Material Design风格UI文件，而如果你要使用Cupertino风格UI文件的话，把它改成Cupertino就行了。</p>
<h2 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ), </span><br><span class="line">      home: MyHomePage(title: <span class="string">&#x27;Flutter Demo Home Page&#x27;</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>第一行，指明项目的入口就是<code>MyApp()</code>。固定格式，可以不用管。</p>
</li>
<li><p>第二行就定义了一个类<code>MyApp</code>继承自<code>StatelessWidget</code>，并重写了父类的<code>build()</code>方法。<code>Widget</code>可以看成Flutter中的页面，只要是Flutter中的页面，都必须继承自<code>Widget</code>。他有点类似于Android中的<code>View</code>，但是不同于<code>View</code>的是，Flutter中的<code>padding</code>、<code>align</code>、<code>layout</code>等居然也是<code>Widget</code>。</p>
</li>
<li><p>如果是<code>StatelessWidget</code>，则代表她是一个“状态少”的<code>Widget</code>，我的理解就是状态相当于<code>Widget</code>的一些数值，比方说页面要显示计数器的计数<code>count</code>，那么这个<code>count</code>就是一个状态，只要有状态就使用<code>StatefulWidget</code>。像<code>MyApp</code>它没有状态，于是就用<code>StatelessWidget</code>。</p>
</li>
<li><p>继承自<code>StatelessWidget</code>的类必须实现<code>build()</code>方法，相当于这个类是一个死页面，只需要展示固定的内容，也就是不需要状态，所以直接通过<code>build()</code>直接写入界面就行。</p>
</li>
<li><p><code>build()</code>方法必须同样返回一个<code>Widget</code>，所以我们就使用<code>MaterialApp</code>，其中我们给他的<code>title</code>、<code>theme</code>、<code>home</code>进行了赋值，同学们应该都能大致读懂啥意思，首页<code>home</code>则给了<code>MyHomePage</code>.</p>
</li>
</ul>
<h2 id="MyHomePage"><a href="#MyHomePage" class="headerlink" title="MyHomePage"></a>MyHomePage</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  MyHomePage(&#123;Key key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _incrementCounter() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _counter++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(</span><br><span class="line">              <span class="string">&#x27;You have pushed the button this many times:&#x27;</span>,</span><br><span class="line">            ),</span><br><span class="line">            Text(</span><br><span class="line">              <span class="string">&#x27;<span class="subst">$_counter</span>&#x27;</span>,</span><br><span class="line">              style: Theme.of(context).textTheme.display1,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        tooltip: <span class="string">&#x27;Increment&#x27;</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MyHomePage-1"><a href="#MyHomePage-1" class="headerlink" title="MyHomePage"></a>MyHomePage</h3><p>我们在前面说过，如果一个页面有数据也就是“状态”的话，那么他就得继承自<code>StatefulWidget</code>。</p>
<p>如果一个类继承自<code>StatefulWidget</code>，那这个类会很简单，只需要创建一个构造方法，构造方法中写入<code>key</code>以及该<code>Widget</code>需要的数据。然后重写<code>createState()</code>方法。</p>
<h3 id="MyHomePageState"><a href="#MyHomePageState" class="headerlink" title="MyHomePageState"></a>MyHomePageState</h3><p>如果一个类继承自<code>StatefulWIdget</code>，那么一定会有一个他的<code>State</code>类并继承自<code>State&lt;该类&gt;</code>，就像<code>class _MyHomePageState extends State&lt;MyHomePage&gt;</code>一样。</p>
<p>那我们来看看State类里面有些啥东西:</p>
<p>首先先定义“状态”：由于我们这个APP主要的功能是用来计数，所以必须定义一个int型变量来计数：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><br>接着如果我们这个_counter变量变了，那就得通知flutter说状态变了，需要更新UI：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _incrementCounter() &#123;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">     _counter++;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中，<code>setState()</code>方法就是用来通知<code>Flutter</code>这个状态改变了，要去更新UI的。</p>
<p>最后重写<code>build()</code>方法来写入界面：</p>
<ul>
<li><code>Scaffold</code>是一个组件，它提供了默认的导航栏、标题和包含主屏幕<code>widget</code>树（后同“组件树”或“部件树”）的<code>body</code>属性。</li>
<li><code>body</code>后面是一个<code>Center</code>组件，它的作用是将它的子<code>Widget</code>定位到父<code>Widget</code>的中间。</li>
<li><code>Center</code>后面是一个<code>Column</code>组件，这个组件类似于Android中的<code>LinearLayout</code>的<code>orientation: Vertical</code>，也就是垂直向的线性布局。同时Flutter也提供了<code>Row</code>这个水平向的线性布局。他们的子<code>Widget</code>是<code>children</code>属性，也就是可以写多个<code>Widget</code>。</li>
<li><code>Column</code>里面是两个<code>Text</code>，这个没啥讲的</li>
<li>接下来是一个<code>FloatingActionButton</code>，这就是一个浮动按钮，Android里面有这个控件，核心是他的<code>onPressed</code>属性，这个就相当于<code>onClick()</code>，用于处理点击事件。</li>
</ul>
<h1 id="体验热重启"><a href="#体验热重启" class="headerlink" title="体验热重启"></a>体验热重启</h1><p>首先先让项目在虚拟机或者手机上运行着，然后我们把页面Text中的”You have pushed the button this many times:”改为”You have clicked the button this many times:”，然后按热重启键（macOS版AndroidStudio默认是commond+s键），接着你就能里面在虚拟机或者手机上看到修改之后的结果。<br><img src="https://cdn.littlecorgi.top/mweb/2019-10-09/%E6%9C%AA%E5%91%BD%E5%90%8D%20-2-.gif" alt="flutter热重启"></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter入门并开发天气预报APP(3)——Widget</title>
    <url>/posts/fc77cdce.html</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在Flutter中，Widget是个非常基本的东西，我在上一章就说过，Flutter中只要是界面都是Widget，你可以把它就理解成是控件，但是又和Android的View控件不同的是，在Flutter中，包括<code>Padding</code>、<code>Align</code>、手势检测的<code>GestureDetector</code>等等，都算是<code>Widget</code>。</p>
<p>其实大多数时候，你就可以把Widget直接理解成UI控件就行了，因为<code>Padding</code>、<code>Align</code>、<code>GestureDetector</code>等等也都是为UI服务的，你就可以理解成Flutter中只要与UI有关的属性都可以算是控件。</p>
<span id="more"></span>
<h1 id="Widget的状态"><a href="#Widget的状态" class="headerlink" title="Widget的状态"></a>Widget的状态</h1><p>在Android中，我们可以直接通过更新数据来达到刷新UI的目的。但是如果使用Flutter，就像我们前面说的计数器的Demo，如果直接通过<code>StatelessWidget</code>也就是无状态Widget的话，是没法进行刷新UI的，只能写一个死界面，也就是说如果在Flutter中界面写出来的就是一个死界面，只有通过刷新状态才能更新UI。</p>
<p>Widget有两个直接子类：<code>StatelessWidget</code>和<code>StatefulWidget</code>：</p>
<ul>
<li><code>StatelessWidget</code>：这个是无状态Widget，实现<code>build()</code>方法后，就不可再变化，哪怕他的状态改变了。这句话可能有点矛盾，但是我来举个例子，比方说现在有一个<code>StatelessWidget</code>，他的内容就是一个<code>Text</code>，而这个<code>Text</code>的内容则显示了<code>counter</code>这个变量。当这个页面出现的时候，取了当时<code>counter</code>的值并显示了出来，但是我们后续不管<code>counter</code>这个值怎么改变，界面都是不会显示出来的。</li>
<li><code>StatefulWidget</code>：这个是有状态Widget，当你有状态需要改变的时候就可以通过他来改变状态。</li>
</ul>
<p>State的几种状态：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">状态</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">initState</td>
<td style="text-align:center">create之后被insert到渲染树时调用的，只会调用一次</td>
</tr>
<tr>
<td style="text-align:center">didChangeDependencies</td>
<td style="text-align:center">state依赖的对象发生变化时调用</td>
</tr>
<tr>
<td style="text-align:center">didUpdateWidget</td>
<td style="text-align:center">Widget状态改变时候调用，可能会调用多次</td>
</tr>
<tr>
<td style="text-align:center">build</td>
<td style="text-align:center">构建Widget时调用</td>
</tr>
<tr>
<td style="text-align:center">deactivate</td>
<td style="text-align:center">当移除渲染树的时调用</td>
</tr>
<tr>
<td style="text-align:center">dispose</td>
<td style="text-align:center">Widget即将销毁时调用</td>
</tr>
</tbody>
</table>
</div>
<h1 id="StatelessWidget"><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h1><p>这个类相对简单，只需要实现<code>build()</code>方法就可以了。</p>
<p><code>StatelessWidget</code>用于不需要维护状态的场景，也就是说如果他需要显示的某一个参数的值发生变化了他也不变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">StatelessWidget</span> &#123;</span><br><span class="line">  Test(&#123;Key key, <span class="built_in">this</span>.title&#125;) : <span class="built_in">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> String title;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget <span class="title function_">build</span><span class="params">(BuildContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: <span class="keyword">new</span> <span class="title class_">AppBar</span>(</span><br><span class="line">        title: Text(<span class="string">&quot;$title&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Text(<span class="string">&quot;1234&quot;</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码就演示了一个<code>StatelessWidget</code>的例子，功能是根据传入的<code>title</code>在界面的<code>title</code>了上显示出来。只实现了<code>build()</code>方法和构造方法。其中构造方法参数<code>Key</code>是必须得有的，而且如果该Widget还有其他状态的话，也需要写入构造方法。接着调用<code>build()</code>方法，将传入的<code>title</code>在界面的<code>title</code>上显示出来。</p>
<p>例如，如果我们调用它：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">  Widget <span class="title function_">build</span><span class="params">(BuildContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: Test(title: <span class="string">&#x27;Flutter Demo Home Page&#x27;</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>结果是：<br><img src="https://cdn.littlecorgi.top/mweb/2019-10-09/Screenshot_20191009-112644.jpg" alt="Screenshot_20191009-112644"></p>
<h1 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h1><p>与<code>StatelessWidget</code>相对的就是<code>StatefulWidget</code>。它的重点在于可以根据状态来更新。</p>
<p>他较于<code>StatelessWidget</code>，少了我们常用的<code>build()</code>方法，多了<code>createState()</code>方法。下面我就来讲一下他的用法，我还是拿上面的<code>Test</code>做例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">StatefulWidget</span> &#123;</span><br><span class="line">  Test(&#123;Key key, <span class="built_in">this</span>.title&#125;) : <span class="built_in">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> String title;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _TestState <span class="title function_">createState</span><span class="params">()</span> =&gt; _TestState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_TestState</span> <span class="keyword">extends</span> <span class="title class_">State</span>&lt;Test&gt; &#123;</span><br><span class="line">  String _title;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">initState</span><span class="params">()</span> &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _title = widget.title;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget <span class="title function_">build</span><span class="params">(BuildContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: <span class="keyword">new</span> <span class="title class_">AppBar</span>(</span><br><span class="line">        title: Text(<span class="string">&quot;$_title&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Text(<span class="string">&quot;1234&quot;</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看<code>Test</code>类，他继承自<code>StatefulWidget</code>，由于这个页面需要根据传入的参数来显示<code>title</code>，所以有一个状态<code>title</code>，并在构造方法中写入了他。接着调用了<code>createState()</code>方法。这个方法是所有<code>StatefulWidget</code>必须的，主要是为这个Widget创建他对应的State。</p>
<p>于是我们就在下面创建一个新的类，类名叫<code>_TestState</code>，继承自<code>State&lt;Test&gt;</code>。由于Widget有<code>title</code>这个状态，并且需要在界面中显示出来，所以为了降低他们的耦合度，我们在State类中也创建一个叫<code>_title</code>的状态，并<code>_title = widget.title;</code>。<br>接下来是一个<code>initState()</code>方法，这个方法也是State必须的，在上面Widget的状态中我们讲到过，这个是初始化State的，同时在<code>initSate()</code>里面，我们写了一个<code>setState()</code>，也就是说我们告诉Flutter说这个方法里面的参数改变了接着Widget的状态也得改变。最后就是<code>build()</code>方法。</p>
<p>接下来我们调用它：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">  Widget <span class="title function_">build</span><span class="params">(BuildContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: Test(title: <span class="string">&#x27;1234&#x27;</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>结果是：<br><img src="https://cdn.littlecorgi.top/mweb/2019-10-09/Screenshot_20191009-114316.jpg" alt="Screenshot_20191009-114316"></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter入门并开发天气预报APP(4)——基础Widget</title>
    <url>/posts/a3b37eac.html</url>
    <content><![CDATA[<p>到这章我们就差不多可以开始写天气预报了。首先我们来看一下一些基础简单的Widget。</p>
<span id="more"></span>
<h1 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h1><h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><p><code>Text</code>用于显示简单的文本，包含一些控制文本显示的属性。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Text(</span><br><span class="line">    <span class="string">&quot;1234&quot;</span>,</span><br><span class="line">),</span><br><span class="line">Text(</span><br><span class="line">    <span class="string">&quot;1234&quot;</span>,</span><br><span class="line">    style: TextStyle(</span><br><span class="line">        color: Colors.purple,</span><br><span class="line">        fontSize: <span class="number">32.0</span>,</span><br><span class="line">        fontWeight: FontWeight.bold,</span><br><span class="line">    ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><br><img src="https://cdn.littlecorgi.top/mweb/2019-10-10/Text%E7%A4%BA%E4%BE%8B.png" alt="Text示例"></p>
<ul>
<li>需要显示的文本信息直接放到一个双引号里面就可以了；</li>
<li><code>textAlign</code>：文本对齐方式；</li>
<li><code>maxLines</code>：文本显示的最大行数；</li>
<li><code>overflow</code>：指定多余文本的截断方式；</li>
<li><code>textScaleFactor</code>：指定文本相对于当前字体大小的缩放因子；</li>
<li><code>TextStyle</code>：设置显示文本的字体、颜色、粗细等样式：<ul>
<li><code>height</code>：指定行高，但是不是绝对值，而是一个因子，相当于<code>fontsize * height</code>；</li>
<li><code>fontFamily</code>：设置字体；</li>
<li><code>fontSize</code>：设置字体大小</li>
</ul>
</li>
</ul>
<h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><p>不同的组件库有不同的按钮，我们现在只拿Material组件库中的按钮举例。</p>
<h3 id="RaisedButton"><a href="#RaisedButton" class="headerlink" title="RaisedButton"></a>RaisedButton</h3><p>漂浮按钮，带有阴影和灰色背景。按下后阴影会变大。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">  child: Text(<span class="string">&quot;1234&quot;</span>),</span><br><span class="line">  onPressed: () &#123;&#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<figure class="half">
    <img src="https://cdn.littlecorgi.top/mweb/2019-10-10/RaisedButton%E6%9C%AA%E6%8C%89%E4%B8%8B.png">
    <img src="https://cdn.littlecorgi.top/mweb/2019-10-10/RaisedButton%E6%8C%89%E4%B8%8B.png">
</figure>

<h3 id="FlatButton"><a href="#FlatButton" class="headerlink" title="FlatButton"></a>FlatButton</h3><p>扁平化按钮，背景透明且不带阴影，按下后会有背景色。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FlatButton(</span><br><span class="line">  child: Text(<span class="string">&quot;1234&quot;</span>),</span><br><span class="line">  onPressed: () &#123;&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<figure class="half">
    <img src="https://cdn.littlecorgi.top/mweb/2019-10-10/FlatButton%E6%9C%AA%E6%8C%89%E4%B8%8B.png">
    <img src="https://cdn.littlecorgi.top/mweb/2019-10-10/FlatButton%E6%8C%89%E4%B8%8B.png">
</figure>

<h3 id="IconButton"><a href="#IconButton" class="headerlink" title="IconButton"></a>IconButton</h3><p>可点击的Icon，默认没有背景，按下后出现阴影<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IconButton(</span><br><span class="line">  icon: Icon(Icons.thumb_up),</span><br><span class="line">  onPressed: () &#123;&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><img src="https://cdn.littlecorgi.top/mweb/2019-10-10/15706115387455.png" alt="-w88"></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>我们通过<code>Image</code>来显示图片，来源可以是<code>asset</code>、网络等位置。</p>
<h3 id="从asset加载图片"><a href="#从asset加载图片" class="headerlink" title="从asset加载图片"></a>从asset加载图片</h3><ol>
<li>现在项目根目录(也就是和android、ios、lib等目录同级)新建一个<code>images</code>目录，并把图片<code>main.png</code>拷进去；</li>
<li>在<code>pubspec.yaml</code>中的flutter部分添加一下内容：<br> <img src="https://cdn.littlecorgi.top/mweb/2019-10-10/assets.png" alt="assets"></li>
<li>加载该图片</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Image(</span><br><span class="line">  image: AssetImage(<span class="string">&quot;images/amoled.png&quot;</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><code>Image</code>也提供了一个快速构造函数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Image.asset(</span><br><span class="line">  <span class="string">&quot;images/amoled.png&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h3 id="从网络加载图片"><a href="#从网络加载图片" class="headerlink" title="从网络加载图片"></a>从网络加载图片</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Image(</span><br><span class="line">  image: NetworkImage(</span><br><span class="line">      <span class="string">&quot;https://s2.ax1x.com/2019/05/27/VZrQ3V.png&quot;</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Image.network(</span><br><span class="line">  <span class="string">&quot;https://s2.ax1x.com/2019/05/27/VZrQ3V.png&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>Image</code>有一些基本参数<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">const <span class="title function_">Image</span><span class="params">(&#123;</span></span><br><span class="line"><span class="params">  ...</span></span><br><span class="line"><span class="params">  <span class="built_in">this</span>.width, //图片的宽</span></span><br><span class="line"><span class="params">  <span class="built_in">this</span>.height, //图片高度</span></span><br><span class="line"><span class="params">  <span class="built_in">this</span>.fit,//缩放模式</span></span><br><span class="line"><span class="params">  <span class="built_in">this</span>.alignment = Alignment.center, //对齐方式</span></span><br><span class="line"><span class="params">  <span class="built_in">this</span>.repeat = ImageRepeat.noRepeat, //重复方式</span></span><br><span class="line"><span class="params">  ...</span></span><br><span class="line"><span class="params">&#125;)</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>width</code>和<code>height</code>：宽和高；</li>
<li><code>fit</code>：缩放模式：<ul>
<li><code>fill</code>：拉伸图片知道填满；</li>
<li><code>cover</code>：按原图长宽比放大图片来填满，多余的部分舍去；</li>
<li><code>contain</code>：在保证图片长宽比不变的情况下尽可能去填满；</li>
<li><code>fitWidth</code>：宽度会缩放到显示空间的宽度，高度会按比例缩放，如果有多余的部分会被舍去；</li>
<li><code>fitHeight</code>：与<code>fitWidth</code>同理；</li>
<li><code>none</code>：没有适应策略，图片多大就显示多大，如果图片原尺寸小于显示空间就只显示原尺寸；如果大于则舍弃多余部分只显示中间部分；</li>
</ul>
</li>
<li><code>repeat</code>：当图片小于显示空间时，会将图片重复显示。</li>
</ul>
<h1 id="布局组件"><a href="#布局组件" class="headerlink" title="布局组件"></a>布局组件</h1><h2 id="线性布局-Row、Column"><a href="#线性布局-Row、Column" class="headerlink" title="线性布局(Row、Column)"></a>线性布局(Row、Column)</h2><p>线性布局就相当于Android里面的<code>LinearLayout</code>，但是不同的是Flutter将竖直和水平布局单独拿了出来。</p>
<p>线性布局分为竖直布局<code>Column</code>和水平布局<code>Row</code>。他两属性都是一样的。<br>再说属性之前我们先熟悉两个概念：主轴和交叉轴。如果是<code>Column</code>，主轴是竖直轴，交叉轴是水平轴；如果是<code>Row</code>，主轴是水平轴，交叉轴是竖直轴。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Row(&#123;</span><br><span class="line">  ...  </span><br><span class="line">  <span class="type">MainAxisSize</span> <span class="variable">mainAxisSize</span> <span class="operator">=</span> MainAxisSize.max,    </span><br><span class="line">  <span class="type">MainAxisAlignment</span> <span class="variable">mainAxisAlignment</span> <span class="operator">=</span> MainAxisAlignment.start,</span><br><span class="line">  <span class="type">CrossAxisAlignment</span> <span class="variable">crossAxisAlignment</span> <span class="operator">=</span> CrossAxisAlignment.center,</span><br><span class="line">  List&lt;Widget&gt; children = const &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>mainAxisSize</code>：主轴占用空间。默认是<code>MainAxisSize.max</code>，是指占用全部主轴空间。如果设置为<code>MainAxisSize.min</code>，那就只占用所有子组件所需要的空间；</li>
<li><code>mainAxisAlignment</code>：子Widget在主轴的对其方向；</li>
<li><code>crossAxisAlignment</code>：子Widget在交叉轴的对其方向；</li>
<li><code>children</code>：所有的子Widget。</li>
</ul>
<h2 id="弹性布局-Flex"><a href="#弹性布局-Flex" class="headerlink" title="弹性布局(Flex)"></a>弹性布局(Flex)</h2><p>其实这个布局和线性布局很有渊源，为什么这么说呢，因为<code>Row</code>和<code>Column</code>都继承自它。<br>因此关于他和线性布局重复的地方我们现在就不再讲了，我们直说他“弹性”的部分。</p>
<h3 id="Expanded"><a href="#Expanded" class="headerlink" title="Expanded"></a>Expanded</h3><p>可以按比例“拉伸”<code>Row</code>、<code>Column</code>和<code>Flex</code>子组件所占的空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">const <span class="title function_">Expanded</span><span class="params">(&#123;</span></span><br><span class="line"><span class="params">  <span class="type">int</span> flex = <span class="number">1</span>, </span></span><br><span class="line"><span class="params">  <span class="meta">@required</span> Widget child,</span></span><br><span class="line"><span class="params">&#125;)</span></span><br></pre></td></tr></table></figure>
<p><code>flex</code>为弹性系数，如果为<code>0</code>或者<code>null</code>，则<code>child</code>不会阔伸占用的控件。如果大于<code>0</code>，则会按照<code>flex</code>的比例来分隔主轴全部空闲空间。其实说白了，就和Android里面<code>LinearLayout</code>的<code>weight</code>一样的。但是我们还是来举个例子吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: <span class="keyword">new</span> <span class="title class_">AppBar</span>(</span><br><span class="line">        title: Text(<span class="string">&quot;$_title&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Flex(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Flex(</span><br><span class="line">              direction: Axis.horizontal,</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                Expanded(</span><br><span class="line">                  flex: <span class="number">1</span>,</span><br><span class="line">                  child: Container(</span><br><span class="line">                    color: Colors.blue,</span><br><span class="line">                    child: Text(<span class="string">&quot;1234&quot;</span>),</span><br><span class="line">                  ),</span><br><span class="line">                ),</span><br><span class="line">                Expanded(</span><br><span class="line">                  flex: <span class="number">2</span>,</span><br><span class="line">                  child: Container(</span><br><span class="line">                    color: Colors.red,</span><br><span class="line">                    child: Text(<span class="string">&quot;1234&quot;</span>),</span><br><span class="line">                  ),</span><br><span class="line">                ),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">            Flex(</span><br><span class="line">              direction: Axis.horizontal,</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                Expanded(</span><br><span class="line">                  flex: <span class="number">3</span>,</span><br><span class="line">                  child: Container(</span><br><span class="line">                    color: Colors.blue,</span><br><span class="line">                    child: Text(<span class="string">&quot;1234&quot;</span>),</span><br><span class="line">                  ),</span><br><span class="line">                ),</span><br><span class="line">                Expanded(</span><br><span class="line">                  flex: <span class="number">1</span>,</span><br><span class="line">                  child: Container(</span><br><span class="line">                    color: Colors.red,</span><br><span class="line">                    child: Text(<span class="string">&quot;1234&quot;</span>),</span><br><span class="line">                  ),</span><br><span class="line">                ),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">            Flex(</span><br><span class="line">              direction: Axis.horizontal,</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                Expanded(</span><br><span class="line">                  flex: <span class="number">1</span>,</span><br><span class="line">                  child: Container(</span><br><span class="line">                    color: Colors.blue,</span><br><span class="line">                    child: Text(<span class="string">&quot;1234&quot;</span>),</span><br><span class="line">                  ),</span><br><span class="line">                ),</span><br><span class="line">                Expanded(</span><br><span class="line">                  flex: <span class="number">1</span>,</span><br><span class="line">                  child: Container(</span><br><span class="line">                    color: Colors.red,</span><br><span class="line">                    child: Text(<span class="string">&quot;1234&quot;</span>),</span><br><span class="line">                  ),</span><br><span class="line">                ),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">          direction: Axis.vertical,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.littlecorgi.top/mweb/2019-10-10/Flex%E7%A4%BA%E4%BE%8B.png" alt="Flex示例"></p>
<h2 id="流式布局-Wrap、Flow"><a href="#流式布局-Wrap、Flow" class="headerlink" title="流式布局(Wrap、Flow)"></a>流式布局(Wrap、Flow)</h2><p>如果使用线性布局的话，当需要显示的内容超出屏幕边界的时候就会报错。<br><img src="https://cdn.littlecorgi.top/mweb/2019-10-10/%E8%B6%85%E5%87%BA%E5%B1%8F%E5%B9%95%E8%BE%B9%E7%95%8C.png" alt="超出屏幕边界"></p>
<p>为了避免这种情况，我们就可以使用流式布局。当需要显示的内容超出屏幕边界的时候，就自动折行来继续显示。</p>
<p>Flutter中通过<code>Wrap</code>和<code>Flow</code>来实现流式布局。</p>
<h3 id="Wrap"><a href="#Wrap" class="headerlink" title="Wrap"></a>Wrap</h3><p>我们来看下<code>Wrap</code>主要的一些参数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Wrap(&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">this</span>.direction = Axis.horizontal,</span><br><span class="line">  <span class="built_in">this</span>.alignment = WrapAlignment.start,</span><br><span class="line">  <span class="built_in">this</span>.spacing = <span class="number">0.0</span>,</span><br><span class="line">  <span class="built_in">this</span>.runAlignment = WrapAlignment.start,</span><br><span class="line">  <span class="built_in">this</span>.runSpacing = <span class="number">0.0</span>,</span><br><span class="line">  <span class="built_in">this</span>.crossAxisAlignment = WrapCrossAlignment.start,</span><br><span class="line">  <span class="built_in">this</span>.textDirection,</span><br><span class="line">  <span class="built_in">this</span>.verticalDirection = VerticalDirection.down,</span><br><span class="line">  List&lt;Widget&gt; children = const &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>其中很多参数<code>Row</code>和<code>Column</code>中都有，就不再介绍了，主要介绍点不同的：</p>
<ul>
<li><code>spacing</code>：主轴方向子widget的间距</li>
<li><code>runSpacing</code>：纵轴方向的间距</li>
<li><code>runAlignment</code>：纵轴方向的对齐方式</li>
</ul>
<p>下面有一个示例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Wrap(</span><br><span class="line">  spacing: <span class="number">8.0</span>, <span class="comment">// 主轴(水平)方向间距</span></span><br><span class="line">  runSpacing: <span class="number">4.0</span>, <span class="comment">// 纵轴（垂直）方向间距</span></span><br><span class="line">  alignment: WrapAlignment.center, <span class="comment">//沿主轴方向居中</span></span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Chip</span>(</span><br><span class="line">      avatar: <span class="keyword">new</span> <span class="title class_">CircleAvatar</span>(backgroundColor: Colors.blue, child: Text(<span class="string">&#x27;A&#x27;</span>)),</span><br><span class="line">      label: <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&#x27;Hamilton&#x27;</span>),</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Chip</span>(</span><br><span class="line">      avatar: <span class="keyword">new</span> <span class="title class_">CircleAvatar</span>(backgroundColor: Colors.blue, child: Text(<span class="string">&#x27;M&#x27;</span>)),</span><br><span class="line">      label: <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&#x27;Lafayette&#x27;</span>),</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Chip</span>(</span><br><span class="line">      avatar: <span class="keyword">new</span> <span class="title class_">CircleAvatar</span>(backgroundColor: Colors.blue, child: Text(<span class="string">&#x27;H&#x27;</span>)),</span><br><span class="line">      label: <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&#x27;Mulligan&#x27;</span>),</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Chip</span>(</span><br><span class="line">      avatar: <span class="keyword">new</span> <span class="title class_">CircleAvatar</span>(backgroundColor: Colors.blue, child: Text(<span class="string">&#x27;J&#x27;</span>)),</span><br><span class="line">      label: <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&#x27;Laurens&#x27;</span>),</span><br><span class="line">    ),</span><br><span class="line">  ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><img src="https://cdn.littlecorgi.top/mweb/2019-10-10/Wrap%E7%A4%BA%E4%BE%8B.png" alt="Wrap示例"></p>
<h3 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h3><p><code>Flow</code>较复杂，需要自己实现子Widget的位置转换，一般不推荐使用<code>Flow</code>。但是如果需要自定义布局策略，或者对性能要求较高，这个时候就得用<code>Flow</code>了。</p>
<p>但是由于太过于复杂，我也没咋用过，我就不在这讲了😝，大家有需要的可以百度，或者看我推荐的这篇：<a href="https://book.flutterchina.club/chapter4/wrap_and_flow.html">4.4 流式布局-《Flutter实战》</a></p>
<h2 id="层叠布局-Stack"><a href="#层叠布局-Stack" class="headerlink" title="层叠布局(Stack)"></a>层叠布局(Stack)</h2><p>这个布局类似于Android中的<code>Frame</code>，允许在父布局的任意地方放置布局。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack(&#123;</span><br><span class="line">  <span class="built_in">this</span>.alignment = AlignmentDirectional.topStart,</span><br><span class="line">  <span class="built_in">this</span>.textDirection,</span><br><span class="line">  <span class="built_in">this</span>.fit = StackFit.loose,</span><br><span class="line">  <span class="built_in">this</span>.overflow = Overflow.clip,</span><br><span class="line">  List&lt;Widget&gt; children = const &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>alignment</code>：决定如何去对齐；</li>
<li><code>textDirection</code>：确定<code>alignment</code>的参考系；</li>
<li><code>fit</code>：没有定位的子Widget如何去适应<code>Stack</code>的大小；</li>
<li><code>overflow</code>：决定超出<code>Stack</code>显示空间的子Widget如何去显示，如果<code>Overflow.clip</code>，则超出部分会隐藏，<code>Overflow.visible</code>则不会。</li>
</ul>
<h2 id="对齐与相对定位-Align"><a href="#对齐与相对定位-Align" class="headerlink" title="对齐与相对定位(Align)"></a>对齐与相对定位(Align)</h2><p>Align可以调整子Widget的位置，并且可以根据子Widget的宽高来确定自身的宽高。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Align(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="built_in">this</span>.alignment = Alignment.center,</span><br><span class="line">  <span class="built_in">this</span>.widthFactor,</span><br><span class="line">  <span class="built_in">this</span>.heightFactor,</span><br><span class="line">  Widget child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>alignment：代表子Widget在父Widget的起始位置；</li>
<li>widthFactor和heightFactor确定Align本身的宽高。</li>
</ul>
<p>来看一个简单的例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Container(</span><br><span class="line">  height: <span class="number">120.0</span>,</span><br><span class="line">  width: <span class="number">120.0</span>,</span><br><span class="line">  color: Colors.blue[<span class="number">50</span>],</span><br><span class="line">  child: Align(</span><br><span class="line">    alignment: Alignment.topRight,</span><br><span class="line">    child: FlutterLogo(</span><br><span class="line">      size: <span class="number">60</span>,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>运行结果：<br><img src="https://cdn.littlecorgi.top/mweb/2019-10-10/15706312811307.png" alt="-w100"></p>
<h1 id="3-容器类组件"><a href="#3-容器类组件" class="headerlink" title="3. 容器类组件"></a>3. 容器类组件</h1><h2 id="填充-Padding"><a href="#填充-Padding" class="headerlink" title="填充(Padding)"></a>填充(Padding)</h2><p>用过Android的同学一定熟悉，Padding就是负责留白的嘛。<br>但是跟Android里面不同的是，在Android里面我们一般是在一个View里面添加Padding，但是在Flutter里面，Padding直接变成了一个Widget、一个布局。</p>
<p>使用方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Padding (&#123;</span><br><span class="line">  EdgeInsetsGeometry padding,</span><br><span class="line">  Widget child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>对于EdgeInsetsGeometry我们一般使用EdgeInsets类。</p>
<h3 id="EdgeInsets"><a href="#EdgeInsets" class="headerlink" title="EdgeInsets"></a>EdgeInsets</h3><p>EdgeInsets类提供了几个便捷的方法：</p>
<ul>
<li>fromLTRB(double left, double top, double right, double bottom)：分别指定四个方向的填充；</li>
<li>all(double value) : 所有方向均使用相同数值的填充；</li>
<li>only({left, top, right ,bottom })：可以设置具体某个方向的填充(可以同时指定多个方向)；</li>
<li>symmetric({ vertical, horizontal })：用于设置对称方向的填充，vertical指top和bottom，horizontal指left和right；</li>
</ul>
<p>示例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">body: Column(</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    Padding(</span><br><span class="line">      padding: EdgeInsets.only(left: <span class="number">12.0</span>, bottom: <span class="number">10.0</span>),</span><br><span class="line">      child: Text(<span class="string">&quot;1234&quot;</span>),</span><br><span class="line">    ),</span><br><span class="line">    Padding(</span><br><span class="line">      padding: EdgeInsets.fromLTRB(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">10.0</span>, <span class="number">10.0</span>),</span><br><span class="line">      child: Text(<span class="string">&quot;1234&quot;</span>),</span><br><span class="line">    ),</span><br><span class="line">    Padding(</span><br><span class="line">      padding: EdgeInsets.symmetric(vertical: <span class="number">10.0</span>),</span><br><span class="line">      child: Text(<span class="string">&quot;1234&quot;</span>),</span><br><span class="line">    ),</span><br><span class="line">  ],</span><br><span class="line">),</span><br></pre></td></tr></table></figure><br>运行结果：<br><img src="https://cdn.littlecorgi.top/mweb/2019-10-10/Padding%E7%A4%BA%E4%BE%8B.png" alt="Padding示例"></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter入门并开发天气预报APP(5)——SingleChildScrollView、ListView和GridView</title>
    <url>/posts/30ff421d.html</url>
    <content><![CDATA[<p>下面我们来介绍下Flutter中的滑动控件<code>SingleChildScrollView</code>、列表<code>ListView</code>和表格<code>GridView</code>。<br><span id="more"></span></p>
<h1 id="SingleChildScrollView"><a href="#SingleChildScrollView" class="headerlink" title="SingleChildScrollView"></a>SingleChildScrollView</h1><p><code>SingleChildScrollView</code>类似于Android中的<code>ScrollView</code>，我使用的较浅，在我目前看来，他和<code>ScrollView</code>的唯一区别就是它还可以横向滚动。</p>
<p>我们先来看下他的定义：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SingleChildScrollView(&#123;</span><br><span class="line">  <span class="built_in">this</span>.scrollDirection = Axis.vertical, <span class="comment">//滚动方向，默认是垂直方向</span></span><br><span class="line">  <span class="built_in">this</span>.reverse = <span class="literal">false</span>, </span><br><span class="line">  <span class="built_in">this</span>.padding, </span><br><span class="line">  bool primary, </span><br><span class="line">  <span class="built_in">this</span>.physics, </span><br><span class="line">  <span class="built_in">this</span>.controller,</span><br><span class="line">  <span class="built_in">this</span>.child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>scrollDirection</code>：设定滚动的方向，可以设定<code>Axis.vertical</code>或者<code>Axis.horizon</code>；</li>
<li><code>reverse</code>：是否按照阅读方向的反方向滑动，emmm这个可能有点觉得莫名其妙，但是如阿拉伯语言地区，他们阅读和我国古时候一样是从右向左的，所以如果<code>reverse</code>为<code>true</code>，且滚动方向是水平滚动的话，如果系统时阿拉伯语等从右向左阅读的语言时，方向是从右向左的；</li>
<li><code>padding</code>：留白的大小，和<code>Padding</code>的用法一样，通过<code>EdgeInsets</code>来设定，具体可以看前几章将Flutter基础Widget；</li>
<li><code>primary</code>：指是否使用widget树中默认的<code>PrimaryScrollController</code>；当滑动方向为垂直方向（<code>scrollDirection</code>值为<code>Axis.vertical</code>）并且没有指定<code>controller</code>时，<code>primary</code>默认为<code>true</code>；</li>
<li><code>physics</code>：用于控制滚动方式，这个等会重点讲解；</li>
<li><code>controller</code>：用于滚动监听及控制；</li>
<li><code>child</code>：子Widget。</li>
</ul>
<h2 id="physics"><a href="#physics" class="headerlink" title="physics"></a>physics</h2><p>这个参数是用于控制滚动方式，有几种参数：</p>
<ul>
<li><code>NeverScrollablePhysics</code>：呈现不可滚动状态；</li>
<li><p><code>BouncingScrollPhysics</code>：当列表滑动结束时，会回弹列表，类似于iOS的列表滑动效果；<br><img src="https://cdn.littlecorgi.top/mweb/2019-10-10/BouncingScrollPhysics.gif" alt="BouncingScrollPhysics"></p>
</li>
<li><p><code>ClampingScrollPhysics</code>：滑动结束时会显示水波纹阴影，类似于Android的列表滑动效果；<br><img src="https://cdn.littlecorgi.top/mweb/2019-10-10/ClampingScrollPhysics.gif" alt="ClampingScrollPhysics"></p>
</li>
<li><p><code>FixedExtentScrollPhysics</code>：可以自己制作滑动效果，但是我也不会，所以在此不做解释😝。</p>
</li>
</ul>
<h1 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h1><p><code>ListView</code>可以沿一个方向上线性排布所有子组件（不仅局限于竖直方向）。</p>
<p>让我们来看下他的定义：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListView(&#123;</span><br><span class="line">  ...  </span><br><span class="line">  <span class="comment">//可滚动widget公共参数</span></span><br><span class="line">  <span class="type">Axis</span> <span class="variable">scrollDirection</span> <span class="operator">=</span> Axis.vertical,</span><br><span class="line">  <span class="type">bool</span> <span class="variable">reverse</span> <span class="operator">=</span> <span class="literal">false</span>,</span><br><span class="line">  ScrollController controller,</span><br><span class="line">  bool primary,</span><br><span class="line">  ScrollPhysics physics,</span><br><span class="line">  EdgeInsetsGeometry padding,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//ListView各个构造函数的共同参数  </span></span><br><span class="line">  <span class="type">double</span> itemExtent,</span><br><span class="line">  <span class="type">bool</span> <span class="variable">shrinkWrap</span> <span class="operator">=</span> <span class="literal">false</span>,</span><br><span class="line">  <span class="type">bool</span> <span class="variable">addAutomaticKeepAlives</span> <span class="operator">=</span> <span class="literal">true</span>,</span><br><span class="line">  <span class="type">bool</span> <span class="variable">addRepaintBoundaries</span> <span class="operator">=</span> <span class="literal">true</span>,</span><br><span class="line">  <span class="type">double</span> cacheExtent,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//子widget列表</span></span><br><span class="line">  List&lt;Widget&gt; children = const &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>公共属性我们就不讲了，上面<code>SingleChildScrollView</code>已经讲过了，我们现在只讲他特有的：</p>
<ul>
<li><code>itemExtent</code>：用于控制<code>ListView</code>的长度，如果不为<code>null</code>，则强制所有子Widget合起来的长度小于设定的值：如果<code>ListView</code>是横向的，则所有子Widget横向长度的和小于它；如果<code>ListView</code>是纵向的，则所有子Widget纵向长度的和小于它；</li>
<li><code>shrinkWrap</code>：该属性表示是否根据子组件的总长度来设置<code>ListView</code>的长度，默认值为<code>false</code> 。默认情况下，<code>ListView</code>的会在滚动方向尽可能多的占用空间。当<code>ListView</code>在一个无边界(滚动方向上)的容器中时，<code>shrinkWrap</code>必须为<code>true</code>；</li>
<li><code>addAutomaticKeepAlives</code>：该属性表示是否将列表项（子组件）包裹在<code>AutomaticKeepAlive</code>组件中；典型地，在一个懒加载列表中，如果将列表项包裹在<code>AutomaticKeepAlive</code>中，在该列表项滑出视口时它也不会被<code>GC（垃圾回收）</code>，它会使用<code>KeepAliveNotification</code>来保存其状态。如果列表项自己维护其<code>KeepAlive</code>状态，那么此参数必须置为<code>false</code>；</li>
<li><code>addRepaintBoundaries</code>：该属性表示是否将列表项（子组件）包裹在<code>RepaintBoundary</code>组件中。当可滚动组件滚动时，将列表项包裹在<code>RepaintBoundary</code>中可以避免列表项重绘，但是当列表项重绘的开销非常小（如一个颜色块，或者一个较短的文本）时，不添加<code>RepaintBoundary</code>反而会更高效。和<code>addAutomaticKeepAlive</code>一样，如果列表项自己维护其<code>KeepAlive</code>状态，那么此参数必须置为<code>false</code>；</li>
<li><code>cacheExtent</code>：设定缓存大小。</li>
</ul>
<p>默认情况下一个一个设定<code>children</code>很麻烦，所以为了方便，Flutter还提供了一个<code>builder</code>构造方法：</p>
<h2 id="ListView-builder"><a href="#ListView-builder" class="headerlink" title="ListView.builder"></a>ListView.builder</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListView.builder(&#123;</span><br><span class="line">  <span class="comment">// ListView公共参数已省略  </span></span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@required</span> IndexedWidgetBuilder itemBuilder,</span><br><span class="line">  <span class="type">int</span> itemCount,</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>itemCount</code>：是需要加载子Widget的长度；</li>
<li><code>itemBuilder</code>：列表项的构造器，当列表滚动到具体的<code>index</code>位置时，会调用该构建器构建列表项。</li>
</ul>
<p>看例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListView.builder(</span><br><span class="line">  itemCount: _provinces.length,</span><br><span class="line">  itemBuilder: (context, index) &#123;</span><br><span class="line">    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">      child: ListTile(</span><br><span class="line">        title: Text(<span class="string">&quot;$index&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">      onTap: () &#123;&#125;));</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><img src="https://cdn.littlecorgi.top/mweb/2019-10-10/ListViewBUilder.png" alt="ListViewBUilde"></p>
<h2 id="ListView-separated"><a href="#ListView-separated" class="headerlink" title="ListView.separated"></a>ListView.separated</h2><p>用于添加分割线。相较于<code>ListView.builder</code>多了一个<code>separatorBuilder</code>参数，该参数是一个分割组件生成器。</p>
<p>下面我们看一个例子：奇数行添加一条蓝色下划线，偶数行添加一条绿色下划线。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListView3</span> <span class="keyword">extends</span> <span class="title class_">StatelessWidget</span> &#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget <span class="title function_">build</span><span class="params">(BuildContext context)</span> &#123;</span><br><span class="line">    <span class="comment">//下划线widget预定义以供复用。  </span></span><br><span class="line">    Widget divider1=Divider(color: Colors.blue,);</span><br><span class="line">    Widget divider2=Divider(color: Colors.green);</span><br><span class="line">    <span class="keyword">return</span> ListView.separated(</span><br><span class="line">        itemCount: <span class="number">100</span>,</span><br><span class="line">        <span class="comment">//列表项构造器</span></span><br><span class="line">        itemBuilder: (BuildContext context, <span class="type">int</span> index) &#123;</span><br><span class="line">          <span class="keyword">return</span> ListTile(title: Text(<span class="string">&quot;$index&quot;</span>));</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//分割器构造器</span></span><br><span class="line">        separatorBuilder: (BuildContext context, <span class="type">int</span> index) &#123;</span><br><span class="line">          <span class="keyword">return</span> index%<span class="number">2</span>==<span class="number">0</span>?divider1:divider2;</span><br><span class="line">        &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action/docs/imgs/6-3.png" alt="-w160"></p>
<h1 id="GridView"><a href="#GridView" class="headerlink" title="GridView"></a>GridView</h1><p><code>GridView</code>可以构造一个网格列表，定义如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GridView(&#123;</span><br><span class="line">  <span class="type">Axis</span> <span class="variable">scrollDirection</span> <span class="operator">=</span> Axis.vertical,</span><br><span class="line">  <span class="type">bool</span> <span class="variable">reverse</span> <span class="operator">=</span> <span class="literal">false</span>,</span><br><span class="line">  ScrollController controller,</span><br><span class="line">  bool primary,</span><br><span class="line">  ScrollPhysics physics,</span><br><span class="line">  <span class="type">bool</span> <span class="variable">shrinkWrap</span> <span class="operator">=</span> <span class="literal">false</span>,</span><br><span class="line">  EdgeInsetsGeometry padding,</span><br><span class="line">  <span class="meta">@required</span> SliverGridDelegate gridDelegate, <span class="comment">//控制子widget layout的委托</span></span><br><span class="line">  <span class="type">bool</span> <span class="variable">addAutomaticKeepAlives</span> <span class="operator">=</span> <span class="literal">true</span>,</span><br><span class="line">  <span class="type">bool</span> <span class="variable">addRepaintBoundaries</span> <span class="operator">=</span> <span class="literal">true</span>,</span><br><span class="line">  <span class="type">double</span> cacheExtent,</span><br><span class="line">  List&lt;Widget&gt; children = const &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>大部分参数和<code>ListView</code>都相同，我们只关注<code>gridDelegate</code>这个参数：<br><code>gridDelegate</code>作用是控制<code>GridView</code>子组件如何排列，Flutter中提供了两个类<code>SliverGridDelegateWithFixedCrossAxisCount</code>和<code>SliverGridDelegateWithMaxCrossAxisExtent</code>，我们可以直接使用，下面我们分别来介绍一下它们。</p>
<h2 id="SliverGridDelegateWithFixedCrossAxisCount"><a href="#SliverGridDelegateWithFixedCrossAxisCount" class="headerlink" title="SliverGridDelegateWithFixedCrossAxisCount"></a>SliverGridDelegateWithFixedCrossAxisCount</h2><p>该子类实现了一个横轴为固定数量子元素的layout算法，其构造函数为：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SliverGridDelegateWithFixedCrossAxisCount(&#123;</span><br><span class="line">  <span class="meta">@required</span> <span class="type">double</span> crossAxisCount, </span><br><span class="line">  <span class="type">double</span> <span class="variable">mainAxisSpacing</span> <span class="operator">=</span> <span class="number">0.0</span>,</span><br><span class="line">  <span class="type">double</span> <span class="variable">crossAxisSpacing</span> <span class="operator">=</span> <span class="number">0.0</span>,</span><br><span class="line">  <span class="type">double</span> <span class="variable">childAspectRatio</span> <span class="operator">=</span> <span class="number">1.0</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>crossAxisCount</code>：横轴子元素的数量。此属性值确定后子元素在横轴的长度就确定了，即<code>ViewPort</code>横轴长度除以<code>crossAxisCount</code>的商。</li>
<li><code>mainAxisSpacing</code>：主轴方向的间距。</li>
<li><code>crossAxisSpacing</code>：横轴方向子元素的间距。</li>
<li><code>childAspectRatio</code>：子元素在横轴长度和主轴长度的比例。由于<code>crossAxisCount</code>指定后，子元素横轴长度就确定了，然后通过此参数值就可以确定子元素在主轴的长度。</li>
</ul>
<h2 id="SliverGridDelegateWithMaxCrossAxisExtent"><a href="#SliverGridDelegateWithMaxCrossAxisExtent" class="headerlink" title="SliverGridDelegateWithMaxCrossAxisExtent"></a>SliverGridDelegateWithMaxCrossAxisExtent</h2><p>该子类实现了一个横轴子元素为固定最大长度的layout算法，其构造函数为：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SliverGridDelegateWithMaxCrossAxisExtent(&#123;</span><br><span class="line">  <span class="type">double</span> maxCrossAxisExtent,</span><br><span class="line">  <span class="type">double</span> <span class="variable">mainAxisSpacing</span> <span class="operator">=</span> <span class="number">0.0</span>,</span><br><span class="line">  <span class="type">double</span> <span class="variable">crossAxisSpacing</span> <span class="operator">=</span> <span class="number">0.0</span>,</span><br><span class="line">  <span class="type">double</span> <span class="variable">childAspectRatio</span> <span class="operator">=</span> <span class="number">1.0</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><code>maxCrossAxisExtent</code>为子元素在横轴上的最大长度，之所以是“最大”长度，是因为横轴方向每个子元素的长度仍然是等分的。其它参数和<code>SliverGridDelegateWithFixedCrossAxisCount</code>相同。</p>
<h2 id="GridView-builder"><a href="#GridView-builder" class="headerlink" title="GridView.builder"></a>GridView.builder</h2><p>和<code>ListView</code>一样，当子Widget数量较多时，也提供了<code>builder</code>方法:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GridView.builder(</span><br><span class="line"> ...</span><br><span class="line"> <span class="meta">@required</span> SliverGridDelegate gridDelegate, </span><br><span class="line"> <span class="meta">@required</span> IndexedWidgetBuilder itemBuilder,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>这个就不在这举例了，<code>gridDelegate</code>和前面一样的，<code>itemBuilder</code>和<code>ListView</code>的一样的。</p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter入门并开发天气预报APP(6)——天气预报第一步-界面</title>
    <url>/posts/15395a84.html</url>
    <content><![CDATA[<p>经过前面的对于Flutter的介绍，我们现在已经可以开始写我们的天气预报APP的界面了。</p>
<p>项目Github地址：<a href="https://github.com/a1203991686/CoolWeather_Flutter">a1203991686/CoolWeather_Flutter</a></p>
<span id="more"></span>
<h1 id="1-大致界面"><a href="#1-大致界面" class="headerlink" title="1. 大致界面"></a>1. 大致界面</h1><p>最终写成的大致界面如图：</p>
<p><img src="https://cdn.littlecorgi.top/mweb/2019-10-11/Screenshot_1570712111.png" width = 50% /></p>
<p>我们可以把这个界面拆分成如下部分：</p>
<p><img src="https://cdn.littlecorgi.top/mweb/2019-10-11/Screenshot_1570711214.png" width = 50% /></p>
<p>可以看到我们APP主要有最上面用来显示地点和刷新时间的<code>Title</code>、显示温度和天气的两个<code>Text</code>、显示3天预报的<code>ListView</code>、显示空气质量的<code>GridView</code>、以及最后显示生活建议的<code>ListView</code>。</p>
<p>此处会用到我们前面学过的所有知识，如果有同学没有看过前面内容的，可以看下本系列前面的文章。</p>
<h1 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2. 创建项目"></a>2. 创建项目</h1><p>首先我们创建一个新的Flutter项目：</p>
<ol>
<li>在AndroidStudio点击<code>File</code>-&gt;<code>New Flutter Project</code>；</li>
<li>接着选择<code>Flutter Application</code>-&gt;<code>NEXT</code>。接着填写你的项目名称等一系列信息后点击<code>next</code>；<img src="https://cdn.littlecorgi.top/mweb/2019-10-11/New%20Flutter%20Project.png" alt="New Flutter Project"></li>
<li>接着输入你的组织/公司名称作为包名，最后点击<code>Finish</code>即可，这样就新建了一个Flutter项目，并且Flutter会自动为你生成一个计数器Demo；<br> <img src="https://cdn.littlecorgi.top/mweb/2019-10-11/package%20new.png" alt="package ne"></li>
<li>让我们把<code>mian.dart</code>里面的所有注释以及<code>_MyHomePageState</code>里面的<code>build</code>方法里面的代码都删掉；</li>
<li>接着在<code>lib</code>文件夹下新建一个文件夹，名叫<code>view</code>，到时候我们把所有与界面有关的代码文件都放在这个文件夹下面；</li>
<li>然后我们在<code>view</code>文件夹下面新建一个dart文件，命名为<code>main_page</code>。这个就是我们的天气详情页。</li>
</ol>
<h1 id="3-设计好天气详情页框架"><a href="#3-设计好天气详情页框架" class="headerlink" title="3. 设计好天气详情页框架"></a>3. 设计好天气详情页框架</h1><p>首先我们需要导入<code>material</code>包，我们项目主要用material风格UI来写。</p>
<p>在开头输入<code>import &#39;package:flutter/material.dart&#39;;</code>，这样就导入了<code>material</code>包。接着创建我们的界面类<code>MainPage</code>。</p>
<p>由于我们在到时候写好网络请求后，所有的数据都得从网络获取，并且使用了异步的方法，也就是说我们先把页面加载了然后等获取的数据回来了在通知Flutter更新状态，所以这块我们得使用<code>StatefulWidget</code>。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainPage</span> <span class="keyword">extends</span> <span class="title class_">StatefulWidget</span> &#123;</span><br><span class="line">  MainPage(&#123;Key key&#125;) : <span class="built_in">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  MainPageState <span class="title function_">createState</span><span class="params">()</span> =&gt; <span class="keyword">new</span> <span class="title class_">MainPageState</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainPageState</span> <span class="keyword">extends</span> <span class="title class_">State</span>&lt;MainPage&gt; &#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget <span class="title function_">build</span><span class="params">(BuildContext context)</span> &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着我们就得开始写<code>build()</code>里面的内容了。由于我们需要一个全屏的背景图片，所以我们就使用<code>Container</code>作为我们最外层的Widget，并使用<code>BoxDecoration</code>装饰容器配合<code>DecorationImage</code>来放置图片：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget <span class="title function_">build</span><span class="params">(BuildContext context)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Container(</span><br><span class="line">    decoration: BoxDecoration(</span><br><span class="line">      image: DecorationImage(</span><br><span class="line">        image: NetworkImage(<span class="string">&quot;http://blog.mrabit.com/bing/today&quot;</span>), <span class="comment">//必应每日一图背景</span></span><br><span class="line">        fit: BoxFit.cover, <span class="comment">// 设置为全屏</span></span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">    child: _weatherBody(),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候我们的运行结果如图(①你背景图片多半和我不一样，因为上面那个Uri获取的是必应的每日一图，每天图片都不一样；②运行的时候记得把<code>child: _weatherBody(),</code>给注释掉，因为我们还没有定义<code>_weatherBody()</code>这个方法):</p>
<p><img src="https://cdn.littlecorgi.top/mweb/2019-10-11/Screenshot_1570797585.png" width = 50% /></p>
<h1 id="4-设计title"><a href="#4-设计title" class="headerlink" title="4. 设计title"></a>4. 设计title</h1><p>为了方便我就直接把剩下的布局单领出来放到<code>_weatherBody()</code>这个方法:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Widget <span class="title function_">_weatherBody</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于我们需要实现一个有Title的页面，所以最外层我选用了Scaffold：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Widget <span class="title function_">_weatherBody</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Scaffold(</span><br><span class="line">    backgroundColor: Colors.transparent, <span class="comment">//背景透明</span></span><br><span class="line">    appBar: AppBar(</span><br><span class="line">      centerTitle: <span class="literal">true</span>,</span><br><span class="line">      title: Text(</span><br><span class="line">        <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">        style: TextStyle(fontSize: <span class="number">25.0</span>),</span><br><span class="line">      ),</span><br><span class="line">      backgroundColor: Colors.transparent, <span class="comment">//背景透明</span></span><br><span class="line">      actions: &lt;Widget&gt;[ <span class="comment">//右侧Widget，相当于Android Toolbar中的menu</span></span><br><span class="line">        Container(</span><br><span class="line">          alignment: Alignment.center, <span class="comment">//向中间对齐</span></span><br><span class="line">          child: Text(</span><br><span class="line">            <span class="string">&quot;12:10&quot;</span>,</span><br><span class="line">            textAlign: TextAlign.center, <span class="comment">//文字向中间对齐</span></span><br><span class="line">          ),</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    ),</span><br><span class="line">    body: SingleChildScrollView( <span class="comment">// 由于到时候整个页面一个屏幕可能放不下，就放置了一个滚动布局</span></span><br><span class="line">    </span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候的运行结果是：</p>
<p><img src="https://cdn.littlecorgi.top/mweb/2019-10-11/Screenshot_1570797746.png" width = 50% /></p>
<h1 id="5-设计下面天气预报页面"><a href="#5-设计下面天气预报页面" class="headerlink" title="5. 设计下面天气预报页面"></a>5. 设计下面天气预报页面</h1><p>接下来可以开始下下面的天气显示页面了。</p>
<h2 id="当前温度和天气情况"><a href="#当前温度和天气情况" class="headerlink" title="当前温度和天气情况"></a>当前温度和天气情况</h2><p>首先写一个纵向线性布局<code>Column</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">body: SingleChildScrollView(</span><br><span class="line">  child: Column(</span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">      </span><br><span class="line">    ]</span><br><span class="line">  )</span><br><span class="line">),</span><br></pre></td></tr></table></figure><br>由于我们要显示在屏幕最右边，所以使用Align:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">body: SingleChildScrollView(</span><br><span class="line">  child: Column(</span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">      Align(</span><br><span class="line">        alignment: Alignment.centerRight,</span><br><span class="line">        child:Text(</span><br><span class="line">          <span class="string">&quot;26°C&quot;</span>,</span><br><span class="line">          style: TextStyle(</span><br><span class="line">            fontSize: <span class="number">50.0</span>,</span><br><span class="line">            color: Colors.white,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      Align(</span><br><span class="line">        alignment: Alignment.centerRight,</span><br><span class="line">        child:Text(</span><br><span class="line">          <span class="string">&quot;阴&quot;</span>,</span><br><span class="line">          style: TextStyle(</span><br><span class="line">            fontSize: <span class="number">20.0</span>,</span><br><span class="line">            color: Colors.white,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ]</span><br><span class="line">  )</span><br><span class="line">),</span><br></pre></td></tr></table></figure></p>
<p>运行结果是：</p>
<p><img src="https://cdn.littlecorgi.top/mweb/2019-10-11/Screenshot_1570797847.png" width = 50% /></p>
<p>接下来我们需要显示3天天气预报、天气质量以及生活建议的三个子控件，同样为了方便我们也把他们给单领出来，于是上面的Column接下来可以这样写：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">body: SingleChildScrollView(</span><br><span class="line">  child: Column(</span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">      ... <span class="comment">//上面的两个Text</span></span><br><span class="line">      Padding(</span><br><span class="line">        padding: EdgeInsets.only(</span><br><span class="line">          left: <span class="number">15.0</span>,</span><br><span class="line">          right: <span class="number">15.0</span>,</span><br><span class="line">          bottom: <span class="number">15.0</span>,</span><br><span class="line">        ),</span><br><span class="line">        child: Container(</span><br><span class="line">          color: Colors.black54,</span><br><span class="line">          child: _weatherList(), <span class="comment">//3天天气预报</span></span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      Padding(</span><br><span class="line">        padding: EdgeInsets.only(</span><br><span class="line">          left: <span class="number">15.0</span>,</span><br><span class="line">          right: <span class="number">15.0</span>,</span><br><span class="line">        ),</span><br><span class="line">        child: Container(</span><br><span class="line">          color: Colors.black54,</span><br><span class="line">          child: _atmosphereList(), <span class="comment">//空气质量</span></span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      Padding(</span><br><span class="line">        padding: EdgeInsets.only(</span><br><span class="line">          top: <span class="number">15.0</span>,</span><br><span class="line">          left: <span class="number">15.0</span>,</span><br><span class="line">          right: <span class="number">15.0</span>,</span><br><span class="line">          bottom: <span class="number">15.0</span>,</span><br><span class="line">        ),</span><br><span class="line">        child: Container(</span><br><span class="line">          color: Colors.black54,</span><br><span class="line">          child: _lifestyleList(), <span class="comment">//生活建议</span></span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ]</span><br><span class="line">  )</span><br><span class="line">),</span><br></pre></td></tr></table></figure></p>
<h2 id="3天天气预报"><a href="#3天天气预报" class="headerlink" title="3天天气预报"></a>3天天气预报</h2><p>对于3天天气预报我们主要通过ListView来实现，由于到时候数据比较灵活，所以我们就直接使用ListView.Builder来实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; dates = [<span class="string">&quot;2019/10/01&quot;</span>, <span class="string">&quot;2019/10/02&quot;</span>, <span class="string">&quot;2019/10/03&quot;</span>];</span><br><span class="line">List&lt;String&gt; temperatures = [<span class="string">&quot;29/14&quot;</span>, <span class="string">&quot;30/18&quot;</span>, <span class="string">&quot;29/18&quot;</span>];</span><br><span class="line">List&lt;String&gt; texts = [<span class="string">&quot;阴&quot;</span>, <span class="string">&quot;晴&quot;</span>, <span class="string">&quot;雨&quot;</span>];</span><br><span class="line"></span><br><span class="line">Widget <span class="title function_">_weatherList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">            Align(</span><br><span class="line">                alignment: Alignment.centerLeft,</span><br><span class="line">                child: Text(</span><br><span class="line">                    <span class="string">&quot;预报&quot;</span>,</span><br><span class="line">                    style: TextStyle(</span><br><span class="line">                        color: Colors.white,</span><br><span class="line">                        fontSize: <span class="number">20.0</span>,</span><br><span class="line">                    ),</span><br><span class="line">                ),</span><br><span class="line">            ),</span><br><span class="line">            ListView.builder(</span><br><span class="line">                shrinkWrap: <span class="literal">true</span>, <span class="comment">//这个是指根据ListView所有子Widget的长度来设定ListView的长度</span></span><br><span class="line">                physics: NeverScrollableScrollPhysics(), <span class="comment">//禁止ListView自己的滑动，因为我们在外面用了个SingleChildScrollView，我们通过他的滑动就可以了</span></span><br><span class="line">                itemCount: dates.length, <span class="comment">//ListView子项个数</span></span><br><span class="line">                itemBuilder: (BuildContext context, <span class="type">int</span> index) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ListTile(</span><br><span class="line">                        title: Row(</span><br><span class="line">                            mainAxisAlignment: MainAxisAlignment.spaceBetween, <span class="comment">//这个是Row的主轴的子项的分布格式，spaceBetween是指平均分布</span></span><br><span class="line">                            mainAxisSize: MainAxisSize.max,</span><br><span class="line">                            children: &lt;Widget&gt;[</span><br><span class="line">                                Text(</span><br><span class="line">                                    <span class="string">&quot;$&#123;dates[index]&#125;&quot;</span>,</span><br><span class="line">                                    style: TextStyle(color: Colors.white),</span><br><span class="line">                                ),</span><br><span class="line">                                Text(</span><br><span class="line">                                    <span class="string">&quot;$&#123;temperatures[index]&#125;&quot;</span>,</span><br><span class="line">                                    style: TextStyle(color: Colors.white),</span><br><span class="line">                                ),</span><br><span class="line">                                Text(</span><br><span class="line">                                    <span class="string">&quot;$&#123;texts[index]&#125;&quot;</span>,</span><br><span class="line">                                    style: TextStyle(color: Colors.white),</span><br><span class="line">                                ),</span><br><span class="line">                            ],</span><br><span class="line">                        ),</span><br><span class="line">                    );</span><br><span class="line">                &#125;),</span><br><span class="line">        ],</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候运行结果是：</p>
<p><img src="https://cdn.littlecorgi.top/mweb/2019-10-11/Screenshot_1570798505.png" width = 50% /></p>
<h2 id="空气质量"><a href="#空气质量" class="headerlink" title="空气质量"></a>空气质量</h2><p>这块我们需要用到GridView，由于只有两个显示内容，而且我们后期也没有需要动态添加的需求，所以我们就直接使用GridView构造方法，而不去使用GridView的builder方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; atmospheres = [<span class="string">&quot;16&quot;</span>, <span class="string">&quot;56&quot;</span>];</span><br><span class="line"></span><br><span class="line">Widget <span class="title function_">_atmosphereList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">            Align(</span><br><span class="line">                alignment: Alignment.centerLeft,</span><br><span class="line">                child: Text(</span><br><span class="line">                    <span class="string">&quot;空气质量&quot;</span>,</span><br><span class="line">                    style: TextStyle(</span><br><span class="line">                        color: Colors.white,</span><br><span class="line">                            fontSize: <span class="number">20.0</span>,</span><br><span class="line">                    ),</span><br><span class="line">                ),</span><br><span class="line">            ),</span><br><span class="line">            GridView(</span><br><span class="line">                shrinkWrap: <span class="literal">true</span>, <span class="comment">//见上面3天天气预报的ListView处</span></span><br><span class="line">                physics: NeverScrollableScrollPhysics(), <span class="comment">//见上面3天天气预报的ListView处</span></span><br><span class="line">                gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">                    crossAxisCount: <span class="number">2</span>, <span class="comment">//横轴三个子widget</span></span><br><span class="line">                    childAspectRatio: <span class="number">2</span> <span class="comment">//显示区域宽高相等</span></span><br><span class="line">                ),</span><br><span class="line">                children: &lt;Widget&gt;[</span><br><span class="line">                    Column(</span><br><span class="line">                        children: &lt;Widget&gt;[</span><br><span class="line">                            Text(</span><br><span class="line">                                <span class="string">&quot;$&#123;atmospheres[0]&#125;&quot;</span>,</span><br><span class="line">                                style: TextStyle(</span><br><span class="line">                                    color: Colors.white,</span><br><span class="line">                                    fontSize: <span class="number">40.0</span>,</span><br><span class="line">                                ),</span><br><span class="line">                            ),</span><br><span class="line">                            Text(</span><br><span class="line">                                <span class="string">&quot;能见度&quot;</span>,</span><br><span class="line">                                style: TextStyle(</span><br><span class="line">                                    color: Colors.white,</span><br><span class="line">                                    fontSize: <span class="number">20.0</span>,</span><br><span class="line">                                ),</span><br><span class="line">                            ),</span><br><span class="line">                        ],</span><br><span class="line">                    ),</span><br><span class="line">                    Column(</span><br><span class="line">                        children: &lt;Widget&gt;[</span><br><span class="line">                            Text(</span><br><span class="line">                                <span class="string">&quot;$&#123;atmospheres[1]&#125;&quot;</span>,</span><br><span class="line">                                style: TextStyle(</span><br><span class="line">                                    color: Colors.white,</span><br><span class="line">                                    fontSize: <span class="number">40.0</span>,</span><br><span class="line">                                ),</span><br><span class="line">                            ),</span><br><span class="line">                            Text(</span><br><span class="line">                                <span class="string">&quot;湿度&quot;</span>,</span><br><span class="line">                                style: TextStyle(</span><br><span class="line">                                    color: Colors.white,</span><br><span class="line">                                    fontSize: <span class="number">20.0</span>,</span><br><span class="line">                                ),</span><br><span class="line">                            ),</span><br><span class="line">                        ],</span><br><span class="line">                    ),</span><br><span class="line">                ],</span><br><span class="line">            ),</span><br><span class="line">        ],</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行后的效果是：</p>
<p><img src="https://cdn.littlecorgi.top/mweb/2019-10-11/Screenshot_1570799107.png" width = 50% /></p>
<h2 id="生活建议"><a href="#生活建议" class="headerlink" title="生活建议"></a>生活建议</h2><p>这块和3天天气预报一样，而且数据比3天天气预报更多，所以他更适合用ListView.builder：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; _lifestyleWeatherBrf = [</span><br><span class="line">    <span class="string">&quot;较舒适&quot;</span>,</span><br><span class="line">    <span class="string">&quot;较舒适&quot;</span>,</span><br><span class="line">    <span class="string">&quot;适宜&quot;</span>,</span><br><span class="line">    <span class="string">&quot;适宜&quot;</span>,</span><br><span class="line">    <span class="string">&quot;弱&quot;</span>,</span><br><span class="line">    <span class="string">&quot;较适宜&quot;</span>,</span><br><span class="line">    <span class="string">&quot;中&quot;</span></span><br><span class="line">];</span><br><span class="line">List&lt;String&gt; _lifestyleWeatherTxt = [</span><br><span class="line">    <span class="string">&quot;白天天气晴好，早晚会感觉偏凉，午后舒适、宜人。&quot;</span>,</span><br><span class="line">    <span class="string">&quot;建议着薄外套、开衫牛仔衫裤等服装。年老体弱者应适当添加衣物，宜着夹克衫、薄毛衣等。&quot;</span>,</span><br><span class="line">    <span class="string">&quot;各项气象条件适宜，无明显降温过程，发生感冒机率较低。&quot;</span>,</span><br><span class="line">    <span class="string">&quot;天气较好，赶快投身大自然参与户外运动，尽情感受运动的快乐吧。&quot;</span>,</span><br><span class="line">    <span class="string">&quot;天气较好，但丝毫不会影响您出行的心情。温度适宜又有微风相伴，适宜旅游。&quot;</span>,</span><br><span class="line">    <span class="string">&quot;紫外线强度较弱，建议出门前涂擦SPF在12-15之间、PA+的防晒护肤品。&quot;</span>,</span><br><span class="line">    <span class="string">&quot;较适宜洗车，未来一天无雨，风力较小，擦洗一新的汽车至少能保持一天。&quot;</span>,</span><br><span class="line">    <span class="string">&quot;,气象条件对空气污染物稀释、扩散和清除无明显影响，易感人群应适当减少室外活动时间。&quot;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">Widget <span class="title function_">_lifestyleList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">            Align(</span><br><span class="line">                alignment: Alignment.centerLeft,</span><br><span class="line">                child: Text(</span><br><span class="line">                    <span class="string">&quot;生活建议&quot;</span>,</span><br><span class="line">                    style: TextStyle(</span><br><span class="line">                        color: Colors.white,</span><br><span class="line">                        fontSize: <span class="number">20.0</span>,</span><br><span class="line">                    ),</span><br><span class="line">                ),</span><br><span class="line">            ),</span><br><span class="line">            ListView.builder(</span><br><span class="line">                shrinkWrap: <span class="literal">true</span>,</span><br><span class="line">                physics: NeverScrollableScrollPhysics(),</span><br><span class="line">                itemCount: _lifestyleWeatherBrf.length,</span><br><span class="line">                itemBuilder: (BuildContext context, <span class="type">int</span> index) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ListTile(</span><br><span class="line">                        title: Column(</span><br><span class="line">                            mainAxisAlignment: MainAxisAlignment.start,</span><br><span class="line">                            crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">                            children: &lt;Widget&gt;[</span><br><span class="line">                                Text(</span><br><span class="line">                                    <span class="string">&quot;$&#123;_lifestyleWeatherBrf[index]&#125;&quot;</span>,</span><br><span class="line">                                    style: TextStyle(</span><br><span class="line">                                        color: Colors.white,</span><br><span class="line">                                    ),</span><br><span class="line">                                ),</span><br><span class="line">                                Text(</span><br><span class="line">                                    <span class="string">&quot;$&#123;_lifestyleWeatherTxt[index]&#125;&quot;</span>,</span><br><span class="line">                                    style: TextStyle(</span><br><span class="line">                                        color: Colors.white,</span><br><span class="line">                                    ),</span><br><span class="line">                                ),</span><br><span class="line">                            ],</span><br><span class="line">                        ),</span><br><span class="line">                    );</span><br><span class="line">                &#125;,</span><br><span class="line">            ),</span><br><span class="line">        ],</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果是:</p>
<p><img src="https://cdn.littlecorgi.top/mweb/2019-10-11/Screenshot_1570799686.png" width = 50% /></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter入门并开发天气预报APP(7)——Http网络请求、Json转Dart实体类及异步更新UI</title>
    <url>/posts/163d319c.html</url>
    <content><![CDATA[<blockquote>
<p>相关Demo源码可见Github <a href="https://github.com/a1203991686/CoolWeather_Flutter">a1203991686/CoolWeather_Flutter</a></p>
</blockquote>
<span id="more"></span>
<h1 id="Flutter-Http-网络请求"><a href="#Flutter-Http-网络请求" class="headerlink" title="Flutter Http 网络请求"></a>Flutter Http 网络请求</h1><p>Flutter网络请求可分为两种方式，一种为<code>Dart:IO</code>库中为我们提供的<code>HttpClient</code>，另一种为Dart第三方库<code>Dio</code>。</p>
<h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p><code>HttpClient</code>是<code>Dart:IO</code>库自带的一个类，通过他来实现网络请求最底层、也可以完完全全的自定义设置，但是相对于其他人封装好的第三方库来说显得复杂。</p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>导入<code>Dart:IO</code>库：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:io&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="创建一个HttpClient"><a href="#创建一个HttpClient" class="headerlink" title="创建一个HttpClient:"></a>创建一个HttpClient:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpClient</span>();</span><br></pre></td></tr></table></figure>
<h3 id="创建一个Uri"><a href="#创建一个Uri" class="headerlink" title="创建一个Uri"></a>创建一个Uri</h3><p>如果你是<code>Http</code>请求：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Uri</span>.http(</span><br><span class="line">    host,</span><br><span class="line">    queryParameters: &#123;</span><br><span class="line">        <span class="string">&quot;xx&quot;</span>:<span class="string">&quot;xx&quot;</span>,</span><br><span class="line">        <span class="string">&quot;yy&quot;</span>:<span class="string">&quot;dd&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>如果你是<code>Https</code>请求：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Uri</span>.https(</span><br><span class="line">    host,</span><br><span class="line">    queryParameters: &#123;</span><br><span class="line">        <span class="string">&quot;xx&quot;</span>:<span class="string">&quot;xx&quot;</span>,</span><br><span class="line">        <span class="string">&quot;yy&quot;</span>:<span class="string">&quot;dd&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="根据uri获取返回数据"><a href="#根据uri获取返回数据" class="headerlink" title="根据uri获取返回数据"></a>根据uri获取返回数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HttpClientRequest</span> <span class="variable">request</span> <span class="operator">=</span> await httpClient.getUrl(uri);</span><br><span class="line"><span class="type">HttpClientResponse</span> <span class="variable">response</span> <span class="operator">=</span> await request.close();</span><br></pre></td></tr></table></figure>
<h3 id="读取内容"><a href="#读取内容" class="headerlink" title="读取内容"></a>读取内容</h3><p>进行这一步得导入<code>dart:convert</code>库：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:convert&#x27;</span>;</span><br><span class="line"></span><br><span class="line">... <span class="comment">//省略中间代码 </span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">responseBody</span> <span class="operator">=</span> await response.transform(Utf8Decoder()).join();</span><br><span class="line"></span><br><span class="line">print(respinseBody)</span><br></pre></td></tr></table></figure></p>
<h3 id="最后关闭Client"><a href="#最后关闭Client" class="headerlink" title="最后关闭Client"></a>最后关闭Client</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">httpClient.close();</span><br></pre></td></tr></table></figure>
<h2 id="Dio"><a href="#Dio" class="headerlink" title="Dio"></a>Dio</h2><p><code>Dio</code>是Dart社区上别人上传的第三方库，他封装了<code>HttpClient</code>，相较来说更为简单、方便。</p>
<h3 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h3><p>在项目的<code>pubspec.yaml</code>文件的<code>dependencies</code>中导入<code>Dio</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  dio: </span><br><span class="line">  <span class="comment">// 如果冒号后面不带具体版本信息则表示自动下载最新版</span></span><br></pre></td></tr></table></figure></p>
<p>接着在需要使用的代码文件里面，<code>import</code>导入他：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:dio/dio.dart&#x27;</span>;</span><br></pre></td></tr></table></figure><br>接着我们就可以使用<code>Dio</code>了。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>首先得创建一个<code>Dio</code>对象。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Dio</span> <span class="variable">dio</span> <span class="operator">=</span>  Dio();</span><br></pre></td></tr></table></figure></p>
<p>发起<code>GET</code>请求：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Response response;</span><br><span class="line">response=await dio.get(uri)</span><br><span class="line">print(response.data.toString());</span><br></pre></td></tr></table></figure></p>
<p>发起<code>POST</code>请求：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response=await dio.post(uri);</span><br></pre></td></tr></table></figure></p>
<h1 id="Json转Dart"><a href="#Json转Dart" class="headerlink" title="Json转Dart"></a>Json转Dart</h1><h2 id="手动生成Dart实体类"><a href="#手动生成Dart实体类" class="headerlink" title="手动生成Dart实体类"></a>手动生成Dart实体类</h2><p>首先得大家安利一个网站，因为Dart实体类比Java实体类多了几个方法，所以相对来说麻烦，通过这个网站就可以自动生成json数据对应的实体类:<br><a href="https://caijinglong.github.io/json2dart/">https://caijinglong.github.io/json2dart/</a></p>
<p><img src="https://cdn.littlecorgi.top/mweb/2019-10-12/json2dart.png" alt="json2dart"></p>
<p>比方说我们使用这个链接(<a href="http://guolin.tech/api/china)，并让他自动转dart：">http://guolin.tech/api/china)，并让他自动转dart：</a><br><img src="https://cdn.littlecorgi.top/mweb/2019-10-12/Province.png" alt="Province"></p>
<p>接下来只需要创建dart文件，然后再把代码复制进去就行了。</p>
<p>不出意外，代码肯定会报错。<br><img src="https://cdn.littlecorgi.top/mweb/2019-10-12/dart%E5%AE%9E%E4%BD%93%E7%B1%BB.png" alt="dart实体类"></p>
<p>报错信息为:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">error: Target of URI hasn<span class="string">&#x27;t been generated: &#x27;</span>province.g.dart<span class="string">&#x27;. (uri_has_not_been_generated at [cool_weather] lib/bean/province.dart:3)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">error: The method &#x27;</span>_$ProvinceFromJson<span class="string">&#x27; isn&#x27;</span>t defined <span class="keyword">for</span> the class <span class="string">&#x27;Province&#x27;</span>. (undefined_method at [cool_weather] lib/bean/province.dart:<span class="number">31</span>)</span><br><span class="line"></span><br><span class="line">error: The method <span class="string">&#x27;_$ProvinceToJson&#x27;</span> isn<span class="string">&#x27;t defined for the class &#x27;</span>Province<span class="string">&#x27;. (undefined_method at [cool_weather] lib/bean/province.dart:33)</span></span><br></pre></td></tr></table></figure></p>
<p>这是因为我们项目下还没有<code>province.g.dart</code>这个文件，这个文件是根据dart实体类自动生成的，那么我们该怎么生成他呢？</p>
<p>这个时候我们需要在<code>pubspec.yaml</code>文件中导入三个依赖包：<br><img src="https://cdn.littlecorgi.top/mweb/2019-10-12/%E8%BD%ACdart.png" alt="转dart"><br>我们重点只需要管三个写着需要导入的。输入之后点击<code>pubspec.yaml</code>文件右上角的<code>packages get</code>，就会自动下载包了。</p>
<p>然后在终端中，转到项目根目录下，输入<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flutter packages pub run build_runner build</span><br></pre></td></tr></table></figure><br>接着你就会惊喜的发现，在你的dart实体类下面多了一个文件，也就是你所缺失的~.g.dart文件，并且实体类中那些报错也都没了。<br><img src="https://cdn.littlecorgi.top/mweb/2019-10-12/dart.g.dart.png" alt="dart.g.dart"></p>
<h2 id="将请求回来的Response转为Dart实体类"><a href="#将请求回来的Response转为Dart实体类" class="headerlink" title="将请求回来的Response转为Dart实体类"></a>将请求回来的Response转为Dart实体类</h2><p>接着HttpClient返回来的responseBody或者Dio返回的response</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Province&gt; provinceList;</span><br><span class="line">provinceList = ProvinceList.getProvinceList(jsonResponse);</span><br></pre></td></tr></table></figure>
<p>provinceList就是返回来的数据转成的实体类的对象了。</p>
<h1 id="异步更新UI"><a href="#异步更新UI" class="headerlink" title="异步更新UI"></a>异步更新UI</h1><p>在此处介绍两种方法，第一种是我自己想出来的沙雕方法，第二种是通过Flutter提供的专门用于异步更新UI的组件FutureBuilder。</p>
<h2 id="沙雕方法"><a href="#沙雕方法" class="headerlink" title="沙雕方法"></a>沙雕方法</h2><p>在此说一下我这个方法的想法。</p>
<p>大家可以回顾下我之前讲Widget的时候说过，Widget有一个方法initState可以用来加载UI，以及一个setState方法可用来提醒Flutter重新加载UI。</p>
<p>说到这很多同学一定想到了，我们可以在获取到数据之后通过setState方法来更新UI。</p>
<h3 id="获取到数据"><a href="#获取到数据" class="headerlink" title="获取到数据"></a>获取到数据</h3><p>这个不同多说，上面讲的全都是获取数据。</p>
<h3 id="设置一个空的实体类"><a href="#设置一个空的实体类" class="headerlink" title="设置一个空的实体类"></a>设置一个空的实体类</h3><p>此处我还是拿上面的Province.dart来做例子。我们正常情况下获取到的数据转成的实体类的对象是<code>List&lt;Province&gt; provinceList</code>。所以我们此处先设置一个空的对象:<code>List&lt;Province&gt; _provinceList</code>。</p>
<p>接着在initState里面调用网络请求的方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">initState</span><span class="params">()</span> &#123;</span><br><span class="line">    getProvince();</span><br><span class="line">    <span class="built_in">super</span>.initState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在getProvince方法里面获取数据，并将数据provinceList传给_provinceList：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">getProvince</span><span class="params">()</span> async &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">response</span> <span class="operator">=</span> await <span class="title function_">Dio</span><span class="params">()</span>.get(<span class="string">&quot;http://guolin.tech/api/china&quot;</span>);</span><br><span class="line">    provinceList = ProvinceList.getProvinceList(response);</span><br><span class="line">    setState(() &#123;</span><br><span class="line">        _provinces = provinceList;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以当获取到数据的时候就通知Flutter更新状态了。这个时候有的同学可能会问我，你这个也只是获取到数据的时候才更新啊，那当还没获取到数据的时候呢？</p>
<p>这块就体现到了为什么我们要设置一个_provinces了。</p>
<p>我们完全可以在build方法设置下，判断下_provinces为不为空:如果为空，就证明没数据，就加载其它页面；如果不为空，就证明有数据了，那就加载数据。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">body: _provinces == <span class="literal">null</span></span><br><span class="line">          ? <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;正在请求&quot;</span>)</span><br><span class="line">          : <span class="keyword">new</span> <span class="title class_">ListView</span>.builder(</span><br><span class="line">          ... <span class="comment">//省去代码，总的来说就是将_provinces的数据加载ListView里面，一个ListView的基本构造方法</span></span><br><span class="line">          )</span><br></pre></td></tr></table></figure></p>
<h2 id="FutureBuilder"><a href="#FutureBuilder" class="headerlink" title="FutureBuilder"></a>FutureBuilder</h2><p>回归正题，我上面那个方法真的是有够沙雕的。</p>
<p>那我们来看看这个名正言顺的Flutter亲生儿子FutureBuilder。</p>
<p>首先我们看下定义：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FutureBuilder(&#123;</span><br><span class="line">  <span class="built_in">this</span>.future,</span><br><span class="line">  <span class="built_in">this</span>.initialData,</span><br><span class="line">  <span class="meta">@required</span> <span class="built_in">this</span>.builder,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>future：异步任务；</li>
<li>initialData：初始化数据；</li>
<li>builder：builder方法。</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">body: FutureBuilder(</span><br><span class="line">    future: Dio().get(<span class="string">&quot;http://guolin.tech/api/china&quot;</span>),</span><br><span class="line">    builder: (BuildContext context, AsyncSnapshot snapshot) &#123;</span><br><span class="line">        <span class="keyword">if</span> (snapshot.connectionState == ConnectionState.done) &#123;</span><br><span class="line">            <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> snapshot.data;</span><br><span class="line">            print(response.toString());</span><br><span class="line">            <span class="comment">//发生错误</span></span><br><span class="line">            <span class="keyword">if</span> (snapshot.hasError) &#123;</span><br><span class="line">                <span class="keyword">return</span> Text(snapshot.error.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            provinceList = ProvinceList.fromJson(response.data);</span><br><span class="line">            <span class="comment">//请求成功，通过项目信息构建用于显示项目名称的ListView</span></span><br><span class="line">            <span class="keyword">return</span> ListView.builder(</span><br><span class="line">                itemCount: provinceList.provinces.length,</span><br><span class="line">                itemBuilder: (context, index) &#123;</span><br><span class="line">                    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">                        child: ListTile(</span><br><span class="line">                            title: Text(<span class="string">&quot;$&#123;provinceList.provinces[index].name&#125;&quot;</span>),</span><br><span class="line">                        ),</span><br><span class="line">                        onTap: () &#123;</span><br><span class="line">                            Navigator.push(context,</span><br><span class="line">                                MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">                                    <span class="keyword">return</span> CityPageWidget(</span><br><span class="line">                                        cityID: provinceList.provinces[index].id);</span><br><span class="line">                                &#125;));</span><br><span class="line">                        &#125;,</span><br><span class="line">                    );</span><br><span class="line">                &#125;,</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 请求未完成时弹出loading</span></span><br><span class="line">        <span class="keyword">return</span> CircularProgressIndicator();</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter入门并开发天气预报APP(8)——天气预报第二步-选择省、市、区界面及网络请求</title>
    <url>/posts/f0e3723.html</url>
    <content><![CDATA[<blockquote>
<p>项目Github地址：<a href="https://github.com/a1203991686/CoolWeather_Flutter">a1203991686/CoolWeather_Flutter</a></p>
</blockquote>
<p>在第六章中我们写了天气预报的页面， 但是你作为天气预报肯定能选择城市吧。所以我们现在来写选择省、市、区的界面。</p>
<p>我们使用的是郭霖大神在第一行代码最后面酷欧天气的API。</p>
<span id="more"></span>
<h1 id="1-实现界面"><a href="#1-实现界面" class="headerlink" title="1. 实现界面"></a>1. 实现界面</h1><p>既然是一个选择省市区的界面，那么我们就用<code>ListView</code>。</p>
<p>首先看一下大致界面：<br><img src="https://cdn.littlecorgi.top/mweb/2019-10-14/Screenshot_1570967184.png" alt="Screenshot_1570967184"></p>
<p>就直接使用<code>ListView</code>的<code>builder()</code>方法，忘了的同学可以看前面第5章。</p>
<h2 id="省"><a href="#省" class="headerlink" title="省"></a>省</h2><p>在<code>view</code>文件夹下新建一个类<code>provinces_page.dart</code>，接下来就在这个文件里面写代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProvincesPageWidget</span> <span class="keyword">extends</span> <span class="title class_">StatefulWidget</span> &#123;</span><br><span class="line">    ProvincesPageWidget(&#123;Key key&#125;) : <span class="built_in">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    ProvincesPageStateWidget <span class="title function_">createState</span><span class="params">()</span> =&gt; <span class="keyword">new</span> <span class="title class_">ProvincesPageStateWidget</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProvincesPageStateWidget</span> <span class="keyword">extends</span> <span class="title class_">State</span>&lt;ProvincesPageWidget&gt; &#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    Widget <span class="title function_">build</span><span class="params">(BuildContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Scaffold(</span><br><span class="line">            appBar: <span class="keyword">new</span> <span class="title class_">AppBar</span>(</span><br><span class="line">                title: Text(</span><br><span class="line">                    <span class="string">&quot;省份&quot;</span>,</span><br><span class="line">                    style: TextStyle(fontSize: <span class="number">25.0</span>),</span><br><span class="line">                ),</span><br><span class="line">            ),</span><br><span class="line">            body: ListView.builder(</span><br><span class="line">                itemCount: <span class="number">30</span>,</span><br><span class="line">                itemBuilder: (context, index) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ListTile(</span><br><span class="line">                            title: Text(<span class="string">&quot;$index&quot;</span>),</span><br><span class="line">                    );</span><br><span class="line">                &#125;,</span><br><span class="line">            ),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="市"><a href="#市" class="headerlink" title="市"></a>市</h2><p>和省一样。在<code>view</code>文件夹下新建一个类<code>city_page.dart</code>，接下来就在这个文件里面写代码。照着省的依葫芦画瓢，写一个<code>ListView</code>。</p>
<h2 id="区"><a href="#区" class="headerlink" title="区"></a>区</h2><p>和省一样。在<code>view</code>文件夹下新建一个类<code>counties_page.dart</code>，接下来就在这个文件里面写代码。照着省的依葫芦画瓢，写一个<code>ListView</code>。</p>
<h1 id="2-网络请求"><a href="#2-网络请求" class="headerlink" title="2. 网络请求"></a>2. 网络请求</h1><p>网络请求可以看下之前第7章的内容。主要是通过<code>Dio</code>进行网络请求。大家可以看下第7章网络请求的内容。</p>
<p>我们网络请求主要需要以下几个API：</p>
<ul>
<li>请求省份列表：<code>http://guolin.tech/api/china</code></li>
<li>请求对应市列表：<code>http://guolin.tech/api/china/provinceID</code></li>
<li>请求对应区县列表：<code>http://guolin.tech/api/china/provinceID/cityID</code></li>
</ul>
<p>由于我们在之前文章中使用的省作为例子，这块我们就用区县作为例子：</p>
<h2 id="转为Dart类"><a href="#转为Dart类" class="headerlink" title="转为Dart类"></a>转为Dart类</h2><p>首先使用网站<a href="https://caijinglong.github.io/json2dart/">https://caijinglong.github.io/json2dart/</a>来讲Json数据转为Dart实体类：<br><img src="https://cdn.littlecorgi.top/mweb/2019-10-14/Json.png" alt="Json"></p>
<p>然后在项目<code>lib</code>目录新建一个文件夹。名为<code>bean</code>。这个文件夹主要存放实体类的代码。然后在这个文件夹下面新建一个dart文件，命名为<code>Counties</code>。然后把生成的Dart代码复制粘贴进去。但是你会发现复制进去后会报错，这个不用急，接下来我们来处理错误。</p>
<h2 id="生成-g-dart文件"><a href="#生成-g-dart文件" class="headerlink" title="生成.g.dart文件"></a>生成.g.dart文件</h2><p>接下来在项目根目录的<code>pubspec.yaml</code>文件的<code>dependencies</code>项下面添加依赖<code>json_annotation</code>、<code>dev_dependencies</code>项下面添加<code>build_runner</code>和<code>json_serializable</code>。</p>
<p>接着打开终端，定位到项目根目录，输入<br><code>flutter packages pub run build_runner build</code>，运行即可。运行完毕你就会发现你项目的存实体类的<code>lib/bean</code>目录多了一个文件，名为<code>Counties.g.dart</code>。同时你<code>Counties.dart</code>里面的错误也没有了。</p>
<h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><p>最后你就可以通过Dio来进行网络请求了。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Dio().get(http:<span class="comment">//guolin.tech/api/china/$_provinceID/$_cityID);</span></span><br></pre></td></tr></table></figure></p>
<p>那么到这有的同学可能就会问了，你网址里面有<code>provinceID</code>和<code>cityID</code>，那这两个怎么获取，这个时候就得用上带值路由跳转了。</p>
<p>我们一般都是这样的一个逻辑:先选择省份、再选择城市、最后选择区和县。所以我们这个<code>CountyPageWidget</code>肯定是由<code>CityPageWidget</code>调用的。那么我们可以在<code>CityPageWidget</code>的<code>ListView</code>里面将<code>Text</code>通过<code>GestureDetector</code>包起来，然后将<code>GestureDetector</code>的<code>onTap</code>方法设置为跳转到<code>CountyPageWidget</code>。<code>CityPageWidget</code>的<code>ListView</code>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListView.builder(</span><br><span class="line">    itemCount: _cityList.cities.length,</span><br><span class="line">    itemBuilder: (context, index) &#123;</span><br><span class="line">        <span class="keyword">return</span> GestureDetector(</span><br><span class="line">            child: ListTile(</span><br><span class="line">                title: Text(<span class="string">&quot;$&#123;_cityList.cities[index].name&#125;&quot;</span>),</span><br><span class="line">            ),</span><br><span class="line">            onTap: () &#123;</span><br><span class="line">                Navigator.push(context,</span><br><span class="line">                    MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">                        <span class="keyword">return</span> CountiesPageWidget(</span><br><span class="line">                            provinceID: _provinceID, <span class="comment">//由CityWidget的上一级ProvinceWidget传过来，</span></span><br><span class="line">                            cityID: _cityList.cities[index].id, <span class="comment">// 由网络请求回来的数据传入</span></span><br><span class="line">                        );</span><br><span class="line">                    &#125;));</span><br><span class="line">            &#125;,</span><br><span class="line">        );</span><br><span class="line">    &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>这样<code>CountyPageWidget</code>所需的<code>provinceID</code>和<code>cityID</code>都是由<code>CityPageWidget</code>传入的，那么我们怎么对他传入的值进行处理呢，怎么把它添加到网址里去？接下来大家看代码就行了：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CountyPageWidget</span> <span class="keyword">extends</span> <span class="title class_">StatefulWidget</span> &#123;</span><br><span class="line">  <span class="comment">//在Widget中定义两个，方便由其他Widget传入</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> provinceID;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> cityID;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置构造方法，在构造方法中传入两个变量</span></span><br><span class="line">  CountyPageWidget(&#123;Key key, <span class="built_in">this</span>.provinceID, <span class="built_in">this</span>.cityID&#125;) : <span class="built_in">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  CountyPageWidgetState <span class="title function_">createState</span><span class="params">()</span> =&gt; CountyPageWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountyPageWidgetState</span> <span class="keyword">extends</span> <span class="title class_">State</span>&lt;CountyPageWidget&gt; &#123;</span><br><span class="line">  <span class="comment">// 在State中定义两个变量</span></span><br><span class="line">  <span class="type">int</span> _provinceID;</span><br><span class="line">  <span class="type">int</span> _cityID;</span><br><span class="line">  List&lt;County&gt; _county;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">initState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 在此将Widget中的两个变量赋值给State中的变量</span></span><br><span class="line">    _provinceID = widget.provinceID;</span><br><span class="line">    _cityID = widget.cityID;</span><br><span class="line">    <span class="built_in">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget <span class="title function_">build</span><span class="params">(BuildContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: <span class="keyword">new</span> <span class="title class_">AppBar</span>(</span><br><span class="line">        title: Text(</span><br><span class="line">          <span class="string">&quot;区县&quot;</span>,</span><br><span class="line">          style: TextStyle(fontSize: <span class="number">25.0</span>),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      body: FutureBuilder( <span class="comment">// UI异步更新组件</span></span><br><span class="line">        <span class="comment">// 这块就可以调用了</span></span><br><span class="line">        future: Dio().get(<span class="string">&quot;http://guolin.tech/api/china/$_provinceID/$_cityID&quot;</span>),</span><br><span class="line">        builder: (BuildContext context, AsyncSnapshot snapshot) &#123;</span><br><span class="line">        ...省略后面所有代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="3-UI异步更新"><a href="#3-UI异步更新" class="headerlink" title="3. UI异步更新"></a>3. UI异步更新</h1><p>与异步更新相关的知识大家也可以看我们之前的第7章博客，这块只讲应用。</p>
<h2 id="省-1"><a href="#省-1" class="headerlink" title="省"></a>省</h2><p>将Scaffold的body参数设置为FutureBuilder，并在FutureBuilder里面调用ListView:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FutureBuilder(</span><br><span class="line">    future: Dio().get(<span class="string">&quot;http://guolin.tech/api/china&quot;</span>),</span><br><span class="line">    builder: (BuildContext context, AsyncSnapshot snapshot) &#123;</span><br><span class="line">        <span class="keyword">if</span> (snapshot.connectionState == ConnectionState.done) &#123;</span><br><span class="line">            <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> snapshot.data;</span><br><span class="line">            <span class="comment">//发生错误</span></span><br><span class="line">            <span class="keyword">if</span> (snapshot.hasError) &#123;</span><br><span class="line">                <span class="keyword">return</span> Text(snapshot.error.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            provinceList = getProvinceList(response.data);</span><br><span class="line">            <span class="comment">//请求成功，通过项目信息构建用于显示项目名称的ListView</span></span><br><span class="line">            <span class="keyword">return</span> ListView.builder(</span><br><span class="line">                itemCount: provinceList.length,</span><br><span class="line">                itemBuilder: (context, index) &#123;</span><br><span class="line">                    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">                        child: ListTile(</span><br><span class="line">                            title: Text(<span class="string">&quot;$&#123;provinceList[index].name&#125;&quot;</span>),</span><br><span class="line">                        ),</span><br><span class="line">                        onTap: () &#123;</span><br><span class="line">                            Navigator.push(context, MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">                                <span class="keyword">return</span> CityPageWidget(</span><br><span class="line">                                    provinceID: provinceList[index].id,</span><br><span class="line">                                );</span><br><span class="line">                            &#125;));</span><br><span class="line">                        &#125;,</span><br><span class="line">                    );</span><br><span class="line">                &#125;,</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 请求未完成时弹出loading</span></span><br><span class="line">        <span class="keyword">return</span> CircularProgressIndicator();</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h2 id="市-1"><a href="#市-1" class="headerlink" title="市"></a>市</h2><p>与省同理:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FutureBuilder(</span><br><span class="line">    future: Dio().get(<span class="string">&quot;http://guolin.tech/api/china/$_provinceID&quot;</span>),</span><br><span class="line">    builder: (BuildContext context, AsyncSnapshot snapshot) &#123;</span><br><span class="line">        <span class="keyword">if</span> (snapshot.connectionState == ConnectionState.done) &#123;</span><br><span class="line">            <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> snapshot.data;</span><br><span class="line">            <span class="comment">//发生错误</span></span><br><span class="line">            <span class="keyword">if</span> (snapshot.hasError) &#123;</span><br><span class="line">                <span class="keyword">return</span> Text(snapshot.error.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _cityList = getCityList(response.data);</span><br><span class="line">            <span class="comment">//请求成功，通过项目信息构建用于显示项目名称的ListView</span></span><br><span class="line">            <span class="keyword">return</span> ListView.builder(</span><br><span class="line">                itemCount: _cityList.length,</span><br><span class="line">                itemBuilder: (context, index) &#123;</span><br><span class="line">                    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">                        child: ListTile(</span><br><span class="line">                            title: Text(<span class="string">&quot;$&#123;_cityList[index].name&#125;&quot;</span>),</span><br><span class="line">                        ),</span><br><span class="line">                        onTap: () &#123;</span><br><span class="line">                            Navigator.push(context, MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">                                <span class="keyword">return</span> CountiesPageWidget(</span><br><span class="line">                                    provinceID: _provinceID,</span><br><span class="line">                                    cityID: _cityList[index].id,</span><br><span class="line">                                );</span><br><span class="line">                            &#125;));</span><br><span class="line">                        &#125;,</span><br><span class="line">                    );</span><br><span class="line">                &#125;,</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 请求未完成时弹出loading</span></span><br><span class="line">        <span class="keyword">return</span> CircularProgressIndicator();</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h2 id="区县"><a href="#区县" class="headerlink" title="区县"></a>区县</h2><p>与省同理:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FutureBuilder(</span><br><span class="line">    future: Dio().get(<span class="string">&quot;http://guolin.tech/api/china/$_provinceID/$_cityID&quot;</span>),</span><br><span class="line">    builder: (BuildContext context, AsyncSnapshot snapshot) &#123;</span><br><span class="line">        <span class="keyword">if</span> (snapshot.connectionState == ConnectionState.done) &#123;</span><br><span class="line">            <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> snapshot.data;</span><br><span class="line">            <span class="comment">//发生错误</span></span><br><span class="line">            <span class="keyword">if</span> (snapshot.hasError) &#123;</span><br><span class="line">                <span class="keyword">return</span> Text(snapshot.error.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _county = getCountyList(response.data);</span><br><span class="line">            <span class="comment">//请求成功，通过项目信息构建用于显示项目名称的ListView</span></span><br><span class="line">            <span class="keyword">return</span> ListView.builder(</span><br><span class="line">                itemCount: _county.length,</span><br><span class="line">                itemBuilder: (context, index) &#123;</span><br><span class="line">                    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">                        child: ListTile(</span><br><span class="line">                            title: Text(<span class="string">&quot;$&#123;_county[index].name&#125;&quot;</span>),</span><br><span class="line">                        ),</span><br><span class="line">                        onTap: () &#123;</span><br><span class="line">                            _saveCityID(_county[index].weatherId);</span><br><span class="line">                            Navigator.push(context, MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">                                <span class="keyword">return</span> MainPage(</span><br><span class="line">                                    cityID: _county[index].weatherId,</span><br><span class="line">                                );</span><br><span class="line">                            &#125;));</span><br><span class="line">                        &#125;,</span><br><span class="line">                    );</span><br><span class="line">                &#125;,</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 请求未完成时弹出loading</span></span><br><span class="line">        <span class="keyword">return</span> CircularProgressIndicator();</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Java锁机制</title>
    <url>/posts/d88880aa.html</url>
    <content><![CDATA[<h1 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h1><p>乐观锁和悲观锁都是一种广义上的概念。</p>
<p>对于同一个数据的并发操作，悲观锁确实很悲观，它时时刻刻都非常担心自己在读取或者写入数据的时候有其他线程来修改数据，所以为了安心，他一般就直接从读取数据的时候就加锁，确保自己操作的时候不会被其它线程打扰。最典型的悲观锁就是synchronized和Lock。</p>
<p>而乐观锁确实很乐观，它认为自己在操作数据的时候是不会有其他线程来修改数据的，所以丝毫不担心，完全不会添加锁。只是在更新数据的时候判断有没有其他线程更改了数据，如果这个数据没有被更新，当前线程再把自己的数据写入；如果数据已经更新，则根据不通过的实现方式执行不同的操作。</p>
<p>看到这，大家就懂了，乐观锁不就是缓存一致性以及CAS算法嘛。</p>
<p>那什么是CAS算法呢？</p>
<p>CAS，比较与交换，一中著名的无所算法。CAS的主要就设计到三个值：</p>
<ul>
<li>需要读写的内存值V</li>
<li>进行比较的值A</li>
<li>要写入的新值B</li>
</ul>
<p>当且仅当V的值等于A时，CAS通过原子操作去用新值B来更新V的值，否则不会执行操作。</p>
<p>但是CAS也有缺点：</p>
<ul>
<li>循环时间长开销大：如果一个线程已知都发现自己的值都不是A，那么他会已知自旋</li>
<li>只能保证一个共享变量的原子操作</li>
<li>ABA问题<ul>
<li>如果一个线程将数据从A改成了B又改成了A，这样虽然另一个线程通过CAS去更改数据的时候，他就只能发现变量值还是A没有发生变化，就断定这个数据没有其他线程更新过。</li>
</ul>
</li>
</ul>
<h1 id="自旋锁和适应性自旋锁"><a href="#自旋锁和适应性自旋锁" class="headerlink" title="自旋锁和适应性自旋锁"></a>自旋锁和适应性自旋锁</h1><p>在说自旋锁之前我们首先来想一个场景：<br>一般情况下，如果两个线程需要请求同一个资源，其中一个线程先于另一个线程得到资源，那么另一个线程就会阻塞，等到占用资源线程执行完毕释放资源并且CPU正在运行的这个线程运行完毕后重新把它调用上来，这时他才会去执行。</p>
<p>一般咱们都会通过这种方式去达到高效的多线程。但是如果你线程执行的代码很短，甚至需要执行的时间比你CPU调度线程所需的时间都要短，那么这样一直长时间切换短时间执行是不是很不划算。</p>
<p>但是现在电脑基本上都是多核CPU，同一时间各个CPU都可以处理各自的一个线程，我们就可以让后面那个线程先不放弃CPU的执行时间，看看持有资源的线程是否能很快就释放。</p>
<p>为了让当前线程稍等一下，我们就可以给他加个自旋锁，让他自旋，如果自旋完成时前面锁定了资源的线程释放了锁，那么当前线程就可以不避阻塞而是直接获取资源，避免切换线程的开销，这就是自旋锁。</p>
<p><img src="https://cdn.littlecorgi.top/mweb/2019-11-28/15748583404329.jpg" alt=""></p>
<p>但是自旋锁也有缺点，而且缺点很明显：如果前面那个占用资源的线程需要执行的时间很长，那么这个自旋的线程就会一直占着CPU，CPU就不能去执行其他线程，这样不尽效率没提上去，反而还下降了。</p>
<p>所以自旋锁一定得有限制，如果自旋的次数超过了一定的次数，就会让他取消自旋，挂起线程。</p>
<p>当然了，既然有静态的设置死的限制次数，肯定就有动态的设定灵活的限制次数。旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<h1 id="无锁、偏向锁、轻量级锁、重量级锁"><a href="#无锁、偏向锁、轻量级锁、重量级锁" class="headerlink" title="无锁、偏向锁、轻量级锁、重量级锁"></a>无锁、偏向锁、轻量级锁、重量级锁</h1><p>其实这几个锁都是对于synchronized来说的。再说这个之前，我们前来了解几个概念：</p>
<ul>
<li>Java对象头：以HotSpot为例，对象头分为两部分信息：Mark Word和类型指针<ul>
<li>Mark Word：这块主要用于存储对象自身运行时的数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁等信息。由于这些信息都是与对象自身定义的数据无关，所以考虑到虚拟机空间效率，Mark Word被设计成一个非固定的数据结构以便在绩效的空间内存储尽量多的信息，它会根据对象的状态复用自己的空间。</li>
<li>类型指针：即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这是哪个类的对象。</li>
</ul>
</li>
<li>Monitor：如果看过操作系统一定不会陌生，这个单词翻译过来就是大名鼎鼎的管程。Java为了保障线程的安全性，就提供了同步机制、互斥锁机制。而这个机制的保障就来自于监视锁Monitor，每个对象都拥有自己的监视锁。他的义务就是控制所有需要访问某个数据的线程，通过调度他们保证只有一个线程能访问受保护的数据和代码。</li>
</ul>
<p>现在回到synchronized，synchronized通过Monitor来实现线程同步，而Monitor则是依赖于底层的操作系统的MutexLock互斥锁来实现的。</p>
<p>我们在自旋锁中提到，阻塞或唤醒一个线程需要操作系统切换CPU来完成，这种状态的转换需要耗费大量的时间，如果此时加锁的代码过与简单，执行时间就可能比切换时间还要短。这种就是JDK1.6之前的synchronized实现方式，这种锁我们称为重量级锁。而为了减少加锁和释放锁所带来的大量资源的消耗，JDK1.6之后引入了偏向锁和轻量级锁。</p>
<p>这4中锁级别由低到高依次是：无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁<br>可以由低级升为高级，但是不能由高级降为低级。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">锁状态</th>
<th style="text-align:center">存储的内容</th>
<th style="text-align:center">存储内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">无锁</td>
<td style="text-align:center">对象的hashCode、对象分代年龄、是否是偏向锁(0)</td>
<td style="text-align:center">01</td>
</tr>
<tr>
<td style="text-align:center">偏向锁</td>
<td style="text-align:center">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁(1)</td>
<td style="text-align:center">01</td>
</tr>
<tr>
<td style="text-align:center">轻量级锁</td>
<td style="text-align:center">指向占中锁纪录的指针</td>
<td style="text-align:center">00</td>
</tr>
<tr>
<td style="text-align:center">重量级锁</td>
<td style="text-align:center">指向互斥量的指针</td>
<td style="text-align:center">10</td>
</tr>
</tbody>
</table>
</div>
<h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><p>无锁顾名思义，就是不加锁，不对资源进行锁定，任何线程都可以访问并修改，但是同一时刻只有一个线程能修改成功。</p>
<p>如果一个线程想要访问该资源时，发现该资源正在被访问，他就进行等待，直到资源没有被访问。这就是个循环，一直循环，知道能访问资源。而其他不能访问的线程也一直循环，知道能访问。</p>
<p>CAS就是无锁。</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>如果一段同步代码一直被同一个线程访问，那么这个线程就会自动加上偏向锁。</p>
<p>因为一直都被同一个线程访问，所以他不需要担心有其他线程和他竞争，又由于这段代码加了锁，所以就给他加上偏向锁，避免加更重量级的锁带来的资源消耗，提高效率。</p>
<p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>当锁是偏向锁但是被另外线程访问的时候，就会自动升级成轻量级锁，这时其它线程会通过自旋的方式来尝试获取锁，不会阻塞，从而提高性能。</p>
<p>指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>
<p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p>
<p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p>
<p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p>
<p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p>
<p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p>
<h1 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h1><p>公平锁就是很公平，按照多个线程的请求锁的顺序依次加入到请求队列中，依次排队。</p>
<p>而非公平锁就是提供了一个插队的机会，如果在一个线程想要去请求锁的时候，刚好这时候锁也没有线程占用，刚好可用，那就直接给这个线程去使用。</p>
<p>公平锁的好处就是等待锁的线程不会饿死，都会按照顺序一个个获取锁；但是缺点就是吞吐量较非公平锁来说较低，等待队列除了第一个可以拿到锁之外其他都得阻塞，直到第一个释放锁，CPU唤醒阻塞线程的开销比非公平锁大。</p>
<p>而非公平锁的好处就是吞吐量比公平锁大，有效减少唤起线程的开销（因为线程可以直接得到锁，不需要再加入到队列），整体吞吐量高；但是缺点是出现后申请的锁反而先拿到资源，而且可能会导致等待队列里面的线程一直拿不到锁，可能会饿死。</p>
<p>其实我觉得理解公平锁的最简单方法就是看图:</p>
<p>你可以看下面的例子，来自于<a href="https://tech.meituan.com/2018/11/15/java-lock.html">美团技术团队的博客</a>，或者是这个:<a href="https://www.jianshu.com/p/f584799f1c77">一张图读懂非公平锁与公平锁</a></p>
<p>公平锁和非公平锁可以形象化为一群人打水。</p>
<p>如图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。<br><img src="https://cdn.littlecorgi.top/mweb/2019-11-28/15749265754437.png" alt=""></p>
<p>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：<br><img src="https://cdn.littlecorgi.top/mweb/2019-11-28/15749266850342.png" alt=""></p>
<p>接下来我们通过ReentrantLock源码来讲一下公平锁和非公平锁在算法上的区别：<br><img src="https://cdn.littlecorgi.top/mweb/2019-11-28/15749283538129.jpg" alt=""></p>
<p>我们可以看到，ReentrantLock里面有一个内部类Sync，Symc继承自AbstractQueuedSynchronizer，添加锁和释放锁的大部分操作实际上都是在Sync中实现的。他有公平锁FairSync和非公平锁NonFairSync。</p>
<p>我们来看下公平锁FairSync和非公平锁NonFairSync的源码：(左边是非公平锁，右边是公平锁)<br><img src="https://cdn.littlecorgi.top/mweb/2019-11-28/15749285866543.jpg" alt=""></p>
<p>从源码中我们可以清楚地看到，两个代码唯一地区别在于第4行的那个if，公平锁较非公平锁多了一个限制条件：<code>!hasQueuedPredecessors()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断head和tail不相等（说明有等待线程）并且（head.next为null=&gt;说明有线程正在入队列的中间状态，肯定不是当前线程, 因为一个线程一个时间只能做一件事 或者 head.next.thread不是当前线程)</p>
<p>这个方法的作用就是判断当前线程是不是唯一锁队列的第一个。如果是返true，不是返回false。</p>
<h1 id="可重入锁和非可重入锁"><a href="#可重入锁和非可重入锁" class="headerlink" title="可重入锁和非可重入锁"></a>可重入锁和非可重入锁</h1><p>在讲这连个锁的概念前，我们先来看一个例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomethings</span><span class="params">()</span> &#123;</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doOthers</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，两个方法都是synchronized修饰的，<code>doSomethings()</code>中调用了<code>doOthers()</code>。</p>
<p>如果是非可重入锁的话，那么我们执行<code>doSomethings()</code>时，会给他加锁，然后去执行<code>doOthers()</code>，又由于执行<code>doOthers()</code>时也需要加锁，并且这个锁和<code>doSomethings()</code>时加的锁还不一样，所以线程必须把原来的锁给释放掉，但是<code>doSomethings()</code>还没执行完，他还不能释放掉锁，这个时候就会形成死锁。</p>
<p>但是如果是可重入锁的话，就能解决这个问题。可重入锁就能保证他在调用<code>doOthers()</code>的时候直接获取当前对象的锁，进入<code>doOthers()</code>进行操作。</p>
<p>这块还是引用<a href="https://tech.meituan.com/2018/11/15/java-lock.html">这篇博客</a>的图片：</p>
<p>还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。<br><img src="https://cdn.littlecorgi.top/mweb/2019-11-28/15749464893016.png" alt=""></p>
<p>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。<br><img src="https://cdn.littlecorgi.top/mweb/2019-11-28/15749464984252.png" alt=""></p>
<p>那下面我们来看下源码，看ReentrantLock的获取锁和释放锁的方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 获取锁，也是非公平锁的获取锁的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取State变量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 如果state变量为0，那么没有其他线程在执行同步方法，就将state置1，当前线程开始执行</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断当前线程是否是获取到锁的线程，如果是就进入if</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 让c的值加上acquires的值，代表可以再次获取锁</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 跟新state</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// state-1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 如果state-1为0，代表当前线程所有重复获取锁的操作都已经执行完毕，就真正的释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新state</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="独享锁和共享锁"><a href="#独享锁和共享锁" class="headerlink" title="独享锁和共享锁"></a>独享锁和共享锁</h1><p>独享锁也是排他锁，也就是说该锁一次只能被一个线程持有。如果线程对数据加上排他锁之后，其它线程就不能在对数据加任何的锁。获得排他锁的线程既能读数据也能写数据。</p>
<p>而共享锁则可被多个线程持有。当线程对数据加上共享锁之后，其它线程也能对该数据加锁，但是只能加共享锁，这时获得共享锁的线程只能读数据不能写数据。</p>
<p>在Java中，ReentrantLock是共享锁，ReentrantReadWriteLock是排他锁。</p>
<p>先来看ReentrantReadWriteLock：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLock</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ReadWriteLock</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6992448646407690164L</span>;</span><br><span class="line">    <span class="comment">/** Inner class providing readlock */</span></span><br><span class="line">    <span class="comment">// 读锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="comment">/** Inner class providing writelock */</span></span><br><span class="line">    <span class="comment">// 写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">    <span class="comment">/** Performs all synchronization mechanics */</span></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></figure><br>我们可以看到，在ReentranReadWriteLock中有两个锁：读锁ReaderLock和写锁WriterLock。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-------------------读锁-------------------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReadLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> &#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-------------------写锁-------------------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriteLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">4992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> &#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>他两都是通过内部的Sync实现的锁。但是读锁和写锁的加锁方式不一样，读锁是共享锁，写锁是独享所。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p>
<p>而且他两的state也很有特色，我们上面说过，state用于描述有多少个线程持有该锁。在独享锁中，这个线程通常是0或者1，而共享锁中就是持有锁的数量。但是ReentrantReadWriteLock中有两把锁，但是他们都通过同一个state来描述，所以这地方就需要有点特别的东西了。</p>
<p>ReentrantReadWriteLock将state分隔成了两部分，高16位代表读锁，低16位代表写锁：<br><img src="https://cdn.littlecorgi.top/mweb/2019-11-28/15749488946683.png" alt=""></p>
<p>接下来再来看加锁的代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Walkthrough: （Google机翻）</span></span><br><span class="line"><span class="comment">     * 1. 如果读取计数非零或写入计数非零并且所有者是另一个线程，则失败。</span></span><br><span class="line"><span class="comment">     * 2. 如果计数饱和，则失败。 </span></span><br><span class="line"><span class="comment">     *       (只有在count已经不为零时，才可能发生这种情况。)</span></span><br><span class="line"><span class="comment">     * 3. 否则，</span></span><br><span class="line"><span class="comment">     *       如果该线程是可重入获取或队列策略允许的话，则有资格进行锁定。 </span></span><br><span class="line"><span class="comment">     *       如果是这样，请更新状态并设置所有者。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取state</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 取写锁的个数w</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">    <span class="comment">// 如果已经有线程持有了锁</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="comment">// 如果w为0，也就是存在读锁，或者持有所的线程不是当前线程，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 如果写入锁的数量大于最大数就抛出一个Error</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li>这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</li>
<li>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</li>
<li>如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</li>
<li>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</li>
<li>如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！</li>
</ul>
</blockquote>
<p>tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p>
<p>因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取state</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 如果其他线程已经获取了写锁，则当前线程获取读锁失败。</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取读锁state</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);</span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>synchronized</tag>
        <tag>lock</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合源码之ArrayList</title>
    <url>/posts/970dc297.html</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ArrayList可以说是我们最常用的一种集合了。</p>
<p>他的本质是一个数组，一个<strong>可以自动扩容的动态数组</strong>，<strong>线程不安全</strong>，<strong>允许元素为null</strong>。</p>
<p>由于数组的内存连续，可以根据下标以O(1)的时间读写元素，因此时间效率很高。</p>
<h1 id="内部属性"><a href="#内部属性" class="headerlink" title="内部属性"></a>内部属性</h1><p>我们先来看下ArrayList里面有哪几个属性:</p>
<ul>
<li><p><code>private static final long serialVersionUID = 8683452581122892189L;</code><br>序列话UID。由于ArrayList实现了Serializable接口，为了序列化和反序列化的方便，我们就手动为他添加一个序列化UID。</p>
</li>
<li><p><code>private static final int DEFAULT_CAPACITY = 10;</code><br>默认的容量。</p>
</li>
<li><p><code>private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</code><br>空数组。</p>
</li>
<li><p><code>private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</code><br>默认的空数组。</p>
</li>
<li><p><code>transient Object[] elementData;</code><br>真正存放元素的数组。</p>
</li>
<li><p><code>private int size;</code><br>当前元素个数。</p>
</li>
</ul>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入参数为初始化容量时的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果传入参数大于零，那就创建一个对应大小的数组</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果传入参数等于0，那就直接把属性中创建好的空数组复制</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果传入参数小于0，那就抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入参数为空时的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 将属性中创建好的空数组复制过来</span></span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入参数为数组时的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">// 先转换为数组</span></span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="comment">// 因为size代表ArrayList中元素个数，所以要把数组的长度赋过来</span></span><br><span class="line">    <span class="comment">// 如果个数不为0进入此if</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//这里是当c.toArray出错，没有返回Object[]时，利用Arrays.copyOf 来复制集合c中的元素到elementData数组中</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果个数为0，那就把属性中的空数组复制过来</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><h3 id="ArrayList-add-E-e"><a href="#ArrayList-add-E-e" class="headerlink" title="ArrayList # add(E e)"></a>ArrayList # add(E e)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析4.1.1</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 将需要加入的元素加到最后面</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析4.1.1 ensureCapacityInternal()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// DEFAULTCAPACITY_EMPTY_ELEMENTDATA这个变量只有在通过无参构造的时候用到过</span></span><br><span class="line">    <span class="comment">// 也就是说，他判断创建出来的这个数组，到底是不是无参构造方法创建出来的，如果是就找出DEFAULT_CAPACITY和minCapacity中较大的那个</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">// 但是按道理来说，add一个元素minCapacity肯定为1，肯定小于DEFAULT_CAPACITY，为什么还要做一个判断呢？</span></span><br><span class="line">        <span class="comment">// 但是你得注意，还有AddAll这个方法</span></span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析4.1.2</span></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析4.1.2 ensureExplicitCapacity()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// modCount是AbstractList中的属性，如果需要扩容，则会修改modCount</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// -&gt;&gt; 分析4.1.3</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析4.1.3 grow()</span></span><br><span class="line"><span class="comment"> * 作用：扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 扩容为原数组的1.5倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果还不够，就直接用能容纳的最小大小</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8</span></span><br><span class="line">    <span class="comment">// 如果新数组比MAX_ARRAY_SIZE还要大的话</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// -&gt;&gt; 分析4.1.4</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually clos2019e to size, so this is a win:</span></span><br><span class="line">    <span class="comment">// 生成新数组</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析4.1.4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ArrayList-add-E-e-1"><a href="#ArrayList-add-E-e-1" class="headerlink" title="ArrayList # add(E e)"></a>ArrayList # add(E e)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按给定的位置添加指定元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果给的位置超过了集合已存放的元素的个数或者小于0，就抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析4.1.1</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 将elementData从index处分开，给index空出位置</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    <span class="comment">// 放入数据</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ArrayList-addAll-Collection-lt-extends-E-gt-c"><a href="#ArrayList-addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="ArrayList # addAll(Collection&lt;? extends E&gt; c)"></a>ArrayList # addAll(Collection&lt;? extends E&gt; c)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">// 转为数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="comment">// 扩容数组 -&gt;&gt; 分析4.1.1</span></span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    <span class="comment">// 将a数组的全部内容添加到elementData数组从size开始之后</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ArrayList-addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#ArrayList-addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="ArrayList # addAll(int index, Collection&lt;? extends E&gt; c)"></a>ArrayList # addAll(int index, Collection&lt;? extends E&gt; c)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转为数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="comment">// 扩容 -&gt;&gt; 分析4.1.1</span></span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index;</span><br><span class="line">    <span class="comment">// 如果index小于size，也就是说需要在原数组的中间插入的haul，就需要先把原数组index之后的数据往后移动</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>无论是add还是addAll，都是先判断是否越界，如果越界就扩容，然后再移动数组</li>
<li>如果需要扩容，默认扩容原来的一般大小；如果还不够，那就直接将目标的size作为扩容后的大小</li>
<li>在扩容成功后，会修改modCount</li>
</ul>
<h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><h3 id="ArrayList-remove-int-index"><a href="#ArrayList-remove-int-index" class="headerlink" title="ArrayList # remove(int index)"></a>ArrayList # remove(int index)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    <span class="comment">// 修改modCount</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 将要删除的内容先保存下来</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> (E) elementData[index];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 判断要删除的数据是不是最后一位</span></span><br><span class="line">    <span class="comment">// 如果不是最后一位，还得先把后面的数据往前移动</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 清除数据，更改引用，让GC去清理</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ArrayList-remove-Object-o"><a href="#ArrayList-remove-Object-o" class="headerlink" title="ArrayList # remove(Object o)"></a>ArrayList # remove(Object o)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// -&gt;&gt; 分析4.2.1</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果参数不为空，那就遍历整个数组集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="comment">// 找到和参数相等的那一位，然后将该位移除</span></span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                <span class="comment">// -&gt;&gt; 分析4.2.1</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 分析4.2.1：fastRemove()</span></span><br><span class="line"><span class="comment"> * 作用：基本上和remove(int index)一样</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 修改modCount</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 判断要删除的数据是不是最后一位</span></span><br><span class="line">    <span class="comment">// 如果不是最后一位，还得先把后面的数据往前移动</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 清除数据，更改引用，让GC去清理</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ArrayList-removeAll-Collection-lt-gt-c"><a href="#ArrayList-removeAll-Collection-lt-gt-c" class="headerlink" title="ArrayList # removeAll(Collection&lt;?&gt; c)"></a>ArrayList # removeAll(Collection&lt;?&gt; c)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析4.2.2</span></span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 分析4.2.2 batchRemove()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="type">boolean</span> complement)</span> &#123;</span><br><span class="line">    <span class="comment">// 先赋值</span></span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="built_in">this</span>.elementData;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">modified</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 快速保存两个集合共有元素</span></span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">        <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            <span class="comment">// 如果出现异常会导致r!=size，就把异常之后的数据全部覆盖到数组里面</span></span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="comment">// clear to let GC do its work</span></span><br><span class="line">            <span class="comment">// 将后面的元素全部置空，让GC来回收</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="literal">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这块我看的时候有点绕，但是一想通就好了。</p>
<p>其实这个地方是要把C集合中和原集合中共有的元素删除，那我就只需要遍历原数组，然后碰到和C集合相同的元素就直接放到前面去，然后等遍历完成后，一次性把后面的全部置空。</p>
<h3 id="ArrayList-retainAll-Collection-lt-gt-c"><a href="#ArrayList-retainAll-Collection-lt-gt-c" class="headerlink" title="ArrayList # retainAll(Collection&lt;?&gt; c)"></a>ArrayList # retainAll(Collection&lt;?&gt; c)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析4.2.2</span></span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ArrayList-clear"><a href="#ArrayList-clear" class="headerlink" title="ArrayList # clear()"></a>ArrayList # clear()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="comment">// 直接遍历每一位，然后把每一位都置空，让GC去清理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>所有的删除操作都会修改modCount</li>
</ul>
<h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出原来的元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> (E) elementData[index];</span><br><span class="line">    <span class="comment">// 把需要更改的数据放进去</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没啥好分析的</p>
<p>不需要修改modCount，相对高效</p>
<h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没啥好分析的</p>
<p>不需要修改modCount，相对高效</p>
<h2 id="包括-contains-amp-indexOf"><a href="#包括-contains-amp-indexOf" class="headerlink" title="包括 contains() &amp; indexOf()"></a>包括 contains() &amp; indexOf()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析4.5.1</span></span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析4.5.1：indexOf()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没啥好分析的</p>
<h2 id="判空-isEmpty"><a href="#判空-isEmpty" class="headerlink" title="判空 isEmpty()"></a>判空 isEmpty()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没啥好分析的</p>
<h1 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器 Iterator"></a>迭代器 Iterator</h1><h2 id="创建迭代器"><a href="#创建迭代器" class="headerlink" title="创建迭代器"></a>创建迭代器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 构造Itr对象并返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Itr属性"><a href="#Itr属性" class="headerlink" title="Itr属性"></a>Itr属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 限制，也就是数组的元素个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> ArrayList.<span class="built_in">this</span>.size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下一个元素的下标</span></span><br><span class="line"><span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line"><span class="comment">// 上一次返回元素的下标</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line"><span class="comment">// 用于判断集合是否修改过结构的标志</span></span><br><span class="line"><span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br></pre></td></tr></table></figure>
<h2 id="Itr-hasNext"><a href="#Itr-hasNext" class="headerlink" title="Itr # hasNext()"></a>Itr # hasNext()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cursor &lt; limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不用多说</p>
<h2 id="Itr-next"><a href="#Itr-next" class="headerlink" title="Itr # next()"></a>Itr # next()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否修改过List的结构，如果修改了就抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">    <span class="comment">// 如果越界了就抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">    <span class="comment">// 再次判断是否越界，在 我们这里的操作时，有异步线程修改了List</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    <span class="comment">// 标记加1</span></span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 返回数据，并设置上一次的下标</span></span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Itr-remove"><a href="#Itr-remove" class="headerlink" title="Itr # remove()"></a>Itr # remove()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用ArrayList的remove方法移除数据</span></span><br><span class="line">        ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">        <span class="comment">// 更新一系列数据</span></span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        limit--;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h1><h2 id="modCount到底是个什么东西？"><a href="#modCount到底是个什么东西？" class="headerlink" title="modCount到底是个什么东西？"></a>modCount到底是个什么东西？</h2><p>如果你看过很多集合源码的话，你就会发现你会在很多地方都会碰到这个modCount，例如ArrayList、LinkedList、HashMap等等。modCount字面意思就是修改次数，那么为什么需要纪录这个修改次数呢？</p>
<p>你回想下，似乎用到modCount的地方，如ArrayList、LinkedList等等，他们都用一个共性——线程不安全。</p>
<p>而在你看了这几个类的迭代器后就会发现，他们迭代器中一定有一个属性(如我们上面的expectedModCount)初始化时的值就是modCount的值。</p>
<p>然后在迭代器的方法中，只要是遍历这个集合的时候，都需要将两个值进行对比，然后再移除元素的时候，都需要更新迭代器里面的modCount变量。</p>
<p>这时，你需要了解下<strong>Fail-Fast机制</strong>。</p>
<p>我们都知道这些集合是线程不安全的，如果在使用迭代器的过程中，有其他线程对集合进行了修改，那么就会抛出ConcurrentModificationException异常，这就是Fail-Fast策略。而这个时候源码中就通过modCount进行了操作。迭代器在创建时，会创建一个变量等于当时的modCount，如果在迭代过程中，集合发生了变化，modCount就是++。这时迭代器中的变量的值和modCount不相等了，那就抛异常。</p>
<p>所以，<strong>遍历线程不安全的集合时，尽量使用迭代器</strong></p>
<p>解决办法：</p>
<ul>
<li>在遍历过程中所有涉及到改变 modCount 值得地方全部加上 synchronized 或者直接使用 Collections.synchronizedList，这样就可以解决。但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。</li>
<li>使用 CopyOnWriteArrayList 来替换 ArrayList。推荐使用该方案。关于CopyOnWriteArrayList的内容此处不再过多的去将，想了解的同学可以百度或者谷歌。</li>
</ul>
<h2 id="ArrayList和Vector的区别"><a href="#ArrayList和Vector的区别" class="headerlink" title="ArrayList和Vector的区别"></a>ArrayList和Vector的区别</h2><ul>
<li>ArrayList线程不安全，Vector线程安全</li>
<li>扩容的时候ArrayList默认扩容1.5倍，Vector默认扩容1倍</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
        <tag>集合</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack入门 之 LiveData的map()和switchMap</title>
    <url>/posts/b1488352.html</url>
    <content><![CDATA[<h1 id="LiveData的map-和switchMap"><a href="#LiveData的map-和switchMap" class="headerlink" title="LiveData的map()和switchMap"></a>LiveData的map()和switchMap</h1><h1 id="官方文档中的介绍"><a href="#官方文档中的介绍" class="headerlink" title="官方文档中的介绍"></a>官方文档中的介绍</h1><p>在Android Developer官网上，对于map和switchMap的解释是这样的：</p>
<ul>
<li>map：</li>
</ul>
<blockquote>
<p>Applies a function on the value stored in the LiveData object, and propagates the result downstream.</p>
</blockquote>
<p>对存储在 LiveData 对象中的值应用函数，并将结果传播到下游。</p>
<ul>
<li>switchMap：</li>
</ul>
<blockquote>
<p>applies a function to the value stored in the LiveData object and unwraps and dispatches the result downstream. <strong>The function passed to switchMap() must return a LiveData object, as illustrated by the following example:</strong></p>
</blockquote>
<p>对存储在 LiveData 对象中的值应用函数，并将结果解封和分派到下游。<strong>传递给 switchMap() 的函数必须返回 LiveData 对象。</strong></p>
<span id="more"></span>
<p>其实单纯的看上面两个官方文档反而还会觉得更加的莫名其妙。其实这两句话差异的核心在于 <strong>“解封”</strong> 和 <strong>“返回LiveData对象”</strong> 。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>我们先来举个栗子来说明下这两个方法的区别(例子来源于<a href="https://medium.com/@elye.project/understanding-live-data-made-simple-a820fcd7b4d0">此文章</a>)：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TransformationMapFragment</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> changeObserver = Observer&lt;String&gt; &#123; value -&gt;</span><br><span class="line">        value?.let &#123; txt_fragment.text = it &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAttach</span><span class="params">(context: <span class="type">Context</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttach(context)</span><br><span class="line">        <span class="keyword">val</span> transformedLiveData = Transformations.map(</span><br><span class="line">                getLiveDataA()) &#123; <span class="string">&quot;A:<span class="variable">$it</span>&quot;</span> &#125;</span><br><span class="line">        transformedLiveData.observe(<span class="keyword">this</span>, changeObserver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到运行结果是这样的：</p>
<p><img src="https://cdn.littlecorgi.top/mweb/2020-06-24/1_6cTWqtHlJgnzF701QFtZQg.gif" alt="1_6cTWqtHlJgnzF701QFtZQg"></p>
<p>结合代码运行结果以及上面文档中对map函数的定义，我们可以得出下面这个结论：map函数主要的功能就是根据原LiveData，对其原LiveData的值进行改变然后生成一个新的LiveData。<strong>基于原LiveData</strong>。</p>
<p>而switchMap，同样的，我们也来看一个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TransformationSwitchMapFragment</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> changeObserver = Observer&lt;String&gt; &#123; value -&gt;</span><br><span class="line">        value?.let &#123; txt_fragment.text = it &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAttach</span><span class="params">(context: <span class="type">Context</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttach(context)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> transformSwitchedLiveData =</span><br><span class="line">            Transformations.switchMap(getLiveDataSwitch()) &#123; </span><br><span class="line">                switchToB -&gt;</span><br><span class="line">                <span class="keyword">if</span> (switchToB) &#123;</span><br><span class="line">                     getLiveDataB()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     getLiveDataA()</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transformSwitchedLiveData.observe(<span class="keyword">this</span>, changeObserver)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// .. some other Fragment specific code ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到运行结果是这样的：</p>
<p><img src="https://cdn.littlecorgi.top/mweb/2020-06-24/1_9RDrsXCBQhZmmc8XMQWw6Q.gif" alt="1_9RDrsXCBQhZmmc8XMQWw6Q"></p>
<p>同样的结合这个例子和上面的文档描述，我们也可以得出一个结论：switchMap是根据传入的LiveData的值，然后判断这个值，然后再去切换或者构建新的LiveData。<strong>手动生成新的LiveData</strong>。</p>
<h1 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h1><p>所以对于这两个函数的区别来说，map，更关注于数值的转换，也就是说，他只会通过你之前的值去生成一个新的值，强调的是这个<strong>转换</strong>，也就是说新的LiveData对象的值，仍然是基于当前这个LiveData的值而生成的。</p>
<p>而switchMap，更关注于数值的<strong>触发</strong>，也就是说，他会监听你这个值的变化，而不关注你这个值本身，你可以理解成触发器或者扳机，当触发之后，你就需要自己去主动的返回任意一个你指定的liveData对象。</p>
<p>所以我们再回过头来看一下上面说的 <strong>“解封”</strong> 和 <strong>“返回LiveData对象” ：</strong></p>
<p>对于这个，我觉得应该相对的来看，对于map来说，他把值从LiveData中读取了出来，但是他只是在原值的基础上进行操作生成新的LiveData对象，新的LiveData对象的值是基于旧的LiveData对象的，也就是说没有完全的将值独立出来；而对于switchMap，它不仅仅将值从LiveData中取出来了，并且取出来之后，对于新的LiveData来说，他并没有要求新的LiveData的值必须得基于旧的LiveData咋样，而是只是单纯的作为一个触发器，你返回的新的LiveData对象中存储的值，与旧的LiveData对象的值有没有关系，他并不在意。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以，总结一下。</p>
<p>map强调的是，<strong>新的LiveData的值必须基于旧的LiveData中的值</strong>(比方说像上面的例子，取出旧的LiveData的每个值然后加上相同的String从而生成新的LiveData)。</p>
<p>而switchMap，他并不在意这些，他在意的是他会<strong>将旧的LiveData的值作为一个触发，作为一个switch</strong>，他不管你你到底是利用这个switch做判断返回不用的值(像上面的例子)，还是你利用这个值去网络请求生成新的值(比方说旧的LiveData存了用户名，而你根据这个用户名去请求用户的具体信息作为新的LiveData返回)也好，只要你<strong>手动返回了一个新的LiveData</strong>就行。</p>
<h1 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h1><ul>
<li><a href="https://medium.com/@elye.project/understanding-live-data-made-simple-a820fcd7b4d0">Understanding LiveData made simple - Elye - Medium</a></li>
<li><a href="https://stackoverflow.com/a/47690327/13753159">What is the difference between map() and switchMap() methods? - stack overflow</a></li>
<li><a href="https://developer.android.google.cn/topic/libraries/architecture/livedata#transform_livedata">LiveData 概览 # 转换 LiveData - Android Developer</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
        <tag>LiveData</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合源码之HashMap</title>
    <url>/posts/2982320f.html</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>HashMap是一个哈希表，线程不安全，<code>key</code>唯一，<code>value</code>可重复，允许<code>key</code>和<code>value</code>为null。遍历时是无序的。</p>
<p>底层结构是基于链表散列，也就是数组+链表。数组也被称为哈希桶，桶里面就装着链表，链表中的每个节点，就是哈希表中的每个元素。</p>
<p>在JDK8中，当链表长度达到8的时候，就会转为红黑树。</p>
<p>它实现了<code>Map&lt;K, V&gt;, Cloneable, Serializable</code>接口。</p>
<p>接下来我们就来看下源码：</p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 序列化ID，用于序列化和反序列化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认初始容量也就是16-必须为2的幂。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大容量。</span></span><br><span class="line"><span class="comment">// 如果两个构造函数都使用参数隐式指定了更高的值，则使用该容量。 </span></span><br><span class="line"><span class="comment">// 必须是2的30次方。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entry数组，也就是哈希桶，长度为2的n次幂</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存缓存的entrySet()。 注意，AbstractMap字段用于keySet（）和values（）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含的键-值对的数，也就是元素的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个与fast-fail有关，可以参考我上一篇将ArrayList部分博客的modCount变量。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前 HashMap 所能容纳键值对数量的最大值，超过这个值，则需扩容</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>
<p>这些可能现在看起来还很迷，可能都不知道有些变量到底是拿来干嘛的。不急，我们继续往后面看。</p>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个指定初始容量和构造因子的HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果指定的初始容量小于0，抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">// 如果指定的初始容量大于设定好的最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        <span class="comment">// 就直接把初始容量设置为最大容量</span></span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;    <span class="comment">// 如果负载因子小于0或者为空，抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析3.1</span></span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个具有指定容量和默认负载因子的HashMap。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用了上面那个构造方法</span></span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 直接加载默认负载因子</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Map里面的值传入HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="comment">//  使用默认的加载因子</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    <span class="comment">// 分析3.2</span></span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分析3-1-HashMap-tableSizeFor-int-cap"><a href="#分析3-1-HashMap-tableSizeFor-int-cap" class="headerlink" title="分析3.1 HashMap # tableSizeFor(int cap)"></a>分析3.1 HashMap # tableSizeFor(int cap)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// &gt;&gt;&gt; 无符号右移</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有点纠结，你光看代码确实看不出来个啥，但是如果你在纸上顺便找几个例子写写就懂了。</p>
<p>他的用途，总结起来就是：<strong>找到大于或等于cap的最小2的幂</strong>。</p>
<p>这里借用一下<a href="http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/">一位大佬的图</a>：<br><img src="https://image-static.segmentfault.com/327/110/3271107614-5a65971be833a" alt=""></p>
<p>这个图就是第一个例子。cap=536870913，经过运算之后，n+1=1073741824。</p>
<h2 id="分析3-2-HashMap-putMapEntries-Map-lt-extends-K-extends-V-gt-m-boolean-evict"><a href="#分析3-2-HashMap-putMapEntries-Map-lt-extends-K-extends-V-gt-m-boolean-evict" class="headerlink" title="分析3.2 HashMap # putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)"></a>分析3.2 HashMap # putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// 先拿到map的大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="comment">// 如果map大于0才去进行操作，如果等于0那就证明Map是空的，就不进行操作</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前哈希表还是空的</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 根据m的元素数量和当前表的加载因子，计算出阈值</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="comment">// 修正阈值的边界 不能超过MAXIMUM_CAPACITY</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 如果新的阈值大于当前阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                <span class="comment">// 返回一个新的阈值的 满足2的n次方的阈值</span></span><br><span class="line">                <span class="comment">// -&gt;&gt; 分析3.1</span></span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前哈希表不是空的，而且map中元素个数大于当前的阈值，那就重新扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            <span class="comment">// 扩容</span></span><br><span class="line">            <span class="comment">// -&gt;&gt; 分析3.3</span></span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 遍历Map，取出map每一个键值对并复制给HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            <span class="comment">// 将取出Key和Value放入HashMap</span></span><br><span class="line">            <span class="comment">// -&gt;&gt; 分析3.4</span></span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分析3-3-HashMap-resize"><a href="#分析3-3-HashMap-resize" class="headerlink" title="分析3.3 HashMap # resize()"></a>分析3.3 HashMap # resize()</h2><p><strong>重点！！！</strong></p>
<p>扩容函数。</p>
<p>先来看源码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 旧数组也就是旧哈希桶的容量，如果oldTab为空就为0，否则为oldTab长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 旧的阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果旧哈希桶容量大于0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果旧哈希桶容量大于限定的最大值</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 阈值就设置为int的最大值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则新的容量是旧的容量的两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                <span class="comment">// 旧的容量为默认初始化容量也就是16</span></span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 新的阈值也等于旧的阈值</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前表是空的，但是有阈值。代表是初始化时指定了容量、阈值的情况</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 直接把新的容量的值设置为旧的阈值</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 如果当前表是空的，而且也没有阈值。代表是初始化时没有任何容量/阈值参数的情况</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 新容量为默认的初始容量</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// 新的阈值默认为默认负载因子 * 默认初始容量 = 16 * 0.7 = 12</span></span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新的阈值是0，对应的是  当前表是空的，但是有阈值的情况</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据新表容量 和 加载因子 求出新的阈值</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新阈值 </span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">// 创建新的哈希桶</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    <span class="comment">// 更新引用</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 如果以前的哈希桶中还有元素，那就把原来的数组复制过来</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历以前的哈希桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 如果当前节点不为空</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 把旧哈希桶中的该位置为空，方便GC回收</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 如果该节点的后一位为空了，也就是说哈希桶里面的链表只有一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">//直接将这个元素放置在新的哈希桶里。</span></span><br><span class="line">                    <span class="comment">//注意这里取下标 是用 哈希值 与 桶的长度-1 。 由于桶的长度是2的n次方，这么做其实是等于 一个模运算。但是效率更高</span></span><br><span class="line">                    <span class="comment">// 具体会在文章最后面讲</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果发生过哈希碰撞 ,而且是节点数超过8个，转化成了红黑树（暂且不谈 避免过于复杂， 后续专门研究一下红黑树）</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// 如果发生过哈希碰撞，节点数小于8个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置。</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 由于现在容量加倍了，按照哈希表的算法，之前在这个哈希桶里面的现在不一定属于该哈希桶了</span></span><br><span class="line">                    <span class="comment">// 比如，之前哈希长度是4，有一个元素为5</span></span><br><span class="line">                    <span class="comment">// 未扩容前，他应该在5%4=1这个桶里面</span></span><br><span class="line">                    <span class="comment">// 但是现在扩容了，哈希长度变成了8，那么他现在就应该在5%8=5这个桶里面了</span></span><br><span class="line">                    <span class="comment">// 而且新桶的位置就是老位置1加上oldCap4，也就是j + oldCap = 1 + 4 = 5</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 代表扩容后还应该在老桶里面的元素</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// 代表扩容后应该在新桶里面的元素</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 这里又是一个利用位运算 代替常规运算的高效点： 利用哈希值 与 旧的容量，可以得到哈希值去模后，是大于等于oldCap还是小于oldCap，等于0代表小于oldCap，应该存放在低位，否则存放在高位                    </span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 以下均为简单的单链表操作</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 以下均为简单的单链表操作</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 遍历两个链表，把lo放到原来的位置上，并把hi放入新位置也就是j+oldCap</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结来说就是:</p>
<ul>
<li>扩容<ul>
<li>如果之前的哈希表有值，而且元素的个数大于限定的哈希表最大容量的话，那就把新的哈希表的阈值设置为Integer.MAX_VALUE也就是int的最大值，并直接返回旧和哈希表</li>
<li>如果之前的哈希表有值，而且元素个数没有大于哈希表最大容量，而且个数的两倍还小于限定的哈希表最大容量、元素个数大于默认的初始容量也就是16的话，就设置新的阈值为旧的阈值的2倍</li>
<li>如果之前的哈希表的空的，但是阈值是存在值的，也就相当于你初始化时指定了容量和阈值然后构造的哈希表，此时就直接让新的容量指定为旧的阈值</li>
<li>如果之前哈希表是空的，阈值也不大于0，也就相当于采用了无参构造，这时就直接让新容量为默认的初始容量也就是16，让新的阈值为默认负载因子<em>默认初始容量 = 16 </em> 0.7 = 12</li>
<li>如果新的阈值是0的话，也就是在之前的4个判断中没有对新的阈值进行更改的情况，也就是之前的哈希表是空的，然后指定了阈值的情况，这是就根据新表的容量和负载因子求出新的阈值</li>
</ul>
</li>
<li>复制到新表<ul>
<li>如果以前的哈希表中有元素，就直接遍历原表，然后判断当前哈希桶里面有没有元素</li>
<li>如果有而且他的下一个为空，就代表这个链表只有一个节点，那就直接求出他的哈希值，然后给对应的哈希桶</li>
<li>如果他下一个不为空而且他是红黑树的实例，那就调用split方法</li>
<li>如果他下一个不为空，也不是红黑树的实例，那就开始遍历链表，判断当前及节点新的哈希值，如果还是当前值，那就放到lo链表上去，如果不是当前值，那就放到hi链表</li>
<li>然后遍历完成后，直接把lo链表放到当前哈希桶，把hi放到当前哈希值+旧的哈希数组长度也就是新的哈希值对应的哈希桶上去</li>
</ul>
</li>
</ul>
<h2 id="分析3-4-HashMap-putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict"><a href="#分析3-4-HashMap-putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict" class="headerlink" title="分析3.4 HashMap # putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)"></a>分析3.4 HashMap # putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果哈希表是空的的话，代表是初始化的</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 那就直接扩容哈希表，并且将扩容后的哈希桶长度赋值给n</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果当前index的节点是空的，表示没有发生哈希碰撞。 直接构建一个新节点Node，挂载在index处即可。</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 发生哈希碰撞</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果哈希值相等、key也相等，那就直接覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果是红黑树的实例，暂时不讨论</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 如果以上情况都不满足，也就代表不是红黑树，但是该链表不止一个节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对链表进行遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 放入链表最后面</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 如果当前链表节点个数大于8</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">// 转为红黑树</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果找到了要覆盖的节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果e不为null，也就是说找到了需要覆盖的节点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// 如果onlyIfAbsent为false，或者oldValue不存在才进入if</span></span><br><span class="line">            <span class="comment">// onlyIfAvsent这个变量的意思是如果为true，则此key对应的节点有value的情况，否则是没有value的情况，此变量用于putIfAbsent方法</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 这是一个空实现的函数，用作LinkedHashMap重写使用</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于节点插入成功，或者覆盖成功，所以需要修改modCount通知HashMap结构发生变化</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 更新size，如果size达到了阈值，那就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 这是一个空实现的函数，用作LinkedHashMap重写使用</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h2 id="增、改"><a href="#增、改" class="headerlink" title="增、改"></a>增、改</h2><h3 id="HashMap-put-K-key-V-value"><a href="#HashMap-put-K-key-V-value" class="headerlink" title="HashMap # put(K key, V value)"></a>HashMap # put(K key, V value)</h3><p>功能：</p>
<ul>
<li>如果原来的表里面没有key对应的节点，就把key和value插入</li>
<li>如果有对应的节点，就把将key对应节点的value更改为传入的value</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// -&gt;&gt; 见分析3.4</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashMap-putAll-Map-lt-extends-K-extends-V-gt-m"><a href="#HashMap-putAll-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="HashMap # putAll(Map&lt;? extends K, ? extends V&gt; m)"></a>HashMap # putAll(Map&lt;? extends K, ? extends V&gt; m)</h3><p>功能：</p>
<ul>
<li>直接把Map里面的内容传入HashMap</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析3.2</span></span><br><span class="line">    putMapEntries(m, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashMap-putIfAbsent-K-key-V-value"><a href="#HashMap-putIfAbsent-K-key-V-value" class="headerlink" title="HashMap # putIfAbsent(K key, V value)"></a>HashMap # putIfAbsent(K key, V value)</h3><p>功能：</p>
<ul>
<li>根据key找到对应节点</li>
<li>如果该节点已经有value，就返回此value</li>
<li>否则就将此value插入，并返回null</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析3.4</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashMap-replace-K-key-V-oldValue-V-newValue"><a href="#HashMap-replace-K-key-V-oldValue-V-newValue" class="headerlink" title="HashMap # replace(K key, V oldValue, V newValue)"></a>HashMap # replace(K key, V oldValue, V newValue)</h3><p>功能：</p>
<ul>
<li>根据key和value找到对应节点，然后把旧值用newValue替换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">replace</span><span class="params">(K key, V oldValue, V newValue)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; V v;</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析4.3.1</span></span><br><span class="line">    <span class="comment">// 根据key找到对应的节点，并判断节点为不为空，以及此时的value的值等不等于传入的oldValue</span></span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        ((v = e.value) == oldValue || (v != <span class="literal">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">        <span class="comment">// 替换为新值</span></span><br><span class="line">        e.value = newValue;</span><br><span class="line">        <span class="comment">// 这是一个空实现的函数，用作LinkedHashMap重写使用</span></span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashMap-replace-K-key-V-value"><a href="#HashMap-replace-K-key-V-value" class="headerlink" title="HashMap # replace(K key, V value)"></a>HashMap # replace(K key, V value)</h3><p>功能：</p>
<ul>
<li>根据key找到对应的节点，然后直接把value替换过去</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">replace</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析4.3.1</span></span><br><span class="line">    <span class="comment">// 找到对应的节点，并判断为不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 取出之前的值</span></span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">        <span class="comment">// 替换为新的值</span></span><br><span class="line">        e.value = value;</span><br><span class="line">        <span class="comment">// 这是一个空实现的函数，用作LinkedHashMap重写使用</span></span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="comment">// 把旧值返回</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><h3 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove(Object key)"></a>remove(Object key)</h3><p>功能：</p>
<ul>
<li>根据key找到节点并删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析4.2.1</span></span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="remove-Object-key-Object-value"><a href="#remove-Object-key-Object-value" class="headerlink" title="remove(Object key, Object value)"></a>remove(Object key, Object value)</h3><p>功能：</p>
<ul>
<li>根据key和value找到对应节点，然后删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析4.2.1</span></span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析4-2-1-HashMap-removeNode-int-hash-Object-key-Object-value-boolean-matchValue-boolean-movable"><a href="#分析4-2-1-HashMap-removeNode-int-hash-Object-key-Object-value-boolean-matchValue-boolean-movable" class="headerlink" title="分析4.2.1 HashMap # removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable)"></a>分析4.2.1 HashMap # removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析4.2.1：HashMap.removeNode()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">// 如果哈希桶不为空并且哈希桶的长度大于0并且key对应的哈希桶不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 如果链表第一个节点就是要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 直接赋值给node</span></span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">// 否则的话，看下一位是否为空，如果不为空，那就证明此处有链表或者红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 不是红黑树，就代表只是链表，而且链表长度不超过8</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 遍历找到对应的节点，然后赋值给node</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到了节点并且要么matchValue为false，要么node的value得和传入的value相等</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 红黑树，不管</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">// 如果node==p也就是该哈希桶里面第一个节点就是我们需要找的</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                <span class="comment">// 操作</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="comment">// 上面if不成立也就代表着要找的节点不是哈希桶里面的第一个节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 操作</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            <span class="comment">// 由于我们改变了哈希表的结构，所以需要更新modCount</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">// 更新size</span></span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">// 这是一个空实现的函数，用作LinkedHashMap重写使用</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在对应哈希桶里面找不到对应的节点，就返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><h3 id="HashMap-get-Object-key"><a href="#HashMap-get-Object-key" class="headerlink" title="HashMap # get(Object key)"></a>HashMap # get(Object key)</h3><p>功能：</p>
<ul>
<li>根据key找到对应节点，并返回节点的value。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析4.4.1</span></span><br><span class="line">    <span class="comment">// 找得到节点就返回节点的value，找不到则返回null</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashMap-containsValue-Object-value"><a href="#HashMap-containsValue-Object-value" class="headerlink" title="HashMap # containsValue(Object value)"></a>HashMap # containsValue(Object value)</h3><p>功能：</p>
<ul>
<li>根据value找到第一个找到的节点；</li>
<li>如果找到了就返回true；</li>
<li>没有返回false。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="comment">// 如果哈希表由内容的话进入if</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接遍历哈希桶数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 再遍历当前哈希桶里面的节点，判断有没有需要找的value，如果有就返回，没有就遍历下一个哈希桶</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashMap-containsKey-Object-key"><a href="#HashMap-containsKey-Object-key" class="headerlink" title="HashMap # containsKey(Object key)"></a>HashMap # containsKey(Object key)</h3><p>功能：</p>
<ul>
<li>根据key找到对应节点；</li>
<li>如果有返回true；</li>
<li>否则返回false。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析4.3.1</span></span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashMap-getOrDefault-Object-key-V-defaultValue"><a href="#HashMap-getOrDefault-Object-key-V-defaultValue" class="headerlink" title="HashMap # getOrDefault(Object key, V defaultValue)"></a>HashMap # getOrDefault(Object key, V defaultValue)</h3><p>功能：</p>
<ul>
<li>根据key找到对应节点；</li>
<li>如果有返回找到节点的value；</li>
<li>否则返回传入的defaultValue。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析4.3.1</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? defaultValue : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析4-3-1-HashMap-getNode-int-hash-Object-key"><a href="#分析4-3-1-HashMap-getNode-int-hash-Object-key" class="headerlink" title="分析4.3.1 HashMap # getNode(int hash, Object key)"></a>分析4.3.1 HashMap # getNode(int hash, Object key)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 哈希表里面有数据</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是该哈希桶里面的第一个节点就是要找的节点，那么直接将该节点返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 如果第一个节点不是，那就遍历后续节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 红黑树，不做讨论</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在节点数小于等于8时，此时还没转为红黑树，这时就遍历该链表，找到要找的节点，并返回</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判空-isEmpty"><a href="#判空-isEmpty" class="headerlink" title="判空 isEmpty()"></a>判空 isEmpty()</h2><p>这个方法没啥好说的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>先将一下用法吧。因为HashMap的遍历有点特别。</p>
<p>他的遍历并不是直接使用迭代器或者他自己有个啥foreach方法能遍历(虽说他有foreach方法，但是他那个方法不是用来遍历，而是遍历进行操作的)。</p>
<p>他的遍历方式很奇特：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object key : map.keySet()) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>或<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(HashMap.Entry entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面代码片段中可以看出，大家一般都是对 HashMap 的 key 集合或 Entry 集合进行遍历。上面代码片段中用 foreach 遍历 keySet 方法产生的集合，在编译时会转换成用迭代器遍历，等价于：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">keys</span> <span class="operator">=</span> map.keySet();</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">ite</span> <span class="operator">=</span> keys.iterator();</span><br><span class="line"><span class="keyword">while</span> (ite.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> ite.next();</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大家在遍历 HashMap 的过程中会发现，多次对 HashMap 进行遍历时，遍历结果顺序都是一致的。但这个顺序和插入的顺序一般都是不一致的。产生上述行为的原因是怎样的呢？</p>
<p>现在咱们就先来看看代码吧。</p>
<p>首先看下keySet方法：</p>
<h3 id="HashMap-keySet"><a href="#HashMap-keySet" class="headerlink" title="HashMap # keySet()"></a>HashMap # keySet()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 复制，尽管我在HashMap类里面没有找到这个变量，但是不妨碍我们看源码</span></span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        <span class="comment">// -&gt;&gt; 4.5.2</span></span><br><span class="line">        ks = <span class="keyword">new</span> <span class="title class_">KeySet</span>();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashMap-KeySet"><a href="#HashMap-KeySet" class="headerlink" title="HashMap # KeySet"></a>HashMap # KeySet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;K&gt; &#123;</span><br><span class="line">    <span class="comment">// 返回HashMap的size</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="comment">// 调用HashMap的clear方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123; HashMap.<span class="built_in">this</span>.clear(); &#125;</span><br><span class="line">    <span class="comment">// -&gt;&gt; 4.5.3</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title function_">iterator</span><span class="params">()</span>     &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyIterator</span>(); &#125;</span><br><span class="line">    <span class="comment">// 调用HashMap的containsKey方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">    <span class="comment">// 调用HashMap的removeNode方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeySpliterator</span>&lt;&gt;(HashMap.<span class="built_in">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> K&gt; action)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// fast-fail 可以看我之前ArrayList源码博客</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">            <span class="comment">// Android-changed: Detect changes to modCount early.</span></span><br><span class="line">            <span class="comment">// 遍历每一个哈希桶</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; (i &lt; tab.length &amp;&amp; modCount == mc); ++i) &#123;</span><br><span class="line">                <span class="comment">// 遍历哈希桶里面每一个节点</span></span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在遍历过程中，如果有其他线程对此HashMap操作导致HashMap的结构发生了变化，导致modCount的值发生了变化，进而不等于mc，抛异常</span></span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashMap-KeyIterator"><a href="#HashMap-KeyIterator" class="headerlink" title="HashMap # KeyIterator"></a>HashMap # KeyIterator</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeyIterator</span> <span class="keyword">extends</span> <span class="title class_">HashIterator</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;K&gt; &#123;</span><br><span class="line">    <span class="comment">// nextNode()是HashIterator里的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashMap-HashIterator"><a href="#HashMap-HashIterator" class="headerlink" title="HashMap # HashIterator"></a>HashMap # HashIterator</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HashIterator</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">    <span class="type">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">    <span class="type">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="literal">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找到第一个包含节点的桶</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">nextNode</span><span class="params">()</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="comment">// fast-fail</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="literal">null</span> &amp;&amp; (t = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 寻找下一个包含节点的桶</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        <span class="comment">// fast-fail</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        current = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> p.key;</span><br><span class="line">        <span class="comment">// 调用HashMap的removeNode方法</span></span><br><span class="line">        removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面的源码，遍历所有的键时，首先要获取键集合KeySet对象，然后再通过 KeySet 的迭代器KeyIterator进行遍历。KeyIterator 类继承自HashIterator类，核心逻辑也封装在 HashIterator 类中。HashIterator 的逻辑并不复杂，在初始化时，HashIterator 先从桶数组中找到包含链表节点引用的桶。然后对这个桶指向的链表进行遍历。遍历完成后，再继续寻找下一个包含链表节点引用的桶，找到继续遍历。找不到，则结束遍历。</p>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="为什么哈希桶的长度一定是2的次方幂"><a href="#为什么哈希桶的长度一定是2的次方幂" class="headerlink" title="为什么哈希桶的长度一定是2的次方幂"></a>为什么哈希桶的长度一定是2的次方幂</h2><p>这是因为在哈希表中，为了计算方便，他全部都用<code>hash&amp;(n-1)</code>代替了<code>hash%n</code>，但是这样替换的前提就是n必须是2的次方幂。</p>
<h2 id="hash-方法核心"><a href="#hash-方法核心" class="headerlink" title="hash()方法核心"></a>hash()方法核心</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);    <span class="comment">//key.hashCode()为哈希算法，返回初始哈希值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的流程就是执行key的hashCode方法得到他的hashCode，然后再让他的hashCode与hashCode右移16位之后的值相与。</p>
<p>那为啥要这样呢？</p>
<p>理论上散列值是一个int型，如果直接拿散列值作为下标访问HashMap主数组的话，考虑到2进制32位带符号的int表值范围从-2147483648到2147483648。前后加起来大概40亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。</p>
<p>但问题是一个40亿长度的数组，内存是放不下的。你想，HashMap扩容之前的数组初始大小才16。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。</p>
<p>这样的话，就算我的散列值分布的再松散，要是只取最后几位的话，碰撞也会很严重，这时，就可以让hashCode自己的高位和低位相与，这样加大了数据的随机性，很大程度降低了碰撞的几率。<br><img src="https://cdn.littlecorgi.top/mweb/2019-11-22/15744333648313.jpg" alt=""></p>
<h2 id="变量table为什么被transient修饰"><a href="#变量table为什么被transient修饰" class="headerlink" title="变量table为什么被transient修饰"></a>变量table为什么被transient修饰</h2><p>HashMap明明实现了serializable接口，而且还定义里serialVersionUID，那为什么table还需要用transient修饰而不去直接序列化呢？</p>
<p>其实HashMap并没有使用默认的序列化机制，而是通过实现readObject/writeObject两个方法自定义了序列化的内容。如果直接对table进行序列化的话存在着两个问题:</p>
<ul>
<li>table大多数情况下都是无法被存满的，序列化未使用的部分，浪费空间；</li>
<li>同一个键值对在不同JVM下，所处的桶位置可能是不同的，在不同的JVM下反序列化table可能会发生错误。</li>
</ul>
<p>第一个好理解，那我们说一下第二个：大家都知道HashMap很多地方都是根据hash值来进行存入或者取出数据的，但是hash调用的是Object的hashCode方法。但是hashCode方法是native方法，这个是取决于JVM的，不同的JVM可能计算hashCode的方法不同。所以如果在不同的平台下，序列化和反序列化HashMap之后。可能序列化时的HashMap是对着的，直接反序列化后，可能序列化中的元素a应该放在哈希桶1中，这样，反序列化也放在桶1中，但是由于反序列化的平台不同，导致hashcode算法不同，导致在反序列时元素a应该在桶2中，这样就导致HashMap结构出问题。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
        <tag>集合</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack源码 之 LiveData</title>
    <url>/posts/28011e4e.html</url>
    <content><![CDATA[<h1 id="Jetpack源码-之-LiveData"><a href="#Jetpack源码-之-LiveData" class="headerlink" title="Jetpack源码 之 LiveData"></a>Jetpack源码 之 LiveData</h1><h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>LiveData是Jetpack中一个响应式开发框架，官方文档对它的说明是一种可观察的数据存储器类，具有生命周期感知能力。有点类似于感知生命周期的RxJava。</p>
<h2 id="0-1-用法"><a href="#0-1-用法" class="headerlink" title="0.1 用法"></a>0.1 用法</h2><p>通常LiveData都是结合着ViewModel使用的，一般都是在ViewModel中创建LiveData：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MvvmViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过MutableLiveData创建一个可读可写的LiveData</span></span><br><span class="line">    <span class="comment">// 设置为Private，避免外部对数据直接进行修改，并暴露对外接口，让外部通过接口来修改</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _count = MutableLiveData(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 暴露给外部一个只读的LiveData副本，让外部监听数据通过此LiveData监听</span></span><br><span class="line">    <span class="keyword">val</span> count: LiveData&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line">        <span class="keyword">get</span>() = _count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">increaseCount</span><span class="params">()</span></span> &#123;</span><br><span class="line">        _count.value = _count.value?.plus(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">clearCount</span><span class="params">()</span></span> &#123;</span><br><span class="line">        _count.value = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="0-2-源码"><a href="#0-2-源码" class="headerlink" title="0.2 源码"></a>0.2 源码</h2><p>LiveData源码其实挺简单的，但是在看他的源码之前得先了解Lifecycle的源码，因为LiveData其实是大量通过Lifecycle实现的。关于Lifecycle的源码我们之前看过了，所以此篇博客不会讨论Lifecycle的相关问题。</p>
<p>我们在阅读源码前，首先得清除我们需要从源码里面搞懂哪些问题：</p>
<ol>
<li>首先，我们在用法上有MutableLiveData和LiveData， 那么他们的区别是啥</li>
<li>官方给LiveData定义是一个可被观察的数据存储类，那么他的可被观察是怎么实现的</li>
<li>官方还说他是生命周期感知的，那么是怎么实现的</li>
</ol>
<p>带着这三个问题，我们来看源码：</p>
<h1 id="1-MutableLiveData"><a href="#1-MutableLiveData" class="headerlink" title="1. MutableLiveData"></a>1. MutableLiveData</h1><p>这个类是我们用来可读可写的LiveData，我们对值的修改都是通过这个类的，那我们来看下他的源码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MutableLiveData</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">LiveData</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MutableLiveData</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MutableLiveData() &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.postValue(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>源码就这么点，全是调用父类的方法，而他的父类就是LiveData类。<br>那么既然这些方法都是调用的LiveData的，那么为什么我们不直接使用LiveData而要去使用MutableLiveData呢？</p>
<p>当你看到LiveData源码时就能知道，LiveData虽然有这些方法，但是他是一个抽象类，没办法直接构造对象，所以我们就需要通过MutableLiveData来操作。<br>同时，LiveData的<code>setValue()</code>和<code>postValue()</code>方法都是被protected修饰的，所以我们在外部并没有办法直接访问到，而MutableLiveData的这两个方法是public的，所以可以在外部直接调用。</p>
<h1 id="2-LiveData"><a href="#2-LiveData" class="headerlink" title="2. LiveData"></a>2. LiveData</h1><h2 id="2-1-基本属性"><a href="#2-1-基本属性" class="headerlink" title="2.1 基本属性"></a>2.1 基本属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LiveData</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 数据锁，通过Synchronized线程同步</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span> <span class="comment">/* synthetic access */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">mDataLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">// LiveData的初始化版本</span></span><br><span class="line">    <span class="comment">// 如果构造方法中没有给值，那么 mVersion 直接使用此值</span></span><br><span class="line">    <span class="comment">// 如果给值，那么 mVersion=START_VERSION+1</span></span><br><span class="line">    <span class="comment">// 见下面构造方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">START_VERSION</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// mData的默认值</span></span><br><span class="line">    <span class="comment">// 如果构造方法传值，那么mData使用传入的值</span></span><br><span class="line">    <span class="comment">// 如果没有，则使用此值</span></span><br><span class="line">    <span class="comment">// 见下面构造方法</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span> <span class="comment">/* synthetic access */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">NOT_SET</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个SafeIterableMap，用来保存监听的对象，key是观察者对象，value是观察者和mActive、mVersion构成的一个对象</span></span><br><span class="line">    <span class="comment">// SafeIterableMap是一个可以安全递归的HashMap</span></span><br><span class="line">    <span class="keyword">private</span> SafeIterableMap&lt;Observer&lt;? <span class="built_in">super</span> T&gt;, ObserverWrapper&gt; mObservers =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SafeIterableMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 活跃的Obsever的数量</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span> <span class="comment">/* synthetic access */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mActiveCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当前LiveData的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Object mData;</span><br><span class="line">    <span class="comment">// 当setData被调用时，我们就设置挂起的数据，实际的数据交换发生在主线程上</span></span><br><span class="line">    <span class="comment">// 咋一看有点迷，看不懂这个注释的意思，但是当我们看完postValue方法后再来看这个就能理解了</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span> <span class="comment">/* synthetic access */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">Object</span> <span class="variable">mPendingData</span> <span class="operator">=</span> NOT_SET;</span><br><span class="line">    <span class="comment">// LiveData版本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mVersion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否正在分发数据的flag</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mDispatchingValue;</span><br><span class="line">    <span class="comment">// 是否分发无效的flag</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;FieldCanBeLocal&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mDispatchInvalidated;</span><br><span class="line">    <span class="comment">// 实现同步锁更新数据的线程，在postValue中被调用，会被发送到主线程中去执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">mPostValueRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            Object newValue;</span><br><span class="line">            <span class="comment">// 将postValue发过来的数据进行修改</span></span><br><span class="line">            <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">                newValue = mPendingData;</span><br><span class="line">                mPendingData = NOT_SET;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用setValue更新数据</span></span><br><span class="line">            setValue((T) newValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LiveData</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        mData = value;</span><br><span class="line">        mVersion = START_VERSION + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LiveData</span><span class="params">()</span> &#123;</span><br><span class="line">        mData = NOT_SET;</span><br><span class="line">        mVersion = START_VERSION;</span><br><span class="line">    &#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">## <span class="number">2.2</span> LiveData # setValue()</span><br><span class="line">```java</span><br><span class="line"><span class="comment">// 通过注解表明只能在主线程使用</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    assertMainThread(<span class="string">&quot;setValue&quot;</span>);</span><br><span class="line">    <span class="comment">// 版本增加</span></span><br><span class="line">    mVersion++;</span><br><span class="line">    <span class="comment">// 更新数据</span></span><br><span class="line">    mData = value;</span><br><span class="line">    <span class="comment">// 分发事件</span></span><br><span class="line">    dispatchingValue(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码很简单，增加版本、更新数据、分发事件。<br>因为这个方法只能在主线程中被调用(@MainThread)，所以实现才这么简单，不需要考虑线程同步啥的。</p>
<h2 id="2-3-LiveData-postValue"><a href="#2-3-LiveData-postValue" class="headerlink" title="2.3 LiveData # postValue()"></a>2.3 LiveData # postValue()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> postTask;</span><br><span class="line">    <span class="comment">// 对数据更新加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">        <span class="comment">// 如果没有设置过值，那么mPendingData == NOT_SET</span></span><br><span class="line">        <span class="comment">// 先将值保存到mPendingData，在通过下面的Runable来更新数据，将mPendingData的值更新到mValue</span></span><br><span class="line">        postTask = mPendingData == NOT_SET;</span><br><span class="line">        mPendingData = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// postTask为false，就代表数据还没有更新到mValue中去，就不让更新数据</span></span><br><span class="line">    <span class="comment">// 因为postValue和mPostValueRunnable执行之间还有一定的时间间隔</span></span><br><span class="line">    <span class="keyword">if</span> (!postTask) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过线程池将数据更新发送到主线程中去更新数据</span></span><br><span class="line">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>postValue会比setValue复杂一点，因为我们可以从最后一行看出，postValue是提供给我们在其它线程中调用的，然后调用之后他就会通过线程池传回主线程，再在主线程中更新数据并调用setValue。</p>
<p>那么为什么会需要mPendingData这个中间量呢?<br>原因也很简单，因为我们最终是要在主线程中调用setValue的，那么我们怎么把最新的值传递给setValue呢，况且这块还涉及到了线程切换，所以我们就必须通过一个中间变量来将这个数据从子线程传输到主线程了。并且由于为了避免多线程情况下对数据进行修改造成数据混乱，所以才对mPendingData加了锁，并且还在postValue处如果数据还没更新的话，后面来的数据都直接丢弃了。</p>
<h2 id="2-4-LiveData-observer"><a href="#2-4-LiveData-observer" class="headerlink" title="2.4 LiveData # observer()"></a>2.4 LiveData # observer()</h2><p>上面说到了设置数据，那么我们数据设置之后谁来相应呢？<br>我们在使用的时候都是通过observer方法来注册观察者的，那我们就看下这个方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只许主线程中调用</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">observe</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner owner, <span class="meta">@NonNull</span> Observer&lt;? <span class="built_in">super</span> T&gt; observer)</span> &#123;</span><br><span class="line">    assertMainThread(<span class="string">&quot;observe&quot;</span>);</span><br><span class="line">    <span class="comment">// Activity和Fragment都实现了Owner接口，所以这个Owner就相当于他们</span></span><br><span class="line">    <span class="comment">// 当他们的状态是DESTROYED时，代表刚创建或者要摧毁了，此时就不需要注册了</span></span><br><span class="line">    <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造一个LifecycleBundleOvserver</span></span><br><span class="line">    <span class="type">LifecycleBoundObserver</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LifecycleBoundObserver</span>(owner, observer);</span><br><span class="line">    <span class="comment">// 存入mObservers这个map中去</span></span><br><span class="line">    <span class="type">ObserverWrapper</span> <span class="variable">existing</span> <span class="operator">=</span> mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    <span class="comment">// 如果已经存在了，并且他的owner并不是我们调用这个方法时传入的owner，就抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="literal">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot add the same observer&quot;</span></span><br><span class="line">                + <span class="string">&quot; with different lifecycles&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果已经存在，就没必要再添加了</span></span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过Lifecycle去监听和分发事件</span></span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>observer方法的源码很简单。</p>
<p>先根据传入的owner和observer构造一个LifecycleBoundObserver，然后把他们存入到mObservers这个SafeIterableMap中去，然后在存的时候，如果原本就有值，并且这个的owner还不是我们这次传入的这个owner，就抛出异常，如果原本有值，那么就直接返回，也就不存了。然后最后还是调用Lifecycle的addObserver存入到Lifecycle中去。</p>
<h2 id="2-5-LiveData-dispatchingValue"><a href="#2-5-LiveData-dispatchingValue" class="headerlink" title="2.5 LiveData # dispatchingValue()"></a>2.5 LiveData # dispatchingValue()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchingValue</span><span class="params">(<span class="meta">@Nullable</span> ObserverWrapper initiator)</span> &#123;</span><br><span class="line">    <span class="comment">// 是否有事件正在被分发</span></span><br><span class="line">    <span class="keyword">if</span> (mDispatchingValue) &#123;</span><br><span class="line">        <span class="comment">// 分发无效</span></span><br><span class="line">        mDispatchInvalidated = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于当前需要分发事件，于是这个flag为true</span></span><br><span class="line">    mDispatchingValue = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 正在分发，所以此flag为false</span></span><br><span class="line">        mDispatchInvalidated = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 传入的不为null</span></span><br><span class="line">        <span class="keyword">if</span> (initiator != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过considerNotify去分发</span></span><br><span class="line">            considerNotify(initiator);</span><br><span class="line">            initiator = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 传入的为null，也就是setValue中的调用</span></span><br><span class="line">            <span class="comment">//遍历mObservers，并且还是能遍历被添加的数据</span></span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class="built_in">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">                <span class="comment">// 通过considerNotify去分发</span></span><br><span class="line">                considerNotify(iterator.next().getValue());</span><br><span class="line">                <span class="comment">// 分发无效就break</span></span><br><span class="line">                <span class="keyword">if</span> (mDispatchInvalidated) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">    <span class="comment">// 分发结束，设置为false</span></span><br><span class="line">    mDispatchingValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-6-LiveData-considerNotify"><a href="#2-6-LiveData-considerNotify" class="headerlink" title="2.6 LiveData # considerNotify()"></a>2.6 LiveData # considerNotify()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">considerNotify</span><span class="params">(ObserverWrapper observer)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是active状态了，就不用分发了</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check latest state b4 dispatch. Maybe it changed state but we didn&#x27;t get the event yet.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class="line">    <span class="comment">// the observer moved to an active state, if we&#x27;ve not received that event, we better not</span></span><br><span class="line">    <span class="comment">// notify for a more predictable notification order.</span></span><br><span class="line">    <span class="comment">// 如果状态不是STARTED之后的话，那么就更新状态</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">        observer.activeStateChanged(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果Observer的Version高于当前Version，那么就没必要去分发</span></span><br><span class="line">    <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新Version</span></span><br><span class="line">    observer.mLastVersion = mVersion;</span><br><span class="line">    <span class="comment">// 事件分发，调用我们实现的Observer的onChanged方法，也就是我们写的代码</span></span><br><span class="line">    observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-LifecycleWrapper"><a href="#3-LifecycleWrapper" class="headerlink" title="3. LifecycleWrapper"></a>3. LifecycleWrapper</h1><h2 id="3-1-LifecycleWrapper"><a href="#3-1-LifecycleWrapper" class="headerlink" title="3.1 LifecycleWrapper"></a>3.1 LifecycleWrapper</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ObserverWrapper</span> &#123;</span><br><span class="line">    <span class="comment">// Observer</span></span><br><span class="line">    <span class="keyword">final</span> Observer&lt;? <span class="built_in">super</span> T&gt; mObserver;</span><br><span class="line">    <span class="comment">// 当前Observer的状态</span></span><br><span class="line">    <span class="type">boolean</span> mActive;</span><br><span class="line">    <span class="comment">// Observer的最新的Version</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mLastVersion</span> <span class="operator">=</span> START_VERSION;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    ObserverWrapper(Observer&lt;? <span class="built_in">super</span> T&gt; observer) &#123;</span><br><span class="line">        mObserver = observer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">shouldBeActive</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">detachObserver</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">activeStateChanged</span><span class="params">(<span class="type">boolean</span> newActive)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// immediately set active state, so we&#x27;d never dispatch anything to inactive</span></span><br><span class="line">        <span class="comment">// owner</span></span><br><span class="line">        <span class="comment">// 更新状态</span></span><br><span class="line">        mActive = newActive;</span><br><span class="line">        <span class="comment">// 如果mActivityCount==0那就意味着没有Observer</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">wasInactive</span> <span class="operator">=</span> LiveData.<span class="built_in">this</span>.mActiveCount == <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 更新mActiveCount</span></span><br><span class="line">        LiveData.<span class="built_in">this</span>.mActiveCount += mActive ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class="line">            <span class="comment">// 如果mActive=1，那么就onActive去更新</span></span><br><span class="line">            onActive();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (LiveData.<span class="built_in">this</span>.mActiveCount == <span class="number">0</span> &amp;&amp; !mActive) &#123;</span><br><span class="line">            <span class="comment">// 如果当前mActiveCount刚刚为0，那么就onInactive</span></span><br><span class="line">            onInactive();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果mActive=true，那么就分发</span></span><br><span class="line">        <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">            dispatchingValue(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-LifecycleBoundObserver"><a href="#3-2-LifecycleBoundObserver" class="headerlink" title="3.2 LifecycleBoundObserver"></a>3.2 LifecycleBoundObserver</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title class_">ObserverWrapper</span> <span class="keyword">implements</span> <span class="title class_">LifecycleEventObserver</span> &#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">final</span> LifecycleOwner mOwner;</span><br><span class="line"></span><br><span class="line">    LifecycleBoundObserver(<span class="meta">@NonNull</span> LifecycleOwner owner, Observer&lt;? <span class="built_in">super</span> T&gt; observer) &#123;</span><br><span class="line">        <span class="built_in">super</span>(observer);</span><br><span class="line">        mOwner = owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">shouldBeActive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断当前Lifecycle的状态是不是在STARTED之后</span></span><br><span class="line">        <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class="line">        <span class="comment">// 监听Lifecycle的状态发生变化</span></span><br><span class="line">        <span class="comment">// 如果状态时DESTROYED，</span></span><br><span class="line">        <span class="keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">            <span class="comment">// 移除掉这个Observer</span></span><br><span class="line">            removeObserver(mObserver);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新Active</span></span><br><span class="line">        activeStateChanged(shouldBeActive());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner == owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">detachObserver</span><span class="params">()</span> &#123;</span><br><span class="line">        mOwner.getLifecycle().removeObserver(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><h2 id="4-1-总结和流程"><a href="#4-1-总结和流程" class="headerlink" title="4.1 总结和流程"></a>4.1 总结和流程</h2><p>LiveData主要由2个类构成：</p>
<ul>
<li><code>LiveData</code>：抽象类，实现类就是<code>MutableLiveData</code>，只不过<code>MutableLiveData</code>中的所有的方法都是直接调用了<code>LiveData</code>的方法，本质上和<code>LiveData</code>没啥区别。</li>
<li><code>LifecycleWrapper</code>：抽象类，主要用来对<code>Observer</code>和<code>Version</code>、<code>Active</code>进行管理，而我们使用的都是<code>LifecycleBoundObserver</code>，这个类继承自<code>LifecycleWrapper</code>，并实现了<code>LifecycleEventObserver</code>接口。</li>
</ul>
<p>并且底层还是通过Lifecycle去实现的，就是对Lifecycle进行了一下封装。</p>
<p>LiveData的操作主要分为两种：</p>
<ul>
<li>添加观察者：<code>observer()</code></li>
<li>设置数据：<ul>
<li><code>setValue()</code></li>
<li><code>postValue()</code></li>
</ul>
</li>
</ul>
<h3 id="4-1-1-添加观察者"><a href="#4-1-1-添加观察者" class="headerlink" title="4.1.1 添加观察者"></a>4.1.1 添加观察者</h3><ol>
<li>调用<code>observer()</code>方法，<ol>
<li>在这个方法中会先构造一个LifecycleBoundObserver的对象，这个对象保存了这个<code>mObserver</code>以及激活状态<code>mActive</code>；</li>
<li>接着把这个对象通过<code>mObservers.putIfAbsent()</code>添加到mObservers这个map中去；</li>
<li>并调用<code>owner.getLifecycle().addObserver(wrapper)</code>添加到Lifecycle中进行监听。</li>
</ol>
</li>
<li>之后每当<code>owner</code>生命周期变化时，就会调用LifecycleBoundObserver的<code>onStateChanged()</code>方法 (具体可见Lifecycle的源码)<ol>
<li>如果当前<code>owner</code>的状态为<code>DESTROYED</code>的时候，就会将这个<code>observer</code>从<code>mObservers</code>中移除</li>
<li>如果不是，就调用<code>activeStateChanged()</code>去更新<code>mActive</code></li>
</ol>
</li>
</ol>
<h3 id="4-1-2-设置数据"><a href="#4-1-2-设置数据" class="headerlink" title="4.1.2 设置数据"></a>4.1.2 设置数据</h3><ol>
<li><code>postValue()</code>：这个方法主要是提供给我们在非主线程中去调用的<ol>
<li>这个方法中会先加锁，然后将数据保存到<code>mPendingData</code>中，并根据<code>mPendingData</code>的值判断上次post的值是否更新到<code>mData</code>中了：<ol>
<li>如果更新到了，则通过<code>ArchTaskExecutor</code>将<code>mPostValueRunnable</code>这个Runnable<code>post</code>到了主线程中执行<ol>
<li><code>mPostValueRunnable</code>中会将加锁，将<code>mPendingData</code>中的值更新到<code>newData</code>中，并将<code>mPendingData</code>值设置为<code>NOT_SET</code>，然后会调用<code>setValue(newData)</code></li>
</ol>
</li>
<li>如果没有更新，则会直接return退出这次<code>postValue()</code>，不更新数据，直接丢弃</li>
</ol>
</li>
</ol>
</li>
<li><code>setValue()</code>：这个方法只能在主线程中调用<ol>
<li>他就会直接调用<code>dispatchingValue(null)</code>进行分发</li>
<li>这个方法中如果传入的是<code>null</code>，就代表需要分发给所有的Observer，那么他会遍历<code>mObservers</code>，对每一个Observer调用<code>considerNotify(iterator.next().getValue());</code></li>
<li>在<code>considerNotify(observer)</code>中会先判断传入的这个Observer的<code>mActive</code>是否为<code>false</code>，如果是的话，就代表没有激活，也就是他的<code>owner</code>处于<code>STARTED</code>之后，就没有必要去更新View了；而如果不是就继续往下执行：<ol>
<li>先调用<code>shouldBeActive</code>判断<code>owner</code>是否处于<code>STARTED</code>之后，如果是就调用<code>activeStateChanged(false)</code>去更新<code>mActive</code>为false，并return，不分发事件</li>
<li>在判断<code>observer</code>的<code>mLastVersion</code>是否大于当前的<code>mVersion</code>，如果大于等于，则也没有必要继续分发</li>
<li>之后更新<code>observer</code>的<code>mLastVersion</code>为当前的<code>mVersion</code></li>
<li>调用<code>observer.mObserver.onChanged((T) mData);</code>去执行我们实现的Observer</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="4-1-3-流程图"><a href="#4-1-3-流程图" class="headerlink" title="4.1.3 流程图"></a>4.1.3 流程图</h3><p>对于流程我们可以用下图表示：<br><img src="https://cdn.littlecorgi.top/mweb/2020-08-22/Jetpack%E6%BA%90%E7%A0%81-%E4%B9%8B-LiveData-LiveData%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="Jetpack源码-之-LiveData-LiveData流程图"></p>
<h2 id="4-2-LiveData真的可以被用于事件分发吗"><a href="#4-2-LiveData真的可以被用于事件分发吗" class="headerlink" title="4.2 LiveData真的可以被用于事件分发吗"></a>4.2 LiveData真的可以被用于事件分发吗</h2><p>LiveData本质上是可观察的数据存储类，但是可观察这个特性不就可以被用来事件分发吗(EventBus)，而且还通过Lifecycle实现了生命周期感知，这些相对来说比EventBus更加简单。</p>
<p>但是LiveData真的有表面上看上去的这个简单吗？真的有这么好吗？</p>
<h3 id="4-2-1-postValue-数据丢失"><a href="#4-2-1-postValue-数据丢失" class="headerlink" title="4.2.1 postValue 数据丢失"></a>4.2.1 postValue 数据丢失</h3><p>在postValue方法中，如果mPendingData == NOT_SET的话，就会直接丢弃调这次的数据。也就是说，如果上次的事件还在分发，还没完成的话，那么这次的事件就会直接丢弃。</p>
<p>这样就导致了事件丢失。</p>
<h3 id="4-2-2-considerNotify-不回调观察者"><a href="#4-2-2-considerNotify-不回调观察者" class="headerlink" title="4.2.2 considerNotify 不回调观察者"></a>4.2.2 considerNotify 不回调观察者</h3><p>除了postValue存放事件这块有问题，considerNotify通知事件也有问题。</p>
<p>considerNotify这个方法第一行就是如果Observer处于非激活状态(mActive == false)，那么这个时候他就不会回调这个Observer去分发事件。</p>
<p>只有当Observer处于激活状态，他才会进行分发。</p>
<p>这样就造成了事件丢失，中间传输的数据都无法收到。</p>
<h3 id="4-2-3-LiveData本来就不是为事件分发打造的"><a href="#4-2-3-LiveData本来就不是为事件分发打造的" class="headerlink" title="4.2.3 LiveData本来就不是为事件分发打造的"></a>4.2.3 LiveData本来就不是为事件分发打造的</h3><p>在官方文档上第一句话就表明了，LiveData只是一个可观察的数据存储类，他的核心在于他能将最新的数据通知给观察者，也就是说，他本来就不会在意中间状态，它只要保证当View处于激活状态能得到最新的数据保证UI时正确的就行，如果还要去纠结中间状态的话，那么UI展示岂不会变得很奇怪；并且如果对于没有显示的View都要去通知这个View的话，这样不就会显得很多此一举。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
        <tag>LiveData</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack源码 之 Lifecycle</title>
    <url>/posts/53c3ccc1.html</url>
    <content><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><h2 id="0-1-用法"><a href="#0-1-用法" class="headerlink" title="0.1 用法"></a>0.1 用法</h2><p>Lifecycle可以说是Jetpack中最基础的一个库，他的主要作用就是帮我们实现的生命周期监听。</p>
<p>对于他的用法也很简单，由于我们的Activity(间接通过<code>ComponentActivity</code>实现)、Fragment(直接实现)都已经实现了<code>LifecycleOwner</code>接口，所以我们可以直接在他们中调用<code>getLifecycle()</code>获得到<code>Lifecycle</code>对象，然后调用他的<code>addObserver()</code>将我们自定义的<code>LifecycleObserver</code>传入进入即可。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 以Activity为例 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MainActivity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_lifecycle_test)</span><br><span class="line">        lifecycle.addObserver(LifecycleObserverTest)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LifecycleObserverTest</span></span><br><span class="line"><span class="keyword">object</span> LifecycleObserverTest : LifecycleObserver &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;LifecycleTest&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">prepare</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// todo 播放器准备工作</span></span><br><span class="line">        Log.d(TAG, <span class="string">&quot;prepare: Create时播放器准备工作&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// todo 释放资源</span></span><br><span class="line">        Log.d(TAG, <span class="string">&quot;release: Destroy时释放资源&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">play</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// todo 开始播放</span></span><br><span class="line">        Log.d(TAG, <span class="string">&quot;play&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样当MainActivity执行<code>onCreate()</code>时会自动执行<code>prepare()</code>方法，执行<code>onDestroy()</code>时会自动执行<code>release()</code>方法，就不需要我们手动的去调用了。</p>
<p>但是这块需要注意的是，这些添加了生命周期的方法，一定不要传入任何参数，因为都已经是自动调用的了，也就我们手动干预不了，那么系统怎么知道你要传入的参数是谁呢。没有添加生命周期的方法不受影响。</p>
<p>另外一个注意的点是，我们调用<code>addObserver()</code>并不是一定得在<code>onCreate()</code>方法中调用，我们在任何地方任何生命周期时调用即可，比方说我们上面在<code>onCreate()</code>中调用了，这样打印出来的log就如下所示：<br><img src="https://cdn.littlecorgi.top/mweb/2020-08-14/Jetpack%E6%BA%90%E7%A0%81%20%E4%B9%8B%20Lifecycle-1-.png" alt="Jetpack源码 之 Lifecycle-1-"></p>
<p>但是如果我们把<code>addObserver()</code>放在<code>onResume()</code>中调用，结果就变成了这样：<br><img src="https://cdn.littlecorgi.top/mweb/2020-08-14/Jetpack%E6%BA%90%E7%A0%81%20%E4%B9%8B%20Lifecycle-2-.png" alt="Jetpack源码 之 Lifecycle-2-"><br>我们就会发现，原本应该在<code>onCreate()</code>时执行的方法却到了<code>onResume()</code>才执行。</p>
<p>所以这点我们一定要注意，我们调用<code>addObserver()</code>一定得在我们监听的生命周期里面或者之前。</p>
<h2 id="0-2-真-·-前言"><a href="#0-2-真-·-前言" class="headerlink" title="0.2 真 · 前言"></a>0.2 真 · 前言</h2><p>看完刚刚的用法，我们能得到的第一个要素就是Lifecycle一定是通过观察者模式实现的，这个从<code>addObserver()</code>就能看出来。</p>
<p>所以我们可以大胆猜想下Lifecycle的实现原理：<br>当调动<code>addObserver()</code>之后，Lifecycle就通过一种数据接口将这个LifecycleObserver的对象保存了起来，当Activity生命周期变化时，他就会遍历这个数据结构，然后调用每一个的对应的生命周期的回调代码。</p>
<p>对应的也就分为两部分：</p>
<ol>
<li>注册</li>
<li>分发</li>
<li>执行回调</li>
</ol>
<p>(PS:突然感觉好像EventBus😂)</p>
<p>接下来我们就可以开始看源码，来验证我们的猜想到底正不正确。</p>
<h1 id="1-注册"><a href="#1-注册" class="headerlink" title="1. 注册"></a>1. 注册</h1><p>注册肯定是从<code>getLifecycle().addObserver(LifecycleObserver observer)</code>开始嘛。</p>
<p>首先，<code>getLifecycle()</code>是谁的方法？</p>
<p>直接通过AndroidStudio的跳转功能就能看到，我们调用的<code>getLifecycle()</code>其实是ComponentActivity的一个方法，进一步跳转就能看到其实是LifecycleOwner这个接口的一个抽象方法。</p>
<p>所以也就是说，Activity继承自ComponentActivity，而ComponentActivity实现了LifecycleOwner接口，这个接口中只有一个方法，那就是<code>getLifecycle()</code>。(Fragment同理)</p>
<p>而这个方法返回的是Lifecycle，那么Lifecycle里面有些啥东西？</p>
<h2 id="1-1-Lifecycle抽象类"><a href="#1-1-Lifecycle抽象类" class="headerlink" title="1.1 Lifecycle抽象类"></a>1.1 Lifecycle抽象类</h2><p>进入Lifecycle的源码就能看到它是一个抽象类，代码也很少：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Lifecycle</span> &#123;</span><br><span class="line"></span><br><span class="line">    AtomicReference&lt;Object&gt; mInternalScopeRef = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span>;</span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span>;</span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> State <span class="title function_">getCurrentState</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">        ON_CREATE,</span><br><span class="line">        ON_START,</span><br><span class="line">        ON_RESUME,</span><br><span class="line">        ON_PAUSE,</span><br><span class="line">        ON_STOP,</span><br><span class="line">        ON_DESTROY,</span><br><span class="line">        ON_ANY</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        DESTROYED,</span><br><span class="line">        INITIALIZED,</span><br><span class="line">        CREATED,</span><br><span class="line">        STARTED,</span><br><span class="line">        RESUMED;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAtLeast</span><span class="params">(<span class="meta">@NonNull</span> State state)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Lifecycle中有三个方法和两个枚举：</p>
<ul>
<li>三个方法<ul>
<li><code>addObserver()</code>：Adds a LifecycleObserver that will be notified when the LifecycleOwner changes.<br>（添加一个LifecycleObserver，这个LifecycleObserver在LifecycleOwner变化时能得到通知）</li>
<li><code>removeObserver()</code>：Removes the given observer from the observers list.<br>（从observers的集合中移除这个observer）</li>
<li><code>getCurrentState()</code>：Returns the current state of the Lifecycle.<br>（返回当前的生命周期状态(State)）</li>
</ul>
</li>
<li>两个枚举<ul>
<li><code>Event</code>：这个不用多说，对应着Activity、Fragment的基本生命周期</li>
<li><code>State</code>：这个是返回的当前Activity、Fragment的状态，具体转换看下图：</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.littlecorgi.top/mweb/2020-08-14/15973104823930.jpg" alt="关于这个图的来源可以看LifecycleRegistry.getStateAfter()源码"></p>
<p>从上可得知，Lifecycle这个抽象类主要的作用就是</p>
<ul>
<li>添加和移除Observer</li>
<li>获取当前LifecycleOwner的状态，并负责对应的状态和事件的转换</li>
</ul>
<p>那么我们回过头来，<code>getLifecycle()</code>要求返回一个Lifecycle对象，但是Lifecycle是一个抽象类，没办法直接构造对象，那么这个方法返回的是谁？<br>我们直接看ComponentActivity的<code>getLifecycle()</code>方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Lifecycle <span class="title function_">getLifecycle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而这个<code>mLifecycleRegistry</code>是LifecycleRegistry的对象，所以可以得知，Lifecycle其中一个(实际上是唯一)实现类是LifecycleRegistry。</p>
<h2 id="1-2-LifecycleRegistry"><a href="#1-2-LifecycleRegistry" class="headerlink" title="1.2 LifecycleRegistry"></a>1.2 LifecycleRegistry</h2><p>Lifecycle只有唯一一个实现类，那就是LifecycleRegistry。</p>
<p>刚刚说到，注册肯定是有一个Observer的集合，刚刚Lifecycle源码中的注释也说明了这一点，所以我们先从这个类的属性开始看起：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifecycleRegistry</span> <span class="keyword">extends</span> <span class="title class_">Lifecycle</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FastSafeIterableMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> State mState;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;LifecycleOwner&gt; mLifecycleOwner;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mAddingObserverCounter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">mHandlingEvent</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">mNewEventOccurred</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>mObserverMap</code>：用于保存Observer的集合，是一个FastSafeIterableMap集合，而这个FastSafeIterableMap根据源码注释，是类似于LinkedHashMap的，并且它是线程不安全，允许使用迭代器时修改集合的。</li>
<li><code>mState</code>：当前的状态(State)。就是Lifecycle中的那个State枚举类。</li>
<li><code>mLifecycleOwner</code>：就是这个LifecycleRegistry的持有者，这块使用了弱引用，是为了避免对Fragment、Activity直接引用而造成内存泄漏。</li>
<li><code>mAddingObserverCounter</code>：正在添加到mObserverMap中的Observer的数量。</li>
<li><code>mHandlingEvent</code>：是否正在分发事件的标记。</li>
<li><code>mNewEventOccurred</code>：是否有新的事件发生的标记。</li>
</ul>
<p>接着就来分析addObserver方法：</p>
<h3 id="1-2-1-addObserver-NonNull-LifecycleObserver-observer"><a href="#1-2-1-addObserver-NonNull-LifecycleObserver-observer" class="headerlink" title="1.2.1 addObserver(@NonNull LifecycleObserver observer)"></a>1.2.1 addObserver(@NonNull LifecycleObserver observer)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span> &#123;</span><br><span class="line">    <span class="type">State</span> <span class="variable">initialState</span> <span class="operator">=</span> mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">    <span class="comment">// 根据状态和observer构造出一个statefulObserver</span></span><br><span class="line">    <span class="type">ObserverWithState</span> <span class="variable">statefulObserver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObserverWithState</span>(observer, initialState);</span><br><span class="line">    <span class="comment">// 通过observer去mObserverMap查找，如果没有这个key或者值为null，就将value保存进去，如果有value，就取出来赋值给previous</span></span><br><span class="line">    <span class="type">ObserverWithState</span> <span class="variable">previous</span> <span class="operator">=</span> mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line">    <span class="comment">// 如果previous不为null，就证明mObserverMap中已经保存了这个observer，就直接return</span></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取到lifecycleOwner弱引用引用对象</span></span><br><span class="line">    <span class="type">LifecycleOwner</span> <span class="variable">lifecycleOwner</span> <span class="operator">=</span> mLifecycleOwner.get();</span><br><span class="line">    <span class="comment">// 为null，就证明这个Activity或者Fragment已经Destroy了</span></span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// it is null we should be destroyed. Fallback quickly</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有observer正在被加入或者正在分发时间，这个标记就会为true</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isReentrance</span> <span class="operator">=</span> mAddingObserverCounter != <span class="number">0</span> || mHandlingEvent;</span><br><span class="line">    <span class="comment">// 计算出目前的State——targetState。</span></span><br><span class="line">    <span class="comment">// -&gt;&gt;&gt; 见1.2.2</span></span><br><span class="line">    <span class="type">State</span> <span class="variable">targetState</span> <span class="operator">=</span> calculateTargetState(observer);</span><br><span class="line">    <span class="comment">// 代表有一个Observer正在被添加</span></span><br><span class="line">    mAddingObserverCounter++;</span><br><span class="line">    <span class="comment">// 如果当前这个Observer的状态低于targetState并且mObserverMap中还有这个Observer的话，就需要同步到targetState</span></span><br><span class="line">    <span class="keyword">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">        <span class="comment">// 同步时先push进去，临时保存下</span></span><br><span class="line">        pushParentState(statefulObserver.mState);</span><br><span class="line">        <span class="comment">// 分发事件</span></span><br><span class="line">        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class="line">        <span class="comment">// 分发完成再pop出来</span></span><br><span class="line">        popParentState();</span><br><span class="line">        <span class="comment">// mState / subling may have been changed recalculate</span></span><br><span class="line">        <span class="comment">// 重新计算targetState</span></span><br><span class="line">        targetState = calculateTargetState(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不可重入，就执行sync方法</span></span><br><span class="line">    <span class="keyword">if</span> (!isReentrance) &#123;</span><br><span class="line">        <span class="comment">// we do sync only on the top level.</span></span><br><span class="line">        <span class="comment">// sync涉及到了事件分发，我们放到后面说</span></span><br><span class="line">        <span class="comment">// -&gt;&gt;&gt; 见 2.2.4</span></span><br><span class="line">        sync();</span><br><span class="line">    &#125;</span><br><span class="line">    mAddingObserverCounter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这个方法主要执行了下面几件事</p>
<ol>
<li>先构造一个默认状态，要么是<code>DESTROYED</code>要么是<code>INITIALIZED</code></li>
<li>然后根据这个<code>observer</code>和这个状态构建出一个<code>statefulObserver</code></li>
<li>就去计算<code>targetState</code>，并对于这个<code>statefulObserver</code>，如果他的<code>state</code>小于<code>targetState</code>，就进行分发时间，并重新计算<code>targetState</code></li>
<li>如果是不可重入状态，则执行<code>sync()</code>方法</li>
</ol>
<h3 id="1-2-2-calculateTargetState-LifecycleObserver-observer"><a href="#1-2-2-calculateTargetState-LifecycleObserver-observer" class="headerlink" title="1.2.2 calculateTargetState(LifecycleObserver observer)"></a>1.2.2 calculateTargetState(LifecycleObserver observer)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> State <span class="title function_">calculateTargetState</span><span class="params">(LifecycleObserver observer)</span> &#123;</span><br><span class="line">    <span class="comment">// 取出当前observer的前一个Observer</span></span><br><span class="line">    Entry&lt;LifecycleObserver, ObserverWithState&gt; previous = mObserverMap.ceil(observer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到previous的State</span></span><br><span class="line">    <span class="type">State</span> <span class="variable">siblingState</span> <span class="operator">=</span> previous != <span class="literal">null</span> ? previous.getValue().mState : <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 取出parentState最后一个元素的State</span></span><br><span class="line">    <span class="type">State</span> <span class="variable">parentState</span> <span class="operator">=</span> !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - <span class="number">1</span>)</span><br><span class="line">            : <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 取出这些中最小的State</span></span><br><span class="line">    <span class="keyword">return</span> min(min(mState, siblingState), parentState);</span><br><span class="line">&#125;                                                                                          </span><br></pre></td></tr></table></figure>
<p>所以这个方法的主要作用就是计算<code>targetState</code>，这个<code>targetState</code>一定小于等于当前<code>mState</code>。<br>也就是说，我们可以添加多个Observer，但是每次添加新的Observer的时候，初始状态都是<code>INITIALIZED</code>，这个时候就需要把它同步到当前的生命周期状态。</p>
<p>并且在更新状态的时候，每次更新之后都会调用这个方法再重新计算<code>targetState</code>。</p>
<p>上面就完成了事件的添加了，那我们现在再来看下它是怎么分发事件的。</p>
<h1 id="2-分发"><a href="#2-分发" class="headerlink" title="2. 分发"></a>2. 分发</h1><p>我们再次回到ComponentActivity，他在<code>onCreate()</code>方法中执行了一行代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    mSavedStateRegistryController.performRestore(savedInstanceState);</span><br><span class="line">    ReportFragment.injectIfNeededIn(<span class="built_in">this</span>); <span class="comment">// !!!</span></span><br><span class="line">    <span class="keyword">if</span> (mContentLayoutId != <span class="number">0</span>) &#123;</span><br><span class="line">        setContentView(mContentLayoutId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>那我们看一下这个ReportFragment到底是啥：</p>
<h2 id="2-1-ReportFragment"><a href="#2-1-ReportFragment" class="headerlink" title="2.1 ReportFragment"></a>2.1 ReportFragment</h2><h3 id="2-1-1-ReportFragment-injectIfNeededIn"><a href="#2-1-1-ReportFragment-injectIfNeededIn" class="headerlink" title="2.1.1 ReportFragment # injectIfNeededIn()"></a>2.1.1 ReportFragment # injectIfNeededIn()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">injectIfNeededIn</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">    <span class="comment">// ProcessLifecycleOwner should always correctly work and some activities may not extend</span></span><br><span class="line">    <span class="comment">// FragmentActivity from support lib, so we use framework fragments for activities</span></span><br><span class="line">    <span class="comment">// 获取到FragmentManager</span></span><br><span class="line">    android.app.<span class="type">FragmentManager</span> <span class="variable">manager</span> <span class="operator">=</span> activity.getFragmentManager();</span><br><span class="line">    <span class="comment">// 判断当前的FragmentManager里面有没有我们需要的Fragment，没有的话就添加进去</span></span><br><span class="line">    <span class="keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="literal">null</span>) &#123;</span><br><span class="line">        manager.beginTransaction().add(<span class="keyword">new</span> <span class="title class_">ReportFragment</span>(), REPORT_FRAGMENT_TAG).commit();</span><br><span class="line">        <span class="comment">// Hopefully, we are the first to make a transaction.</span></span><br><span class="line">        manager.executePendingTransactions();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这块是不是感觉很眼熟，Android中最常用的监听生命周期的方法就是往Activity中添加一个没有界面的Fragment，这块正是这个操作，所以我们具体看一下ReportFragment的实现。</p>
<h3 id="2-1-2-ReportFragment-生命周期监听"><a href="#2-1-2-ReportFragment-生命周期监听" class="headerlink" title="2.1.2 ReportFragment # 生命周期监听"></a>2.1.2 ReportFragment # 生命周期监听</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">    dispatchCreate(mProcessListener);</span><br><span class="line">    dispatch(Lifecycle.Event.ON_CREATE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onStart();</span><br><span class="line">    dispatchStart(mProcessListener);</span><br><span class="line">    dispatch(Lifecycle.Event.ON_START);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onResume();</span><br><span class="line">    dispatchResume(mProcessListener);</span><br><span class="line">    dispatch(Lifecycle.Event.ON_RESUME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onPause();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onStop();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_STOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onDestroy();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">    <span class="comment">// just want to be sure that we won&#x27;t leak reference to an activity</span></span><br><span class="line">    mProcessListener = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是ReportFragment中对生命周期监听的所有方法，我们可以看到这些方法都有两个共性：</p>
<ul>
<li>他们都调用了<code>dispatch()</code>方法去分发生命周期</li>
<li>他们都通知了<code>mProcessListener</code></li>
</ul>
<p>对于<code>mProcessListener</code>，这个是处理应用程序进程的生命周期的，这个我们先不去管它，我们需要重视的是这个<code>dispatch()</code>方法</p>
<h3 id="2-1-3-ReportFragment-dispatch"><a href="#2-1-3-ReportFragment-dispatch" class="headerlink" title="2.1.3 ReportFragment # dispatch()"></a>2.1.3 ReportFragment # dispatch()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(Lifecycle.Event event)</span> &#123;</span><br><span class="line">    <span class="type">Activity</span> <span class="variable">activity</span> <span class="operator">=</span> getActivity();</span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">        <span class="type">Lifecycle</span> <span class="variable">lifecycle</span> <span class="operator">=</span> ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">        <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们探究的是ComponentActivity，所以肯定是走的第8行的if，然后他就会通过<code>getLifecycle()</code>拿到<code>mLifecycleRegistry</code>，然后调用了他的<code>handleLifecycleEvent(event)</code></p>
<h2 id="2-2-LifecycleRegistry"><a href="#2-2-LifecycleRegistry" class="headerlink" title="2.2 LifecycleRegistry"></a>2.2 LifecycleRegistry</h2><h3 id="2-2-1-LifecycleRegistry-handleLifecycleEvent"><a href="#2-2-1-LifecycleRegistry-handleLifecycleEvent" class="headerlink" title="2.2.1 LifecycleRegistry # handleLifecycleEvent()"></a>2.2.1 LifecycleRegistry # handleLifecycleEvent()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLifecycleEvent</span><span class="params">(<span class="meta">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class="line">    <span class="type">State</span> <span class="variable">next</span> <span class="operator">=</span> getStateAfter(event);</span><br><span class="line">    moveToState(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他首先调用了<code>getSateAfter()</code>方法，获取到了当前<code>event</code>对应的State（这个对应关系见上面那个State和Event的对应关系图）。<br>然后调用<code>moveToSate()</code>去分发事件以及移动状态。</p>
<h3 id="2-2-2-LifecycleRegistry-getStateAfter"><a href="#2-2-2-LifecycleRegistry-getStateAfter" class="headerlink" title="2.2.2 LifecycleRegistry # getStateAfter()"></a>2.2.2 LifecycleRegistry # getStateAfter()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> State <span class="title function_">getStateAfter</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">        <span class="keyword">case</span> ON_CREATE:</span><br><span class="line">        <span class="keyword">case</span> ON_STOP:</span><br><span class="line">            <span class="keyword">return</span> CREATED;</span><br><span class="line">        <span class="keyword">case</span> ON_START:</span><br><span class="line">        <span class="keyword">case</span> ON_PAUSE:</span><br><span class="line">            <span class="keyword">return</span> STARTED;</span><br><span class="line">        <span class="keyword">case</span> ON_RESUME:</span><br><span class="line">            <span class="keyword">return</span> RESUMED;</span><br><span class="line">        <span class="keyword">case</span> ON_DESTROY:</span><br><span class="line">            <span class="keyword">return</span> DESTROYED;</span><br><span class="line">        <span class="keyword">case</span> ON_ANY:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unexpected event value &quot;</span> + event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个也就是我们上面说的Event和State对照图的来源。</p>
<h3 id="2-2-3-LifecycleRegistry-moveToState"><a href="#2-2-3-LifecycleRegistry-moveToState" class="headerlink" title="2.2.3 LifecycleRegistry # moveToState()"></a>2.2.3 LifecycleRegistry # moveToState()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToState</span><span class="params">(State next)</span> &#123;</span><br><span class="line">    <span class="comment">// 当前状态已经是目标状态了，就不需要改变</span></span><br><span class="line">    <span class="keyword">if</span> (mState == next) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改变当前状态</span></span><br><span class="line">    mState = next;</span><br><span class="line">    <span class="comment">// 如果正在分发状态，或者有Observer正在添加的话</span></span><br><span class="line">    <span class="keyword">if</span> (mHandlingEvent || mAddingObserverCounter != <span class="number">0</span>) &#123;</span><br><span class="line">        mNewEventOccurred = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// we will figure out what to do on upper level.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分发状态标志位设置为true</span></span><br><span class="line">    mHandlingEvent = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 调用sync方法进行事件分发</span></span><br><span class="line">    sync();</span><br><span class="line">    <span class="comment">// 分发状态标志位设置为false</span></span><br><span class="line">    mHandlingEvent = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法就是将<code>next</code>同步到<code>mState</code>，并进行对应的状态的分发。</p>
<h3 id="2-2-4-LifecycleRegistry-sync"><a href="#2-2-4-LifecycleRegistry-sync" class="headerlink" title="2.2.4 LifecycleRegistry # sync()"></a>2.2.4 LifecycleRegistry # sync()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sync</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 取出当前的lifecycleOwner，按照我们上面的流程，此处取出的是ComponentActivity</span></span><br><span class="line">    <span class="comment">// (并不一定是这个Activity，只是因为我们是从ComponentActivity入手分析的，也有可能是Fragment)</span></span><br><span class="line">    <span class="type">LifecycleOwner</span> <span class="variable">lifecycleOwner</span> <span class="operator">=</span> mLifecycleOwner.get();</span><br><span class="line">    <span class="comment">// 如果Owner不存在了，就抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;LifecycleOwner of this LifecycleRegistry is already&quot;</span></span><br><span class="line">                + <span class="string">&quot;garbage collected. It is too late to change lifecycle state.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过isSynced去判断，</span></span><br><span class="line">    <span class="comment">// 这个方法主要是判断mObserverMap的队头和队尾元素的State是否相等，以及队尾元素的State是否等于mState</span></span><br><span class="line">    <span class="comment">// 如果均相等则返回true(不需要进行分发)，否则返回false</span></span><br><span class="line">    <span class="keyword">while</span> (!isSynced()) &#123;</span><br><span class="line">        mNewEventOccurred = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// no need to check eldest for nullability, because isSynced does it for us.</span></span><br><span class="line">        <span class="comment">// 如果 mState 小于 mObserverMap 中队头元素的状态值，调用 backwardPass()</span></span><br><span class="line">        <span class="keyword">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            backwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出队尾元素</span></span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();</span><br><span class="line">        <span class="comment">// 如果mState的状态值大于newest的状态值，则调用forwardPass()</span></span><br><span class="line">        <span class="keyword">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            forwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNewEventOccurred = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这是<code>mState</code>已经更新，但是Observers的状态还没更新过，所以肯定是进入第23行的if，也就执行<code>forwardPass()</code>方法</p>
<h3 id="2-2-5-LifecycleRegistry-forwardPass"><a href="#2-2-5-LifecycleRegistry-forwardPass" class="headerlink" title="2.2.5 LifecycleRegistry # forwardPass()"></a>2.2.5 LifecycleRegistry # forwardPass()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">forwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过iteratorWithAdditions去安全的并在遍历时能遍历到所有新增的元素的遍历方式去遍历mObservers集合</span></span><br><span class="line">    Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator =</span><br><span class="line">            mObserverMap.iteratorWithAdditions();</span><br><span class="line">    <span class="keyword">while</span> (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next();</span><br><span class="line">        <span class="type">ObserverWithState</span> <span class="variable">observer</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        <span class="comment">// 向上传递事件，直到 observer 的状态值等于当前状态值</span></span><br><span class="line">        <span class="keyword">while</span> ((observer.mState.compareTo(mState) &lt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">            <span class="comment">// 和addObserver中一样的操作</span></span><br><span class="line">            <span class="comment">// 先临时保存</span></span><br><span class="line">            pushParentState(observer.mState);</span><br><span class="line">            <span class="comment">// 分发事件</span></span><br><span class="line">            observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState));</span><br><span class="line">            <span class="comment">// 移除</span></span><br><span class="line">            popParentState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * upEvent()</span></span><br><span class="line"><span class="comment"> * state升级所需要经历的事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Event <span class="title function_">upEvent</span><span class="params">(State state)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">        <span class="keyword">case</span> DESTROYED:</span><br><span class="line">            <span class="keyword">return</span> ON_CREATE;</span><br><span class="line">        <span class="keyword">case</span> CREATED:</span><br><span class="line">            <span class="keyword">return</span> ON_START;</span><br><span class="line">        <span class="keyword">case</span> STARTED:</span><br><span class="line">            <span class="keyword">return</span> ON_RESUME;</span><br><span class="line">        <span class="keyword">case</span> RESUMED:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unexpected state value &quot;</span> + state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这块我们就差不多能理解他的一个流程了，假设我们上面的流程是从<code>ON_CREATE</code>到<code>ON_RESUME</code>，那么这个流程就是：</p>
<ol>
<li>ReportFragment通过监听生命周期变化，调用了<code>dispatch(Lifecycle.Event.ON_RESUME)</code>；</li>
<li>在<code>dispatch()</code>中则执行了LifecycleRegistry的<code>handleLifecycleEvent()</code>方法，参数是<code>ON_RESUME</code>；</li>
<li>通过<code>getStateAfter()</code>返回<code>RESUMED</code>，在调用<code>moveToState()</code>跳转到<code>RESUMED</code>；</li>
<li>这时将<code>mSate</code>更新为<code>RESUMED</code>，然后调用<code>sync()</code>方法</li>
<li>在<code>sync()</code>方法中，由于<code>mSate</code>是<code>RESUMED</code>状态，而<code>mObserverMap</code>中的状态都是<code>STARTED</code>，那么<code>mState</code>大于<code>mObserverMap</code>，就执行<code>forwardPass()</code>方法</li>
<li>最后就会调用<code>observer.dispatchEvent()</code>去分发事件</li>
</ol>
<h3 id="2-2-6-LifecycleRegistry-backwardPass"><a href="#2-2-6-LifecycleRegistry-backwardPass" class="headerlink" title="2.2.6 LifecycleRegistry # backwardPass()"></a>2.2.6 LifecycleRegistry # backwardPass()</h3><p>刚刚看完了上面的代码和流程，那么既然有<code>forwardPass()</code>，对应的<code>backwardPass()</code>有啥作用呢？</p>
<p>我们还是假设一下流程，我们刚刚说到了<code>ON_RESUME</code>，那么我们假设从<code>ON_RESUME</code>到<code>ON_PAUSE</code>，再来看一下刚刚的流程，和刚刚的流程一样的：</p>
<ol>
<li>ReportFragment通过监听生命周期变化，调用了<code>dispatch(Lifecycle.Event.ON_PAUSE)</code>；</li>
<li>在<code>dispatch()</code>中则执行了LifecycleRegistry的<code>handleLifecycleEvent()</code>方法，参数是<code>ON_PAUSE</code>；</li>
<li>通过<code>getStateAfter()</code>返回<code>STARTED</code>，在调用<code>moveToState()</code>跳转到<code>STARTED</code>；</li>
<li>这时将<code>mSate</code>更新为<code>STARTED</code>，然后调用<code>sync()</code>方法</li>
<li>在<code>sync()</code>方法中，由于<code>mSate</code>是<code>STARTED</code>状态，而<code>mObserverMap</code>中的状态都是<code>RESUMED</code>，那么<code>mState</code>小于<code>mObserverMap</code>，就执行<code>backwardPass()</code>方法</li>
<li>最后就会调用<code>observer.dispatchEvent()</code>去分发事件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 和 forwardPass() 差不多</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> &#123;</span><br><span class="line">    Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator =</span><br><span class="line">            mObserverMap.descendingIterator();</span><br><span class="line">    <span class="keyword">while</span> (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next();</span><br><span class="line">        <span class="type">ObserverWithState</span> <span class="variable">observer</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        <span class="keyword">while</span> ((observer.mState.compareTo(mState) &gt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="type">Event</span> <span class="variable">event</span> <span class="operator">=</span> downEvent(observer.mState);</span><br><span class="line">            pushParentState(getStateAfter(event));</span><br><span class="line">            observer.dispatchEvent(lifecycleOwner, event);</span><br><span class="line">            popParentState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * downEvent()</span></span><br><span class="line"><span class="comment"> * state降级所需经历的事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Event <span class="title function_">downEvent</span><span class="params">(State state)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">case</span> CREATED:</span><br><span class="line">            <span class="keyword">return</span> ON_DESTROY;</span><br><span class="line">        <span class="keyword">case</span> STARTED:</span><br><span class="line">            <span class="keyword">return</span> ON_STOP;</span><br><span class="line">        <span class="keyword">case</span> RESUMED:</span><br><span class="line">            <span class="keyword">return</span> ON_PAUSE;</span><br><span class="line">        <span class="keyword">case</span> DESTROYED:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unexpected state value &quot;</span> + state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是事件分发的过程。</p>
<p>那么剩下最后一个问题，怎么执行回调方法？</p>
<h1 id="3-执行回调"><a href="#3-执行回调" class="headerlink" title="3. 执行回调"></a>3. 执行回调</h1><p>其实这块我们刚刚已经提到过了，那就是在<code>sync()</code>方法中会调用<code>forwardPass()</code>和<code>backwardPass()</code>方法，这两个方法中都会调用<code>observer.dispatchEvent(lifecycleOwner, event)</code>方法，所以我们就从这个入手。</p>
<p>首先我们回顾下，我们添加进去的<code>observer</code>到底是谁？<br>回到<code>addObserver()</code>方法，在这个方法内部的第二行和第三行：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObserverWithState</span> <span class="variable">statefulObserver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObserverWithState</span>(observer, initialState);</span><br><span class="line"><span class="type">ObserverWithState</span> <span class="variable">previous</span> <span class="operator">=</span> mObserverMap.putIfAbsent(observer, statefulObserver);</span><br></pre></td></tr></table></figure><br>可以看到我们取出来的<code>observer</code>其实就是这块的这个<code>statefulObserver</code>，他是调用了ObserverWithState的构造方法构造出来的，并且我们后面也是调用的他的<code>dispatchEvent()</code>方法，那我们就直接来看一下这个类：</p>
<h2 id="3-1-ObserverWithState"><a href="#3-1-ObserverWithState" class="headerlink" title="3.1 ObserverWithState"></a>3.1 ObserverWithState</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ObserverWithState</span> &#123;</span><br><span class="line">    State mState;</span><br><span class="line">    LifecycleEventObserver mLifecycleObserver;</span><br><span class="line"></span><br><span class="line">    ObserverWithState(LifecycleObserver observer, State initialState) &#123;</span><br><span class="line">        mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);</span><br><span class="line">        mState = initialState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> &#123;</span><br><span class="line">        <span class="type">State</span> <span class="variable">newState</span> <span class="operator">=</span> getStateAfter(event);</span><br><span class="line">        mState = min(mState, newState);</span><br><span class="line">        mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">        mState = newState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个源码可以看到，它里面有两个参数，一个是<code>mSate</code>，这个就是这个Observer当前的状态，另一个就是<code>mLifecycleObserver</code>，这个也就是我们传入的Observer，但是他并不是直接拿着我们传入的<code>observer</code>使用，而是调用<code>Lifecycling.lifecycleEventObserver()</code>返回了一个值，那我们看一下这个方法到底是啥：</p>
<h3 id="3-1-1-Lifecycling"><a href="#3-1-1-Lifecycling" class="headerlink" title="3.1.1 Lifecycling"></a>3.1.1 Lifecycling</h3><h4 id="3-1-1-1-Lifecycling-lifecycleEventObserver"><a href="#3-1-1-1-Lifecycling-lifecycleEventObserver" class="headerlink" title="3.1.1.1 Lifecycling # lifecycleEventObserver()"></a>3.1.1.1 Lifecycling # lifecycleEventObserver()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">static</span> LifecycleEventObserver <span class="title function_">lifecycleEventObserver</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是不是这两种类型的对象</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLifecycleEventObserver</span> <span class="operator">=</span> object <span class="keyword">instanceof</span> LifecycleEventObserver;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isFullLifecycleObserver</span> <span class="operator">=</span> object <span class="keyword">instanceof</span> FullLifecycleObserver;</span><br><span class="line">    <span class="comment">// 判断是哪种，返回对应的</span></span><br><span class="line">    <span class="comment">// 但是我们是构造的LifecycleObserver的子类，所以不满足下面这三种if</span></span><br><span class="line">    <span class="keyword">if</span> (isLifecycleEventObserver &amp;&amp; isFullLifecycleObserver) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FullLifecycleObserverAdapter</span>((FullLifecycleObserver) object,</span><br><span class="line">                (LifecycleEventObserver) object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isFullLifecycleObserver) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FullLifecycleObserverAdapter</span>((FullLifecycleObserver) object, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isLifecycleEventObserver) &#123;</span><br><span class="line">        <span class="keyword">return</span> (LifecycleEventObserver) object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得到他的class对象</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; klass = object.getClass();</span><br><span class="line">    <span class="comment">// -&gt;&gt;&gt; 备注1</span></span><br><span class="line">    <span class="comment">// 获取 type</span></span><br><span class="line">    <span class="comment">//   GENERATED_CALLBACK 表示注解生成的代码</span></span><br><span class="line">    <span class="comment">//   REFLECTIVE_CALLBACK 表示使用反射</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> getObserverConstructorType(klass);</span><br><span class="line">    <span class="keyword">if</span> (type == GENERATED_CALLBACK) &#123;</span><br><span class="line">        List&lt;Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">GeneratedAdapter</span>&gt;&gt; constructors =</span><br><span class="line">                sClassToAdapters.get(klass);</span><br><span class="line">        <span class="keyword">if</span> (constructors.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">GeneratedAdapter</span> <span class="variable">generatedAdapter</span> <span class="operator">=</span> createGeneratedAdapter(</span><br><span class="line">                    constructors.get(<span class="number">0</span>), object);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SingleGeneratedAdapterObserver</span>(generatedAdapter);</span><br><span class="line">        &#125;</span><br><span class="line">        GeneratedAdapter[] adapters = <span class="keyword">new</span> <span class="title class_">GeneratedAdapter</span>[constructors.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; constructors.size(); i++) &#123;</span><br><span class="line">            adapters[i] = createGeneratedAdapter(constructors.get(i), object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CompositeGeneratedAdaptersObserver</span>(adapters);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReflectiveGenericLifecycleObserver</span>(object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 备注1</span></span><br><span class="line"><span class="comment"> * 返回构造方法的类型</span></span><br><span class="line"><span class="comment"> *   先从缓存(sCallbackCache)中找，有则直接返回</span></span><br><span class="line"><span class="comment"> *   没有则调用resolveObserverCallbackType方法获取并将结果缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getObserverConstructorType</span><span class="params">(Class&lt;?&gt; klass)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断缓存里面有没有，如果有则直接返回</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">callbackCache</span> <span class="operator">=</span> sCallbackCache.get(klass);</span><br><span class="line">    <span class="keyword">if</span> (callbackCache != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> callbackCache;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// -&gt;&gt;&gt; 备注2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> resolveObserverCallbackType(klass);</span><br><span class="line">    sCallbackCache.put(klass, type);</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 备注2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">resolveObserverCallbackType</span><span class="params">(Class&lt;?&gt; klass)</span> &#123;</span><br><span class="line">    <span class="comment">// anonymous class bug:35073837</span></span><br><span class="line">    <span class="comment">// 获得包名，如果为null，则是匿名内部类</span></span><br><span class="line">    <span class="keyword">if</span> (klass.getCanonicalName() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 对应返回，表示使用反射</span></span><br><span class="line">        <span class="keyword">return</span> REFLECTIVE_CALLBACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找注解生成的 GeneratedAdapter 类</span></span><br><span class="line">    Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">GeneratedAdapter</span>&gt; constructor = generatedConstructor(klass);</span><br><span class="line">    <span class="keyword">if</span> (constructor != <span class="literal">null</span>) &#123;</span><br><span class="line">        sClassToAdapters.put(klass, Collections</span><br><span class="line">                .&lt;Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">GeneratedAdapter</span>&gt;&gt;singletonList(constructor));</span><br><span class="line">        <span class="keyword">return</span> GENERATED_CALLBACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找被OnLifecycleEvent注解的方法</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasLifecycleMethods</span> <span class="operator">=</span> ClassesInfoCache.sInstance.hasLifecycleMethods(klass);</span><br><span class="line">    <span class="keyword">if</span> (hasLifecycleMethods) &#123;</span><br><span class="line">        <span class="keyword">return</span> REFLECTIVE_CALLBACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有找到注解生成的 GeneratedAdapter 类，也没有找到 OnLifecycleEvent 注解，</span></span><br><span class="line">    <span class="comment">// 则向上寻找父类</span></span><br><span class="line">    Class&lt;?&gt; superclass = klass.getSuperclass();</span><br><span class="line">    List&lt;Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">GeneratedAdapter</span>&gt;&gt; adapterConstructors = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isLifecycleParent(superclass)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getObserverConstructorType(superclass) == REFLECTIVE_CALLBACK) &#123;</span><br><span class="line">            <span class="keyword">return</span> REFLECTIVE_CALLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">        adapterConstructors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(sClassToAdapters.get(superclass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找是否有接口实现</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intrface : klass.getInterfaces()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isLifecycleParent(intrface)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getObserverConstructorType(intrface) == REFLECTIVE_CALLBACK) &#123;</span><br><span class="line">            <span class="keyword">return</span> REFLECTIVE_CALLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (adapterConstructors == <span class="literal">null</span>) &#123;</span><br><span class="line">            adapterConstructors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        adapterConstructors.addAll(sClassToAdapters.get(intrface));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (adapterConstructors != <span class="literal">null</span>) &#123;</span><br><span class="line">        sClassToAdapters.put(klass, adapterConstructors);</span><br><span class="line">        <span class="keyword">return</span> GENERATED_CALLBACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REFLECTIVE_CALLBACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中我们需要注意的是<code>hasLifecycleMethods</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">hasLifecycleMethods</span><span class="params">(Class klass)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">hasLifecycleMethods</span> <span class="operator">=</span> mHasLifecycleMethods.get(klass);</span><br><span class="line">    <span class="keyword">if</span> (hasLifecycleMethods != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> hasLifecycleMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method[] methods = getDeclaredMethods(klass);</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="type">OnLifecycleEvent</span> <span class="variable">annotation</span> <span class="operator">=</span> method.getAnnotation(OnLifecycleEvent.class);</span><br><span class="line">        <span class="keyword">if</span> (annotation != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Optimization for reflection, we know that this method is called</span></span><br><span class="line">            <span class="comment">// when there is no generated adapter. But there are methods with @OnLifecycleEvent</span></span><br><span class="line">            <span class="comment">// so we know that will use ReflectiveGenericLifecycleObserver,</span></span><br><span class="line">            <span class="comment">// so we createInfo in advance.</span></span><br><span class="line">            <span class="comment">// CreateInfo always initialize mHasLifecycleMethods for a class, so we don&#x27;t do it</span></span><br><span class="line">            <span class="comment">// here.</span></span><br><span class="line">            createInfo(klass, methods);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mHasLifecycleMethods.put(klass, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个代码就没啥好说的，单纯通过反射去找OnLifecycleEvent注解，所以综上所述，我们通过OnLifecycleEvent注解实现的Observer则返回的是<code>REFLECTIVE_CALLBACK</code>类型，对应的<code>lifecycleEventObserver()</code>方法返回的也是<code>new ReflectiveGenericLifecycleObserver(observer)</code>。</p>
<h3 id="3-1-2-ReflectiveGenericLifecycleObserver"><a href="#3-1-2-ReflectiveGenericLifecycleObserver" class="headerlink" title="3.1.2 ReflectiveGenericLifecycleObserver"></a>3.1.2 ReflectiveGenericLifecycleObserver</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectiveGenericLifecycleObserver</span> <span class="keyword">implements</span> <span class="title class_">LifecycleEventObserver</span> &#123;</span><br><span class="line">    <span class="comment">// 我们传入的observer对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object mWrapped;</span><br><span class="line">    <span class="comment">// 通过反射从这个observer对象中获取的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallbackInfo mInfo;</span><br><span class="line"></span><br><span class="line">    ReflectiveGenericLifecycleObserver(Object wrapped) &#123;</span><br><span class="line">        mWrapped = wrapped;</span><br><span class="line">        <span class="comment">// 通过反射来获取信息，但是代码太长，也很简单，就不详细去说了</span></span><br><span class="line">        mInfo = ClassesInfoCache.sInstance.getInfo(mWrapped.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStateChanged</span><span class="params">(LifecycleOwner source, Event event)</span> &#123;</span><br><span class="line">        mInfo.invokeCallbacks(source, event, mWrapped);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而我们之前的<code>observer.dispatchEvent()</code>方法中实际上调用的是<code>mLifecycleObserver.onStateChanged(owner, event)</code>，所以最后会交给ReflectiveGenericLifecycleObserver的<code>onStateChanged()</code>方法来执行，而这个方法中又调用了<code>mInfo.invokeCallbacks()</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">invokeCallbacks</span><span class="params">(LifecycleOwner source, Lifecycle.Event event, Object target)</span> &#123;</span><br><span class="line">    invokeMethodsForEvent(mEventToHandlers.get(event), source, event, target);</span><br><span class="line">    invokeMethodsForEvent(mEventToHandlers.get(Lifecycle.Event.ON_ANY), source, event,</span><br><span class="line">            target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeMethodsForEvent</span><span class="params">(List&lt;MethodReference&gt; handlers,</span></span><br><span class="line"><span class="params">        LifecycleOwner source, Lifecycle.Event event, Object mWrapped)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (handlers != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> handlers.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            handlers.get(i).invokeCallback(source, event, mWrapped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">invokeCallback</span><span class="params">(LifecycleOwner source, Lifecycle.Event event, Object target)</span> &#123;</span><br><span class="line">    <span class="comment">//noinspection TryWithIdenticalCatches</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (mCallType) &#123;</span><br><span class="line">            <span class="keyword">case</span> CALL_TYPE_NO_ARG:</span><br><span class="line">                mMethod.invoke(target);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CALL_TYPE_PROVIDER:</span><br><span class="line">                mMethod.invoke(target, source);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CALL_TYPE_PROVIDER_WITH_EVENT:</span><br><span class="line">                mMethod.invoke(target, source, event);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failed to call observer method&quot;</span>, e.getCause());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个代码就很简单了，就是利用反射去执行。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Jetpack</tag>
        <tag>Lifecycle</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack源码 之 ViewModel</title>
    <url>/posts/b309316d.html</url>
    <content><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>ViewModel作为MVVM中最重要的一层，他的作用就是对数据状态的持有与维护。</p>
<p>根据源码里面的注释，我们可以知道，它在Android中事实上是为了解决一下两个问题：</p>
<ul>
<li>UI组件间实现数据共享</li>
<li>Activity配置更改重建时保留数据</li>
</ul>
<p>对于第一条，如果不同VM，那么各个UI组件都需要持有共享数据的引用，这样会带来两个麻烦：</p>
<ul>
<li>如果新增共享数据，则各个UI组件需要再次声明并初始化新增的共享数据</li>
<li>某个组件对于数据的修改，没办法直接通知其他UI组件，需手动实现观察者模式</li>
</ul>
<p>对于第二条，如果不使用VM，那么还是可以通过onSaveInstanceState保存的，但是如果数据量比较大，数据的序列化和反序列化都会产生一定的性能开销。</p>
<p>所以我们看ViewModel的源码，就需要从这两个问题入手：</p>
<ul>
<li>ViewModel是如何解决UI组件间共享数据的</li>
<li>ViewModel是怎么解决重建时保留数据的</li>
</ul>
<h1 id="1-ViewModel是什么"><a href="#1-ViewModel是什么" class="headerlink" title="1. ViewModel是什么"></a>1. ViewModel是什么</h1><p>我们直接看下源码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ViewModel</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; mBagOfTags = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 用于标记当前ViewModel是否已经不再被使用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">mCleared</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法会在ViewModel不再被使用并且即将被销毁时调用</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCleared</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注释里面写到：</span></span><br><span class="line">    <span class="comment">//   由于clear()方法是final的，所以这个方法仍然会被在模拟对象中被调用，</span></span><br><span class="line">    <span class="comment">//   并且在这种情况下，mBagOfTags为null</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        mCleared = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mBagOfTags != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mBagOfTags) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Object value : mBagOfTags.values()) &#123;</span><br><span class="line">                    closeWithRuntimeException(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        onCleared();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">setTagIfAbsent</span><span class="params">(String key, T newValue)</span> &#123;</span><br><span class="line">        T previous;</span><br><span class="line">        <span class="comment">// 当当前key不存在时才将数据保存进去</span></span><br><span class="line">        <span class="comment">// 类似于ConcurrentHashMap的 putIfAbsent()</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mBagOfTags) &#123;</span><br><span class="line">            previous = (T) mBagOfTags.get(key);</span><br><span class="line">            <span class="keyword">if</span> (previous == <span class="literal">null</span>) &#123;</span><br><span class="line">                mBagOfTags.put(key, newValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> previous == <span class="literal">null</span> ? newValue : previous;</span><br><span class="line">        <span class="comment">// 当mCleared时，异常</span></span><br><span class="line">        <span class="keyword">if</span> (mCleared) &#123;</span><br><span class="line">            closeWithRuntimeException(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;TypeParameterUnusedInFormals&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">getTag</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mBagOfTags == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (mBagOfTags) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) mBagOfTags.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeWithRuntimeException</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Closeable) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((Closeable) obj).close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面基本上对ViewModel这个抽象类有了一个大致的了解，那接下来我们来看下ViewModel是如何被创建的。</p>
<h1 id="2-ViewModel的创建"><a href="#2-ViewModel的创建" class="headerlink" title="2. ViewModel的创建"></a>2. ViewModel的创建</h1><p>一般情况下，我们都会通过这个代码创建ViewModel：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">mViewModel = ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(MvvmViewModel::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure></p>
<p>这里的this要求传入ViewModelStoreOwner，一般我们的Activity和Fragment都实现了这个接口。我们来看下这个ViewModelProvider的构造方法：</p>
<h2 id="2-1-ViewModelProvider"><a href="#2-1-ViewModelProvider" class="headerlink" title="2.1 ViewModelProvider"></a>2.1 ViewModelProvider</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ViewModelProvider</span><span class="params">(<span class="meta">@NonNull</span> ViewModelStoreOwner owner)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(owner.getViewModelStore(), owner <span class="keyword">instanceof</span> HasDefaultViewModelProviderFactory</span><br><span class="line">            ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory()</span><br><span class="line">            : NewInstanceFactory.getInstance());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ViewModelProvider</span><span class="params">(<span class="meta">@NonNull</span> ViewModelStoreOwner owner, <span class="meta">@NonNull</span> Factory factory)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(owner.getViewModelStore(), factory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ViewModelProvider</span><span class="params">(<span class="meta">@NonNull</span> ViewModelStore store, <span class="meta">@NonNull</span> Factory factory)</span> &#123;</span><br><span class="line">    mFactory = factory;</span><br><span class="line">    mViewModelStore = store;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注释1：ComponentActivity # getDefaultViewModelProviderFactory()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ViewModelProvider.Factory <span class="title function_">getDefaultViewModelProviderFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getApplication() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Your activity is not yet attached to the &quot;</span></span><br><span class="line">                + <span class="string">&quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mDefaultFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        mDefaultFactory = <span class="keyword">new</span> <span class="title class_">SavedStateViewModelFactory</span>(</span><br><span class="line">                getApplication(),</span><br><span class="line">                <span class="built_in">this</span>,</span><br><span class="line">                getIntent() != <span class="literal">null</span> ? getIntent().getExtras() : <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mDefaultFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注释2：Fragment # getDefaultViewModelProviderFactory()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ViewModelProvider.Factory <span class="title function_">getDefaultViewModelProviderFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mFragmentManager == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Can&#x27;t access ViewModels from detached fragment&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mDefaultFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Application</span> <span class="variable">application</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">appContext</span> <span class="operator">=</span> requireContext().getApplicationContext();</span><br><span class="line">        <span class="keyword">while</span> (appContext <span class="keyword">instanceof</span> ContextWrapper) &#123;</span><br><span class="line">            <span class="keyword">if</span> (appContext <span class="keyword">instanceof</span> Application) &#123;</span><br><span class="line">                application = (Application) appContext;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            appContext = ((ContextWrapper) appContext).getBaseContext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (application == <span class="literal">null</span> &amp;&amp; FragmentManager.isLoggingEnabled(Log.DEBUG)) &#123;</span><br><span class="line">            Log.d(FragmentManager.TAG, <span class="string">&quot;Could not find Application instance from &quot;</span></span><br><span class="line">                    + <span class="string">&quot;Context &quot;</span> + requireContext().getApplicationContext() + <span class="string">&quot;, you will &quot;</span></span><br><span class="line">                    + <span class="string">&quot;not be able to use AndroidViewModel with the default &quot;</span></span><br><span class="line">                    + <span class="string">&quot;ViewModelProvider.Factory&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mDefaultFactory = <span class="keyword">new</span> <span class="title class_">SavedStateViewModelFactory</span>(</span><br><span class="line">                application,</span><br><span class="line">                <span class="built_in">this</span>,</span><br><span class="line">                getArguments());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mDefaultFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们调用的是第一个构造方法，这个方法中调用了第三个构造方法，然后通过<code>getViewModelStore()</code>获取到了ViewModelStore，并判断我们这个<code>owner</code>是不是HasDefaultViewModelProviderFactory子类，如果是就调用HasDefaultViewModelProviderFactory的<code>getDefaultViewModelProviderFactory()</code>否则调用<code>NewInstanceFactory.getInstance()</code>。</p>
<blockquote>
<p>这块还是别看AndroidStudio自带的SDK的源码了，这个时候最新的源码是API30，但是ComponentActivity并没有实现HasDefaultViewModelProviderFactory，而从<a href="https://github.com/androidx/androidx/blob/androidx-master-dev/activity/activity/src/main/java/androidx/activity/ComponentActivity.java">官方Github</a>看到的源码是已经实现了的。</p>
</blockquote>
<p>而我们的Activity和Fragment都是实现了这个接口的。<br>他们的<code>getDefaultViewModelProviderFactory()</code>最后都创建了这样一个东西：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mDefaultFactory = <span class="keyword">new</span> <span class="title class_">SavedStateViewModelFactory</span>(</span><br><span class="line">        getApplication(),</span><br><span class="line">        <span class="built_in">this</span>,</span><br><span class="line">        getIntent() != <span class="literal">null</span> ? getIntent().getExtras() : <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>那我们再来看下<code>get()</code>方法：</p>
<h2 id="2-1-ViewModelProvider-get"><a href="#2-1-ViewModelProvider-get" class="headerlink" title="2.1 ViewModelProvider # get()"></a>2.1 ViewModelProvider # get()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过Class获取到他的类名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">canonicalName</span> <span class="operator">=</span> modelClass.getCanonicalName();</span><br><span class="line">    <span class="comment">// 如果没有名字，则证明是局部内部类或者匿名内部类，则抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (canonicalName == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Local and anonymous classes can not be ViewModels&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> get(DEFAULT_KEY + <span class="string">&quot;:&quot;</span> + canonicalName, modelClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">    <span class="comment">// 从ViewModelStore中取值，刚开始是取不到的，因为没有存内容</span></span><br><span class="line">    <span class="comment">// 如果是已经调用过get方法后再调用这个方法，这个时候是能取出值的</span></span><br><span class="line">    <span class="type">ViewModel</span> <span class="variable">viewModel</span> <span class="operator">=</span> mViewModelStore.get(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为第一次进入还没有值，那么这个时候取出的是null，isInstance也就返回false了</span></span><br><span class="line">    <span class="comment">// 如果是已经被缓存之后再调用的这个就能取出值，那么这个时候一般返回true</span></span><br><span class="line">    <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">        <span class="comment">// SavedStateViewModelFactory是OnRequeryFactory的孙类(子类的子类)</span></span><br><span class="line">        <span class="comment">// 所以返回true，进入if</span></span><br><span class="line">        <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> OnRequeryFactory) &#123;</span><br><span class="line">            <span class="comment">// 获取到ViewModel</span></span><br><span class="line">            ((OnRequeryFactory) mFactory).onRequery(viewModel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//noinspection StatementWithEmptyBody</span></span><br><span class="line">        <span class="keyword">if</span> (viewModel != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> KeyedFactory) &#123;</span><br><span class="line">        viewModel = ((KeyedFactory) (mFactory)).create(key, modelClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// create方法中通过反射的newInstance去创建对象</span></span><br><span class="line">        <span class="comment">// -&gt;&gt; 注释1</span></span><br><span class="line">        viewModel = (mFactory).create(modelClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存起来</span></span><br><span class="line">    mViewModelStore.put(key, viewModel);</span><br><span class="line">    <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注释1：NewInstanceFactory # create()</span></span><br><span class="line"><span class="comment"> * 作用：通过反射去创建对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">create</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> modelClass.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Cannot create an instance of &quot;</span> + modelClass, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Cannot create an instance of &quot;</span> + modelClass, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这块，我们的创建ViewModel就说完了，最后总结下：</p>
<ul>
<li>ViewModelStore是用来保存ViewModel对象的HashMap，Activity和Fragment都会构造这个的对象；</li>
<li>ViewModelProvider中会通过<code>get()</code>方法创建一个ViewModel，创建之前会检测ViewModelStore中有没有缓存了的，如果有直接返回，没有就通过反射去创建。</li>
</ul>
<h1 id="3-重建时如何保证ViewModel不会重建"><a href="#3-重建时如何保证ViewModel不会重建" class="headerlink" title="3. 重建时如何保证ViewModel不会重建"></a>3. 重建时如何保证ViewModel不会重建</h1><p>了解到VieModel的创建后，我们现在来看第一个问题：ViewModel是怎么解决重建时保留数据的？</p>
<p>我们回顾下刚刚创建的ViewModel的流程，在<code>get()</code>方法中主要是通过ViewModelStore来帮我们保存ViewModel的，那么ViewModelStore是怎么创建的？</p>
<h2 id="3-1-ViewModelStore的创建"><a href="#3-1-ViewModelStore的创建" class="headerlink" title="3.1 ViewModelStore的创建"></a>3.1 ViewModelStore的创建</h2><h3 id="3-1-1-Activity中"><a href="#3-1-1-Activity中" class="headerlink" title="3.1.1 Activity中"></a>3.1.1 Activity中</h3><p>在ComponentActivity中有<code>getViewModelStore()</code>这样的一个方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getApplication() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Your activity is not yet attached to the &quot;</span></span><br><span class="line">                + <span class="string">&quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mViewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">NonConfigurationInstances</span> <span class="variable">nc</span> <span class="operator">=</span></span><br><span class="line">                (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">        <span class="keyword">if</span> (nc != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过NonConfigurationInstances获取到ViewModelStore</span></span><br><span class="line">            mViewModelStore = nc.viewModelStore;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果获取不到，则新建一个ViewmodelStore</span></span><br><span class="line">        <span class="keyword">if</span> (mViewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">            mViewModelStore = <span class="keyword">new</span> <span class="title class_">ViewModelStore</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mViewModelStore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这块就涉及到了一个NonConfigurationInstances，而熟悉Activity重建机制的小伙伴应该会很熟悉这个，这个就是与我们的重建机制有关。</p>
<p>当我们需要重建Activity的时候，除了通过<code>onSaveInstanceState()</code>保存数据之外，也可以通过<code>onRetainNonConfigurationInstance()</code>这个方法：</p>
<h4 id="ComponentActivity-onRetainNonConfigurationInstance"><a href="#ComponentActivity-onRetainNonConfigurationInstance" class="headerlink" title="ComponentActivity # onRetainNonConfigurationInstance()"></a>ComponentActivity # onRetainNonConfigurationInstance()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">onRetainNonConfigurationInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">custom</span> <span class="operator">=</span> onRetainCustomNonConfigurationInstance();</span><br><span class="line"></span><br><span class="line">    <span class="type">ViewModelStore</span> <span class="variable">viewModelStore</span> <span class="operator">=</span> mViewModelStore;</span><br><span class="line">    <span class="keyword">if</span> (viewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是null，说明以前没有调用过 getViewModelStore()方法,</span></span><br><span class="line">        <span class="comment">// 也就是没有调用过ViewModelProvider(requireActivity()).get(DemoViewModel::class.java)的方法来获取ViewModel。</span></span><br><span class="line">        <span class="comment">// 所以我们看一下最后一个的NonConfigurationInstance里面是否存在viewModelStore</span></span><br><span class="line">        <span class="type">NonConfigurationInstances</span> <span class="variable">nc</span> <span class="operator">=</span></span><br><span class="line">                (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">        <span class="comment">// 如果nc 不等于null，就证明以前存储过，所以从这里取出来</span></span><br><span class="line">        <span class="keyword">if</span> (nc != <span class="literal">null</span>) &#123;</span><br><span class="line">            viewModelStore = nc.viewModelStore;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewModelStore == <span class="literal">null</span> &amp;&amp; custom == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果viewModelStore不是null，也就是说最后一个NonConfigurationInstance里面有值，直接new出来NonConfigurationInstances并赋值，返回出去</span></span><br><span class="line">    <span class="type">NonConfigurationInstances</span> <span class="variable">nci</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NonConfigurationInstances</span>();</span><br><span class="line">    nci.custom = custom;</span><br><span class="line">    nci.viewModelStore = viewModelStore;</span><br><span class="line">    <span class="keyword">return</span> nci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="那么onRetainNonConfigurationInstance-什么时候回被调用呢"><a href="#那么onRetainNonConfigurationInstance-什么时候回被调用呢" class="headerlink" title="那么onRetainNonConfigurationInstance()什么时候回被调用呢"></a>那么onRetainNonConfigurationInstance()什么时候回被调用呢</h4><p>在Activity的启动流程中，当ActivityThread执行到<code>performDestroyActivity()</code>这个方法时，就会调用Activity的<code>retainNonConfigurationInstances()</code>方法将保存的数据保存到ActivityClientRecord中：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NonConfigurationInstances <span class="title function_">retainNonConfigurationInstances</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用了 onRetainNonConfigurationInstance() 获取到 NonConfigurationInstances</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">activity</span> <span class="operator">=</span> onRetainNonConfigurationInstance();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">NonConfigurationInstances</span> <span class="variable">nci</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NonConfigurationInstances</span>();</span><br><span class="line">    nci.activity = activity;</span><br><span class="line">    nci.children = children;</span><br><span class="line">    nci.fragments = fragments;</span><br><span class="line">    nci.loaders = loaders;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> nci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到他先调用<code>onRetainNonConfigurationInstance()</code>获取到ComponentActivity返回来的<code>nci</code>，然后由构建了一个<code>nci</code>，并将之前ComponentActivity的那个<code>nci</code>保存到了这个<code>nci</code>的<code>activity</code>中。</p>
<h4 id="ActivityThread-performDestroyActivity-保存nci"><a href="#ActivityThread-performDestroyActivity-保存nci" class="headerlink" title="ActivityThread # performDestroyActivity() 保存nci"></a>ActivityThread # performDestroyActivity() 保存nci</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ActivityClientRecord <span class="title function_">performDestroyActivity</span><span class="params">(IBinder token, <span class="type">boolean</span> finishing,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> configChanges, <span class="type">boolean</span> getNonConfigInstance, String reason)</span> &#123;</span><br><span class="line">    <span class="type">ActivityClientRecord</span> <span class="variable">r</span> <span class="operator">=</span> mActivities.get(token);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (getNonConfigInstance) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                r.lastNonConfigurationInstances</span><br><span class="line">                        = r.activity.retainNonConfigurationInstances();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                            <span class="string">&quot;Unable to retain activity &quot;</span></span><br><span class="line">                            + r.intent.getComponent().toShortString()</span><br><span class="line">                            + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="那么什么时候恢复呢"><a href="#那么什么时候恢复呢" class="headerlink" title="那么什么时候恢复呢"></a>那么什么时候恢复呢</h4><p>当页面重构完成，就会调用ActivityThread的<code>performLaunchActivity()</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Activity <span class="title function_">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">            activity.attach(appContext, <span class="built_in">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback,</span><br><span class="line">                    r.assistToken);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Activity-attach"><a href="#Activity-attach" class="headerlink" title="Activity # attach()"></a>Activity # attach()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span><br><span class="line"><span class="params">        Instrumentation instr, IBinder token, <span class="type">int</span> ident,</span></span><br><span class="line"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span><br><span class="line"><span class="params">        CharSequence title, Activity parent, String id,</span></span><br><span class="line"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span><br><span class="line"><span class="params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">        Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mLastNonConfigurationInstances = lastNonConfigurationInstances;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这块就将值赋给了Activity的<code>mLastNonConfigurationInstances</code>。</p>
<p>然后我们在回到3.1.1节的<code>getViewModelStore()</code>方法中，如果调用<code>getLastNonConfigurationInstance()</code>返回的<code>nc</code>不为null的话，就直接取出他的<code>viewModelStore</code>，这样我们不就实现了Activity重建但是ViewModel仍然不会重建的问题嘛。</p>
<h3 id="3-1-2-Fragment中"><a href="#3-1-2-Fragment中" class="headerlink" title="3.1.2 Fragment中"></a>3.1.2 Fragment中</h3><p>一样的，也来看下Fragment的<code>getViewModelStore()</code>方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mFragmentManager == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Can&#x27;t access ViewModels from detached fragment&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mFragmentManager.getViewModelStore(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到他里面调用了FragmentManager的<code>getViewModelStore()</code>方法:</p>
<h4 id="FragmentManagerImpl-getViewModelStore"><a href="#FragmentManagerImpl-getViewModelStore" class="headerlink" title="FragmentManagerImpl # getViewModelStore()"></a>FragmentManagerImpl # getViewModelStore()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">(<span class="meta">@NonNull</span> Fragment f)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mNonConfig.getViewModelStore(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面直接调用了mNonConfig的getViewModelStore方法。</p>
<p>那么这个mNonConfig是个啥呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> FragmentManagerViewModel mNonConfig;</span><br></pre></td></tr></table></figure>
<p>就是一个FragmentManagerViewModel，那么他是在哪赋值的：</p>
<h4 id="FragmentManagerImpl-attachController"><a href="#FragmentManagerImpl-attachController" class="headerlink" title="FragmentManagerImpl # attachController()"></a>FragmentManagerImpl # attachController()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attachController</span><span class="params">(<span class="meta">@NonNull</span> FragmentHostCallback host,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> FragmentContainer container, <span class="meta">@Nullable</span> <span class="keyword">final</span> Fragment parent)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 当parent不为null时，就获取到他的FragmentManager的getChildNonConfig</span></span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        mNonConfig = parent.mFragmentManager.getChildNonConfig(parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (host <span class="keyword">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class="line">        <span class="comment">// 一般都会进入到这个分支中，执行下面代码</span></span><br><span class="line">        <span class="type">ViewModelStore</span> <span class="variable">viewModelStore</span> <span class="operator">=</span> ((ViewModelStoreOwner) host).getViewModelStore();</span><br><span class="line">        mNonConfig = FragmentManagerViewModel.getInstance(viewModelStore);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mNonConfig = <span class="keyword">new</span> <span class="title class_">FragmentManagerViewModel</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中就是根据不同的分支返回不同的mNonConfig，而这个方法则会被FragmentController的attachHost调用:</p>
<h4 id="FragmentController-attachHost"><a href="#FragmentController-attachHost" class="headerlink" title="FragmentController # attachHost()"></a>FragmentController # attachHost()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attachHost</span><span class="params">(<span class="meta">@Nullable</span> Fragment parent)</span> &#123;</span><br><span class="line">    mHost.mFragmentManager.attachController(</span><br><span class="line">            mHost, mHost <span class="comment">/*container*/</span>, parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这个方法接着会被FragmetActivity中的onCreate调用。</p>
<h4 id="FragmentActivity-onCreate"><a href="#FragmentActivity-onCreate" class="headerlink" title="FragmentActivity # onCreate()"></a>FragmentActivity # onCreate()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    mFragments.attachHost(<span class="literal">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而attachHost中的那个host则是在FragmentController构造方法中传入的：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">FragmentController</span><span class="params">(FragmentHostCallback&lt;?&gt; callbacks)</span> &#123;</span><br><span class="line">    mHost = callbacks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> FragmentController <span class="title function_">createController</span><span class="params">(<span class="meta">@NonNull</span> FragmentHostCallback&lt;?&gt; callbacks)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FragmentController</span>(checkNotNull(callbacks, <span class="string">&quot;callbacks == null&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">FragmentController</span> <span class="variable">mFragments</span> <span class="operator">=</span> FragmentController.createController(<span class="keyword">new</span> <span class="title class_">HostCallbacks</span>());</span><br></pre></td></tr></table></figure></p>
<p>而这个HostCallbacks则实现了ViewModelStoreOwner：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HostCallbacks</span> <span class="keyword">extends</span> <span class="title class_">FragmentHostCallback</span>&lt;FragmentActivity&gt; <span class="keyword">implements</span></span><br><span class="line">        <span class="title class_">ViewModelStoreOwner</span>,</span><br><span class="line">        OnBackPressedDispatcherOwner &#123;</span><br></pre></td></tr></table></figure></p>
<h1 id="4-UI组件间数据共享"><a href="#4-UI组件间数据共享" class="headerlink" title="4. UI组件间数据共享"></a>4. UI组件间数据共享</h1><p>只要我们在调用<code>ViewModelProvider(this).get(MvvmViewModel::class.java)</code>时传入的this是同一个，那么就能获取到同一个ViewModelStore，对应的返回的ViewModel也是同一个了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
        <tag>ViewModel</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin Anko入门</title>
    <url>/posts/62bb1dd7.html</url>
    <content><![CDATA[<h1 id="Kotlin-Anko入门"><a href="#Kotlin-Anko入门" class="headerlink" title="Kotlin Anko入门"></a>Kotlin Anko入门</h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Anko的官网就是他的GitHub地址</p>
<blockquote>
<p><a href="https://github.com/Kotlin/anko">https://github.com/Kotlin/anko</a></p>
</blockquote>
<p>官方对Anko的解释是</p>
<blockquote>
<p>Anko是一个 <a href="https://www.kotlinlang.org/">Kotlin</a> 库，它使Android应用程序开发更快更容易。它使您的代码清晰易读，让您忘记Android SDK for Java的粗糙边缘。</p>
</blockquote>
<span id="more"></span>
<p>为什么这样说呢？<br>比方说如果你写Android，你在xml中定义了一个<code>Button</code>，他的ID是<code>button_login</code>。<br>如果是Java：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setContentView(R.layout.activity_words_detail);</span><br><span class="line"><span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> findViewById(R.Id.button_login);</span><br></pre></td></tr></table></figure><br>而如果你使用kotlin的话，你可以就按如下代码写<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_kotlin_main.*</span><br><span class="line">...</span><br><span class="line">button_login.setText(<span class="string">&quot;Kotlin Android Extensions 我不太喜欢&quot;</span>);</span><br></pre></td></tr></table></figure><br>这样确实比Java方便多了，不需要对每一个组件都定义再findViewById，可以就直接输入组件的id然后就能使用了。但是我们还是觉得不够啊，为什么我们不能就直接在代码中写入各个组件呢，于是，Anko来了。</p>
<h1 id="导入Anko"><a href="#导入Anko" class="headerlink" title="导入Anko"></a>导入Anko</h1><p>Anko由几部分组成：</p>
<ul>
<li><em>Anko Commons</em>：一个轻量级的库，包含用于Layouts，Intent，Log等的帮助程序;</li>
<li><em>Anko Layouts</em>：一种快速且类型安全的方式来编写动态Android布局;</li>
<li><em>Anko SQLite</em>：Android SQLite的查询DSL和解析器集合;</li>
<li><em>Anko Coroutines</em>：基于<a href="https://github.com/Kotlin/kotlinx.coroutines">kotlinx.coroutines</a>库的实用程序。</li>
</ul>
<p>你可以在app的<code>build.gradle</code>中添加<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">     <span class="comment">// Anko Layouts</span></span><br><span class="line">    implementation <span class="string">&quot;org.jetbrains.anko:anko-sdk25:$anko_version&quot;</span> <span class="comment">// sdk15, sdk19, sdk21, sdk23 are also available</span></span><br><span class="line">    implementation <span class="string">&quot;org.jetbrains.anko:anko-appcompat-v7:$anko_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Coroutine listeners for Anko Layouts</span></span><br><span class="line">    implementation <span class="string">&quot;org.jetbrains.anko:anko-sdk25-coroutines:$anko_version&quot;</span></span><br><span class="line">    implementation <span class="string">&quot;org.jetbrains.anko:anko-appcompat-v7-coroutines:$anko_version&quot;</span>&#125;</span><br></pre></td></tr></table></figure><br>这个依赖可以直接导入所有的可用特性（包括Commons, Layouts, SQLite)。</p>
<h1 id="使用Anko-layout"><a href="#使用Anko-layout" class="headerlink" title="使用Anko layout"></a>使用Anko layout</h1><h2 id="创建简单布局"><a href="#创建简单布局" class="headerlink" title="创建简单布局"></a>创建简单布局</h2><p>使用Anko创建布局很简单：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        verticalLayout &#123;</span><br><span class="line">            padding = dip(<span class="number">30</span>)</span><br><span class="line">            editText &#123;</span><br><span class="line">                hint = <span class="string">&quot;Name&quot;</span></span><br><span class="line">                textSize = <span class="number">24f</span></span><br><span class="line">            &#125;</span><br><span class="line">            editText &#123;</span><br><span class="line">                hint = <span class="string">&quot;Password&quot;</span></span><br><span class="line">                textSize = <span class="number">24f</span></span><br><span class="line">            &#125;</span><br><span class="line">            button(<span class="string">&quot;登录&quot;</span>) &#123;</span><br><span class="line">                textSize = <span class="number">26f</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你只需要在Activity中写入DSL代码就能使用它。</p>
<h2 id="AnkoComponent"><a href="#AnkoComponent" class="headerlink" title="AnkoComponent"></a>AnkoComponent</h2><p>尽管我们现在可以直接在Activity中写入DSL代码，但是我们还是觉得把代码和布局文件放在一起不太好，希望把Activity和DSl代码放到两个不同的类里面，所以AnkoComponent就出来了。<br>代码如下<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        MainActivityUI().setContentView(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivityUI</span> : <span class="type">AnkoComponent</span>&lt;<span class="type">MainActivity</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createView</span><span class="params">(ui: <span class="type">AnkoContext</span>&lt;<span class="type">MainActivity</span>&gt;)</span></span> = with(ui) &#123;</span><br><span class="line">        verticalLayout &#123;</span><br><span class="line">            padding = dip(<span class="number">30</span>)</span><br><span class="line">            editText &#123;</span><br><span class="line">                hint = <span class="string">&quot;Name&quot;</span></span><br><span class="line">                textSize = <span class="number">24f</span></span><br><span class="line">            &#125;</span><br><span class="line">            editText &#123;</span><br><span class="line">                hint = <span class="string">&quot;Password&quot;</span></span><br><span class="line">                textSize = <span class="number">24f</span></span><br><span class="line">            &#125;</span><br><span class="line">            button(<span class="string">&quot;登录&quot;</span>) &#123;</span><br><span class="line">                textSize = <span class="number">26f</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h2><p>在Anko如果你想设置Theme需要使用<code>themeable</code><br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">verticalLayout &#123;</span><br><span class="line">    padding = dip(<span class="number">30</span>)</span><br><span class="line">    themedButton(<span class="string">&quot;登陆&quot;</span>, theme = R.style.Base_TextAppearance_AppCompat_Button)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="LayoutParams"><a href="#LayoutParams" class="headerlink" title="LayoutParams"></a>LayoutParams</h2><p>在Anko中也可以使用<code>LayoutParams</code>。<br>比方说我现在要显示一个button，下面显示一个图片。</p>
<p>如果使用XML:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Hello World!&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">center</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@color/colorAccent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>但是使用Anko:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">verticalLayout &#123;</span><br><span class="line">    textView (<span class="string">&quot;Hello World!&quot;</span>) &#123;</span><br><span class="line">        textSize = sp(<span class="number">12</span>).toFloat()</span><br><span class="line">    &#125;.lparams(height = wrapContent, width = wrapContent) &#123;</span><br><span class="line">        horizontalGravity = Gravity.CENTER_HORIZONTAL</span><br><span class="line">    &#125;</span><br><span class="line">    imageView &#123;</span><br><span class="line">        backgroundColor = Color.BLUE</span><br><span class="line">    &#125;.lparams(height = matchParent, width = matchParent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><code>horizontalMargin</code> 同时设置 left 和 right margins</li>
<li><code>verticalMargin</code> 同时设置 top 和 bottom</li>
<li><code>margin</code> 同时设置4个方向的 margins</li>
</ul>
<h2 id="Listeners"><a href="#Listeners" class="headerlink" title="Listeners"></a>Listeners</h2><p>在Anko中设置<code>Listeners</code>非常简单，我下面以<code>Button</code>的<code>OnClick</code>举例：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">button(<span class="string">&quot;登录&quot;</span>) &#123;</span><br><span class="line">    id = buttonLogin</span><br><span class="line">    textSize = <span class="number">26f</span></span><br><span class="line">    onClick &#123; toast(<span class="string">&quot;OnClickLoginButton&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用Fragment加载"><a href="#使用Fragment加载" class="headerlink" title="使用Fragment加载"></a>使用Fragment加载</h2><p>先创建一个<code>Activity</code>，把<code>Fragment</code>加进去<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnkoFragmentActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        linearLayout &#123;</span><br><span class="line">            id = R.id.fragment_id</span><br><span class="line">            supportFragmentManager.beginTransaction().replace(id, AnkoFragment.newInstance()).commit()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后在<code>Fragment</code>的<code>onCreateView()</code>中加入DSL代码，然后返回<code>View</code>即可<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnkoFragment</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        <span class="comment">// return inflater.inflate(R.layout.fragment_anko, container, false)</span></span><br><span class="line">        <span class="keyword">return</span> UI &#123;</span><br><span class="line">            verticalLayout &#123;</span><br><span class="line">                editText()</span><br><span class="line">                button(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.view</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newInstance</span><span class="params">()</span></span>: AnkoFragment &#123;</span><br><span class="line">            <span class="keyword">return</span> AnkoFragment()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>AnkoLayout确实挺好的，因为他把UI代码集成到了代码文件中，不用再像以前一样写一个点击事件还得先<code>findViewBuId</code>，然后再<code>setOnClickListeners</code>。代码能非常简洁。</p>
<p>但是AnkoLayout还是不够完美，感觉写起来还是没有XML那个顺手（可能是我写惯了XML，刚开始用Anko还不够熟练），而且Anko还有很多控件都不支持。<br>最重要的是，<strong>他没有实时预览</strong>！！！</p>
<blockquote>
<p>Android Studio里面有一个叫<code>Anko Support</code>的插件，可以实现anko的预览，但是他必须是先将项目构建了再预览的，不算是实时预览</p>
</blockquote>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin入门(一)——基本要素</title>
    <url>/posts/2ed82411.html</url>
    <content><![CDATA[<h1 id="Kotlin入门-一-——基本要素"><a href="#Kotlin入门-一-——基本要素" class="headerlink" title="Kotlin入门(一)——基本要素"></a>Kotlin入门(一)——基本要素</h1><blockquote>
<p>本章内容包括：</p>
<ul>
<li>kotlin的HelloWorld</li>
<li>变量、控制流、函数</li>
<li>包和类（最基础的内容，具体的后面会介绍）</li>
<li>智能转换</li>
</ul>
</blockquote>
<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>我之前写过一篇<a href="https://www.littlecor/gi.top/%2Fposts%2F343b01ae.html">《Kotlin入门》</a>博客，但是一方面是这篇博客写的比较早，写的时候单纯是为了学习anko而写的，所以感觉写的并不好，另一方面，在写的时候只是写了点基础知识，当时也没有系统的学习kotlin。</p>
<p>所以在看完kotlin实战后，就想回过头来写一篇总结博客</p>
<p>写这个主要是为了几个目的：</p>
<ul>
<li>对于看我博客的人来说有一个更加系统更加全面更加完善的kotlin入门指南。</li>
<li>对于我自己，单纯的看书还是不够好，就写一篇总结博客总结下书本中的知识。</li>
</ul>
<p>注：由于我之前只会Java，并且目前主要是在做Android开发，所以我的博客更多的会将kotlin与Java进行比较，并且可能会偏向Android开发中的实践。</p>
<span id="more"></span>
<h1 id="1-Hello-World"><a href="#1-Hello-World" class="headerlink" title="1. Hello World"></a>1. Hello World</h1><p>万恶之源，我们从程序员的第一个程序“Hello World”开始。</p>
<p>我们先来看下kotlin版的Hello World是怎么写的，如果你之前学习过Java，你会立马被kotlin语法的简洁所震惊：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> kotlinstudy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你之前是Java工程师，或者你之前学过Java，是不是会感觉到非常的惊讶：</p>
<ul>
<li>熟悉的<code>public static void main(String[] args)</code>不见了，取而代之的是<code>fun main()</code></li>
<li>熟悉的<code>System.out.println()</code>不见了，取而代之的是<code>println()</code></li>
<li>熟悉的main方法必须在一个class里面不见了，取而代之的是方法可以直接写在最外面。<del><em>这个叫顶层层函数，我们后面会讲到</em></del></li>
</ul>
<p>我们都知道，kotlin也是运行在JVM之上的，也就是他也必须遵守JVM的一些约定，那么他是如何能做到这样的语法的呢？</p>
<p>如果你使用IDEA或者Android Studio的话，你可以在上面的Tools-Kotlin里面看到一个<code>Show Kotlin Bytecode</code>的选项：<br><img src="https://cdn.littlecorgi.top/mweb/2020-05-27/15895156953362.jpg" alt="-w743"></p>
<p>我们打开它，就能看到我们刚刚编写的kotlin代码的字节码文件了，但是这个时候还是看不懂，不急，我们可以点一下这个<code>Decompile</code>按钮，然后就能转成更易懂的语句了。<br><img src="https://cdn.littlecorgi.top/mweb/2020-05-27/15895157853281.jpg" alt="-w1393"><br><img src="https://cdn.littlecorgi.top/mweb/2020-05-27/15895158024195.jpg" alt="-w765"></p>
<p>看到转过来的语法，你就能懂了，为什么kotlin能运行在JVM只上了。其实kotlin运行的最终本质仍然还是JVM的class文件，只不过他使用了一层语法糖，所谓的<code>fun main()</code>、<code>println()</code>等等，最终都会转成Java语法对应的东西。</p>
<p>所以我们可以得出一个结论：kotlin的一切方便，只不过都是一层语法糖而已。（可能存在一定的过与绝对，但是道理也确实还是这个道理）</p>
<h1 id="2-函数"><a href="#2-函数" class="headerlink" title="2. 函数"></a>2. 函数</h1><h2 id="2-1-函数声明"><a href="#2-1-函数声明" class="headerlink" title="2.1 函数声明"></a>2.1 函数声明</h2><p>上面我们通过一个简单的HelloWorld了解到了main函数的定义方法，我们就一个简单的函数来大致了解下kotlin中函数的定义：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们就来将这个函数拆解一下，逐步讲一下他的各个组成部分：</p>
<ul>
<li><p><code>fun</code>：fun关键字是kotlin中函数的标识，就是说想在kotlin中写一个函数的话，必须以fun开头，否则kotlin是不会将它识别成一个函数的，反而还可能会报错。</p>
</li>
<li><p><code>max</code>：紧跟着fun的，就是函数的名称了。</p>
</li>
<li><code>(a: Int, b: Int)</code>：函数名后面就是用括号括起来的形参列表了，每个形参之间用逗号(‘,’)分隔开来。而参数的定义方法或者说变量的定义方法想必大家已经看出来了，<code>a</code>就是变量名，然后<code>Int</code>就是变量类型。由于kotlin没有基本类型，也就是说他不像Java有int、float等这些基本类型，所以变量类型就是<code>Int</code>了。</li>
<li><code>: Int</code>：大家应该已经看出来了，和定义类型类似，这个就代表函数的返回值是Int类型的。</li>
<li>后面的就和Java类似，就是用一组大括号括起来的函数体。只不过kotlin没有三目运算符，所以Java中的<code>?:</code>在kotlin中就成了<code>if else</code>。</li>
</ul>
<h2 id="2-2-表达式函数体"><a href="#2-2-表达式函数体" class="headerlink" title="2.2 表达式函数体"></a>2.2 表达式函数体</h2><p>在kotlin中，你可以让简单的事物尽可能简单的展现出来(在后面你可以看到更多这类例子)。</p>
<p>比方说我们上面的<code>max</code>函数，他的功能就是接受<code>a</code>和<code>b</code>两个参数，然后返回他们中的较大值。我们写的代码已经够简洁了，但是，这个只是对于Java来说够简洁，但是对于kotlin来说，他还不够。</p>
<p>下面让我们来看一下如何用表达式函数来重写这个<code>max</code>函数：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure></p>
<p>对于上面那个初级版本的<code>max</code>函数来说，这个已经够简洁了。</p>
<p>对应的，如果函数体写在大括号中，我们就说这个函数有代码块体。如果他只是简单的一个表达式，他就有表达式体。</p>
<p>但是，我们刚刚说到，kotlin想让简单的事物尽可能简单的展现出来。所以，对于这个已经非常明显的返回值类型，我们何必要把它显式的定义出来呢：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure></p>
<h2 id="2-3-参数"><a href="#2-3-参数" class="headerlink" title="2.3 参数"></a>2.3 参数</h2><h3 id="2-3-1-默认参数"><a href="#2-3-1-默认参数" class="headerlink" title="2.3.1 默认参数"></a>2.3.1 默认参数</h3><p>有时候，我们想要缺省函数的参数时，我们就可以对参数使用默认值：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span> = <span class="number">0</span>)</span></span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure></p>
<p>这个时候我们调用它的时候，就可以缺省有默认值的参数：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">print(max(<span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
<p>但是当在设置了默认值参数的后面有没有设置默认值的参数的话，我们调用的时候必须显式指明这个值到底是属于哪个参数的：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span> = <span class="number">0</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = <span class="keyword">return</span> <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line">print(max(b = <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
<h1 id="3-变量-类和对象"><a href="#3-变量-类和对象" class="headerlink" title="3. 变量(类和对象)"></a>3. 变量(类和对象)</h1><h2 id="3-1-不可变变量和可变变量"><a href="#3-1-不可变变量和可变变量" class="headerlink" title="3.1 不可变变量和可变变量"></a>3.1 不可变变量和可变变量</h2><p>和Java不同，在kotlin中，变量的定义主要通过<code>val</code>和<code>var</code>。这个语法有点类似于JS。</p>
<ul>
<li><code>val</code>：用于值从不更改的变量。您不能为使用 val 声明的变量重新赋值。对应Java是<code>final</code>。</li>
<li><code>var</code>：用于值可以更改的变量。对应Java是普通(非final)的变量。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> count: <span class="built_in">Int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> num: <span class="built_in">Int</span> = <span class="number">10</span></span><br><span class="line">count = <span class="number">1</span> <span class="comment">// Error：因为count是val，并且已经初始化过了</span></span><br><span class="line">num = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>在默认情况下，应该尽可能的去使用<code>val</code>来声明所有的kotlin变量。</p>
<p>同Java的final一样，被val修饰的变量，它本身是不能变的，但是他指向的对象是可以变的：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a = ArrayList&lt;String&gt;()</span><br><span class="line">a.add(<span class="string">&quot;1234&quot;</span>) <span class="comment">// 改变了所引用的对象</span></span><br><span class="line">a.add(<span class="string">&quot;1324&quot;</span>) <span class="comment">// 改变了所引用的对象</span></span><br><span class="line">a = ArrayList&lt;String&gt;() <span class="comment">// Error：改变了他自身</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-2-类型推断"><a href="#3-2-类型推断" class="headerlink" title="3.2 类型推断"></a>3.2 类型推断</h2><p>在某些时候，变量的类型可以省略不写，然后编译器会根据所赋值的类型来推断类型：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> languageName = <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line"><span class="keyword">val</span> upperCaseName = languageName.toUpperCase()</span><br></pre></td></tr></table></figure></p>
<p>但是一旦变量的类型在定义时被确定下来后，后面是不许再更改类型了：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> answer = <span class="number">42</span> <span class="comment">// answer的类型是Int</span></span><br><span class="line">answer = <span class="string">&quot;no answer&quot;</span> <span class="comment">//Error：类型不匹配</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-3-字符串模板"><a href="#3-3-字符串模板" class="headerlink" title="3.3 字符串模板"></a>3.3 字符串模板</h2><p>我们前面写过HelloWorld，但是我们现在想根据人名，输出Hello Name，那么这个用kotlin该怎么实现：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line">    println(<span class="string">&quot;Hello <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到字符串中有一个<code>$变量名</code>类型的结构，其实这个结构完整是这样的<code>$&#123;变量名&#125;</code>，只不过对于单纯的变量，可以省略花括号。</p>
<p>这个就是字符串模板。</p>
<p>除了变量外，字符串模板中还可以写入表达式：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line">    println(<span class="string">&quot;Hello <span class="subst">$&#123;name.toUpperCase()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>甚至更复杂的都可以写：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sc = Scanner(System.`<span class="keyword">in</span>`)</span><br><span class="line">    <span class="keyword">val</span> name = sc.next()</span><br><span class="line">    println(<span class="string">&quot;Hello <span class="subst">$&#123;if (name.isNotEmpty()) name else <span class="string">&quot;Kotlin&quot;</span>&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="4-控制流"><a href="#4-控制流" class="headerlink" title="4. 控制流"></a>4. 控制流</h1><p>在kotlin中，控制流主要有<code>if</code>、<code>when</code>、<code>for</code>、<code>while</code>。</p>
<h2 id="4-1-if"><a href="#4-1-if" class="headerlink" title="4.1 if"></a>4.1 if</h2><p>在大部分语言中，<code>if</code>就是简单的判断，kotlin也不例外。</p>
<p>但是在kotlin中，<code>if</code>是一个表达式，她是有返回值的。这也是为什么在kotlin中没有<code>?:</code>，因为<code>if else</code>就可以替代他。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统用法</span></span><br><span class="line"><span class="keyword">var</span> max = a </span><br><span class="line"><span class="keyword">if</span> (a &lt; b) max = b</span><br><span class="line"></span><br><span class="line"><span class="comment">// With else </span></span><br><span class="line"><span class="keyword">var</span> max: <span class="built_in">Int</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    max = a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    max = b</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 作为表达式</span></span><br><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure>
<h2 id="4-2-when"><a href="#4-2-when" class="headerlink" title="4.2 when"></a>4.2 when</h2><p>有一个很常见的案例，当我们需要判断一个变量的值的时候，当在某个区间执行某个代码，在另一个区间执行另一个代码(比如我们高中是学习过的那种区间的二元一次方程求解)，这个时候如果我们使用<code>if</code>的话，就需要特别多的<code>if else</code>。</p>
<p>而如果我们有一种东西，他可以只需要指定判断的变量，然后后面就可以下对应的区间并执行对应的代码，这样是不是比单纯的大量的<code>if else</code>简洁的多。</p>
<p>所以我们就需要使用<code>when</code>。</p>
<h3 id="4-2-1-when的基础用法"><a href="#4-2-1-when的基础用法" class="headerlink" title="4.2.1 when的基础用法"></a>4.2.1 when的基础用法</h3><p>在kotlin中，用<code>when</code>取代了C、C++、Java中的<code>switch</code>，功能一模一样，只不过有一小区别，我们边看代码边说：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">0</span> -&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;x == 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">1</span> -&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;x == 1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">2</span> -&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;x == 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;没有被定义&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和<code>switch</code>一样，括号里面是用来匹配的变量，然后下面就是匹配的值，当匹配到某个值的时候，就执行这个值后面的代码块。</p>
<p>但是和Java及C++的<code>switch</code>不同的是，他不需要写<code>break</code>语句。</p>
<p>当其他分支都不满足条件的时候，就会自动进入<code>else</code>分支，去执行<code>else</code>分支的代码。在kotlin中，<code>else</code>分支是必须有的。</p>
<p>当有多个分支需要执行同样的代码时，就可以把多个分支的条件放在一起：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span> -&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;x == 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">2</span> -&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;x == 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;没有被定义&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同时我们也可以使用区间(这个我们后面将for循环的时候会讲到)作为分支的判断条件：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="keyword">in</span> <span class="number">0.</span><span class="number">.10</span> -&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;x == 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;没有被定义&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-2-2-在when中使用任意对象"><a href="#4-2-2-在when中使用任意对象" class="headerlink" title="4.2.2 在when中使用任意对象"></a>4.2.2 在when中使用任意对象</h3><p><code>when</code>比Java中的<code>switch</code>要强大的多，在<code>switch</code>中只能用常量作为分支条件，但是在<code>when</code>中，可以使用任何对象：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> b: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">when</span> (setOf(a, b)) &#123;</span><br><span class="line">    setOf(<span class="number">0</span>, <span class="number">0</span>) -&gt; &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    setOf(<span class="number">0</span>, <span class="number">1</span>) -&gt; &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    setOf(<span class="number">1</span>, <span class="number">0</span>) -&gt; &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    setOf(<span class="number">1</span>, <span class="number">1</span>) -&gt; &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-2-3-类型检测与智能转换"><a href="#4-2-3-类型检测与智能转换" class="headerlink" title="4.2.3 类型检测与智能转换"></a>4.2.3 类型检测与智能转换</h3><h4 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h4><p>使用<code>when</code>的时候还可以去判断当前这个对象是属于哪个类的对象。</p>
<p>kotlin给我们提供了一个关键字<code>is</code>，使用这个关键字，我们可以去判断当前这个对象是否符合给定的类型：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> String) &#123;</span><br><span class="line">    print(obj.length)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (obj !<span class="keyword">is</span> String) &#123; <span class="comment">// 与 !(obj is String) 相同</span></span><br><span class="line">    print(<span class="string">&quot;Not a String&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(obj.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="智能转换"><a href="#智能转换" class="headerlink" title="智能转换"></a>智能转换</h4><p><code>is</code>的厉害之处不在于他能判断对象是否符合某个给定的类型，而是在于当他检测过某个变量是某种类型的时候，后面就不用再进行转换了，可以就把他当做检查过的类型使用，这就是智能转换：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">(x: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">is</span> String) &#123;</span><br><span class="line">        print(x.length) <span class="comment">// x 自动转换为字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="在when中使用"><a href="#在when中使用" class="headerlink" title="在when中使用"></a>在when中使用</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; print(x + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">is</span> String -&gt; print(x.length + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">is</span> IntArray -&gt; print(x.sum())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-while"><a href="#4-3-while" class="headerlink" title="4.3 while"></a>4.3 while</h2><p>相信一定有很多人都和我一样，看到这块会有点疑问。因为我看过的大部分语言学习的书，比方说C、Java、C++的大部分语言入门类书，都会将<code>for循环</code>放在<code>while循环</code>的前面。而当我在看《kotlin实战》这本书的时候，却发现它把<code>while</code>放在了<code>for</code>的前面。</p>
<p>但是当我看了会之后就懂了，kotlin的<code>while</code>和Java以及C的<code>while</code>没有啥区别，但是kotlin的<code>for</code>和Java的<code>for</code>有点区别，并且有很多操作。所以会把<code>while</code>放在前面，并且会一笔带过。</p>
<p>kotlin的while也分为<code>while</code>和<code>do-while</code>。用法和Java的没有任何区别：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123; <span class="comment">// 当条件符合才进入循环</span></span><br><span class="line">    x--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123; <span class="comment">// 先会进入代码块一只，然后执行完毕后才会去判断条件，如果符合就再去执行循环</span></span><br><span class="line">  <span class="keyword">val</span> y = retrieveData()</span><br><span class="line">&#125; <span class="keyword">while</span> (y != <span class="literal">null</span>) <span class="comment">// y 在此处可见</span></span><br></pre></td></tr></table></figure></p>
<h2 id="4-4-for"><a href="#4-4-for" class="headerlink" title="4.4 for"></a>4.4 for</h2><p>我们刚刚说到过，kotlin的<code>for</code>和Java的<code>for</code>有着较大的区别。</p>
<p>我们在Java中常用的for有两种：<code>简单的for</code>和<code>for-each</code>：</p>
<ul>
<li>简单的for就是<code>for(变量定义; 执行的条件; 变量每次循环需要执行的语句，一般都是控制变量的值的变化)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>for-each就是<code>for(临时变量 in 集合)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (i in arrayList) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时i就相当于是arrayList这个集合里面存着的每一个对象。</p>
<p>而kotlin的<code>for</code>就和Java的<code>for-each</code>一致。</p>
<h3 id="4-4-1-for-each"><a href="#4-4-1-for-each" class="headerlink" title="4.4.1 for-each"></a>4.4.1 for-each</h3><p><code>for</code>循环可以对任何提供了<code>迭代器(iterator)</code>的对象进行遍历。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection) print(item)</span><br></pre></td></tr></table></figure></p>
<p>for可以循环遍历任何提供了迭代器的对象。即：</p>
<ul>
<li>有一个成员函数或者扩展函数<code>iterator()</code>，它的返回类型<ul>
<li>有一个成员函数或者扩展函数<code>next()</code>，并且</li>
<li>有一个成员函数或者扩展函数<code>hasNext()</code>返回<code>Boolean</code></li>
</ul>
</li>
</ul>
<h3 id="4-4-2-迭代数字：区间"><a href="#4-4-2-迭代数字：区间" class="headerlink" title="4.4.2 迭代数字：区间.."></a>4.4.2 迭代数字：区间..</h3><p>对于我来说，kotlin的使用<code>for</code>迭代数字比Java更为方便，但是有些时候却反而很不方便。</p>
<p>在使用<code>for</code>迭代数字之前，我们先来看kotlin的区间表达式。</p>
<p>区间本质上就是两个值之间的间隔，这两个值通常就是数字：一个代表了起始值，一个代表了结束值。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.4</span>) &#123; <span class="comment">// 等同于1 &lt;= i &lt;= 4</span></span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而<code>in</code>这个函数实际上是<code>rangeTo()</code>。所以说，实际上我们调用的是<code>rangeTo()</code>函数。</p>
<p>但是我们可以看下<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/range-to.html">kotlin官方文档</a>对这个函数的定义：<br><img src="https://cdn.littlecorgi.top/mweb/2020-05-27/kotlin%E5%85%A5%E9%97%A8-%E4%B8%80-%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A04.png" alt="kotlin入门-一-——基本要素4"></p>
<p>翻译过来就是:</p>
<blockquote>
<p>创建一个从这个继承自Comparable接口的value到that的range(区间)<br>value必须小于that，否则这个range将会是空的。</p>
</blockquote>
<p>所以就是说<code>rangeTo()</code>或者说<code>..</code>只能从小到大的遍历，反过来则不行。</p>
<p>但是我们上面的例子是从1逐步到4，也就是说打印出来的是1，2，3，4。<br>但是如果我只想要输出1到4之间的奇数呢？<br>也就是说，如果我想在1到4之间每隔2个输出一次，那么该怎么操作呢：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.4</span> step <span class="number">2</span>) &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就能从1开始每隔2执行一次，也就是输出1，3。</p>
<p><code>..</code>相当于是闭区间，那么开区间呢？<br>如果要实现开区间，我们可以使用<code>until</code><br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until <span class="number">4</span> step <span class="number">2</span>) &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们刚刚说的全部都是从小到大，那么从大到小呢？<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">8</span> downTo <span class="number">1</span>) print(i)</span><br></pre></td></tr></table></figure></p>
<p>这样就会实现从8开始输出字符直到1为止。</p>
<h3 id="4-4-2-为什么我会说kotlin的for在有些地方没有Java的for方便"><a href="#4-4-2-为什么我会说kotlin的for在有些地方没有Java的for方便" class="headerlink" title="4.4.2 为什么我会说kotlin的for在有些地方没有Java的for方便"></a>4.4.2 为什么我会说kotlin的for在有些地方没有Java的for方便</h3><p>在使用<code>for (i in 0..10</code>的时候，如果我们需要操作指针是没法操作的，举个例子：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.2</span>) &#123;</span><br><span class="line">    i-- <span class="comment">// Error：val不能被更改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们就懂了，因为kotlin自动把i这个变量定义为val的。</p>
<p>那么如果我们把它手动设定为var呢：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.2</span>) &#123; <span class="comment">// Error：&#x27;var&#x27;不允许被放在循环的参数中</span></span><br><span class="line">    i--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>也就是说kotlin根本不允许var出现在这，或者说任何东西都不允许出现在这(val也不行)，因为这样不符合kotlin的语法。</p>
<p>所以在kotlin中，如果你想在循环中操作指针，就只能通过while了。</p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin入门(三)——类、对象、接口</title>
    <url>/posts/756a6103.html</url>
    <content><![CDATA[<blockquote>
<p>本章内容包括：</p>
<ul>
<li>类的基本要素</li>
<li>类的继承结构</li>
<li>修饰符</li>
<li>接口</li>
</ul>
</blockquote>
<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>在<a href="https://blog.csdn.net/a1203991686/article/details/106421100">上一篇</a>的末尾，我们提到了Kotlin的包和导入。</p>
<p>原本我是准备把这篇的内容也放在上一篇的，但是后来一想，这张的内容会很有点多，放进去的话可能会导致上一篇太大了，所以就单独分成一篇了。</p>
<p>在说类之前，我们先来看下一个类的Java版和Kotlin版的对比，这个会一下子就让你对Kotlin感兴趣。</p>
<span id="more"></span>
<p>我们现在有一个需求，需要定义一个JavaBean类Person，这个类中包含这个人的姓名、电话号码以及地址。</p>
<p>我们先来看下Java的实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String telephone;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String firstName, String lastName, String telephone, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">        <span class="built_in">this</span>.telephone = telephone;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFirstName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirstName</span><span class="params">(String firstName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLastName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastName</span><span class="params">(String lastName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTelephone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> telephone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTelephone</span><span class="params">(String telephone)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.telephone = telephone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个很基本的Java类，我们定义了四个private属性，然后给定了一个构造函数，然后对每个属性都给了get和set方法。</p>
<p>相信大家学Java一定都写过这个类。但是我们想想，就写一个功能这么简单的类，Java却需要我们写这么多内容，有的同学会说：Idea和Eclipse都不是提供了自动生成代码的工具吗。但是如果你看了Kotlin的实现，一定会觉得连自动生成工具都麻烦：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(</span><br><span class="line">    <span class="keyword">val</span> firstName: String,</span><br><span class="line">    <span class="keyword">val</span> lastName: String,</span><br><span class="line">    <span class="keyword">val</span> telephone: String,</span><br><span class="line">    <span class="keyword">val</span> address: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>对，你没有看错，Kotlin的类就是这么的简单：</p>
<ul>
<li><p>由于Kotlin的属性默认的修饰符就是<code>public</code>。但是由于我们这个方法设置成了<code>val</code>，所以除了构造方法外，没法对这个属性的值进行更改。但是从Kotlin编译后会自动将<code>val</code>的属性转为<code>private final String firstName;</code>，<code>var</code>的属性转为<code>private String firstName;</code></p>
</li>
<li><p>由于Kotlin会自动为属性生成<code>get</code>和<code>set</code>方法，所以没必要去显式的写<code>get</code>和<code>set</code>方法，除非你需要自定义的<code>get</code>和<code>set</code>方法。但是由于这个类的属性都是<code>val</code>，所以只会生成<code>get</code>方法。</p>
</li>
<li>Kotlin的默认构造方法是直接写在类名后面的</li>
</ul>
<p>接下来我们就把这个代码进行分解，逐步来讲解Kotlin的类。</p>
<h1 id="1-类与继承"><a href="#1-类与继承" class="headerlink" title="1. 类与继承"></a>1. 类与继承</h1><h2 id="1-1-类"><a href="#1-1-类" class="headerlink" title="1.1 类"></a>1.1 类</h2><p>与Java类似，Kotlin也是使用<code>class</code>关键字来表示类。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>() &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>类声明由类名、类头（指定其类型参数、主构造函数等）以及由花括号包围的类体构成。类头和类体都是可选的，一个类如果没有类体，可以省略花括号：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>()</span><br></pre></td></tr></table></figure></p>
<h2 id="1-2-构造函数"><a href="#1-2-构造函数" class="headerlink" title="1.2 构造函数"></a>1.2 构造函数</h2><h3 id="1-2-1-主构造函数"><a href="#1-2-1-主构造函数" class="headerlink" title="1.2.1 主构造函数"></a>1.2.1 主构造函数</h3><p>Kotlin的一个类可以有一个主构造函数以及一个或者多个次构造函数。主构造函数是类头的一部分，跟在类名之后：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">constructor</span>(<span class="keyword">val</span> name: String)&#123;&#125;</span><br></pre></td></tr></table></figure><br>如果主构造函数没有任何注解或者可见性修饰符，可以省略这个<code>constructor</code>关键字。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>主构造方法主要有两种目的：表明构造方法的参数，以及定义使用这些参数初始化的属性。</p>
<p>但是主构造方法不允许直接有代码块，所以如果需要在主构造方法中添加初始化代码，可以放到init关键字的代码块中：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> _name: String) &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        name = _name</span><br><span class="line">        println(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是同时，这个例子中，_name赋值给name，这个语句可以放在name的定义中去，所以可以改成：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> _name: String) &#123;</span><br><span class="line">    <span class="keyword">val</span> name: =  _name</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，如果主构造方法需要添加注解或者修饰符的话，这个<code>constructor</code>是不能省略的：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-2-2-次构造函数"><a href="#1-2-2-次构造函数" class="headerlink" title="1.2.2 次构造函数"></a>1.2.2 次构造函数</h3><p>类也可以单纯的声明次构造方法而不声明主构造方法：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(_name: String) &#123;</span><br><span class="line">        name = _name</span><br><span class="line">        println(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果类有一个主构造函数，每个次构造函数需要委托给主构造函数， 可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数用 this 关键字即可：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">var</span> children: MutableList&lt;Person&gt; = mutableListOf&lt;&gt;()</span><br><span class="line">    <span class="keyword">constructor</span>(name: String, parent: Person) : <span class="keyword">this</span>(name) &#123;</span><br><span class="line">        parent.children.add(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>值的注意下的是，初始化语句(init)实际上会成为主构造方法的一部分。委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块与属性初始化器中的代码都会在次构造函数体之前执行。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块。<br>简单点来说就是，不管你有没有主构造方法，只要你有次构造方法，并且有init语句，他都会在执行次构造方法的函数体内的代码之前，先去执行init语句：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(_name: String) &#123;</span><br><span class="line">        name = _name</span><br><span class="line">        println(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;init: 1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">输出结果为</span></span><br><span class="line"><span class="comment">init: 1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<h2 id="1-3-类的实例"><a href="#1-3-类的实例" class="headerlink" title="1.3 类的实例"></a>1.3 类的实例</h2><p>回忆一下<a href="https://blog.csdn.net/a1203991686/article/details/106421100">上一篇</a>讲基本类型：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> one = <span class="number">1</span> <span class="comment">// Int</span></span><br><span class="line"><span class="keyword">val</span> threeBillion = <span class="number">3000000000</span> <span class="comment">// Long</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>首先我们说过Kotlin和Java不一样，所有的东西都是对象，包括基本类型。所以说我们创建的Kotlin的<code>Int</code>型参数，实际上就是<code>new</code>了一个<code>Int</code>这个类的对象</li>
<li>其次Kotlin创建对象是通过<code>val</code>和<code>var</code>关键字的</li>
<li>最后就是一点大家应该都发现了，Kotlin是没有<code>new</code>这个关键字的</li>
</ul>
<p>所以从上面我们可以推出如果在Kotlin中创建一个对象：</p>
<ul>
<li>首先，我们需要根据对象需要的场景，选择到底是val的对象还是var的对象；</li>
<li>然后写对象名；</li>
<li>紧跟着对象名的就是对象的类型，但是由于Kotlin有类型推断，所以此处这个显式声明类型可以省略，因为他可以通过等号右边给定的内容自动推断出该对象的类型（此处暂时先不考虑lateinit或者其他的操作）</li>
<li>之后就可以写等号<code>=</code></li>
<li>等号右边就是我们需要赋值给这个对象的初始化语句了，但是Kotlin没有<code>new</code>关键字，所以是直接写，不需要加<code>new</code></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> person1: Person = Person(<span class="string">&quot;1&quot;</span>) <span class="comment">// Kotlin没有 new 关键字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> person2 = Person(<span class="string">&quot;1&quot;</span>) <span class="comment">// 由于等号右边已经给出了具体的内容，所以可以省略掉显式的指定类型</span></span><br></pre></td></tr></table></figure>
<p>当然也有特殊情况：</p>
<ul>
<li>使用<code>lateinit</code>关键字</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> person3: Person</span><br></pre></td></tr></table></figure>
<p>在这种情况下必须显式的指定变量类型，因为使用了<code>lateinit</code>关键字，可以延迟初始化，但是从现在开始，直到初始化，期间如果使用了这个变量，<strong>运行后</strong>就会报错<code>lateinit property person3 has not been initialized</code></p>
<ul>
<li>在方法或者类中定义变量</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person4: Person</span><br><span class="line">    println(person4) <span class="comment">// 此时IDE就会报红，Variable &#x27;person4&#x27; must be initialized</span></span><br><span class="line">    person4 = Person(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    println(person4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法中或者类中还可以这样，先不初始化，先定义变量，但是此时必须显式指出其类型，并且在初始化之前都不可使用变量，如果使用了，<strong>在编译前也就是还在编辑时</strong>，IDE就会报红，<code>Variable &#39;person4&#39; must be initialized</code>。但是一旦初始化之后就可以正常使用。</p>
<h2 id="1-4-继承"><a href="#1-4-继承" class="headerlink" title="1.4 继承"></a>1.4 继承</h2><h3 id="1-4-1-Object和Any、extends和"><a href="#1-4-1-Object和Any、extends和" class="headerlink" title="1.4.1 Object和Any、extends和:"></a>1.4.1 <code>Object</code>和<code>Any</code>、<code>extends</code>和<code>:</code></h3><p>我们都知道，Java中存在着一个基类<code>Object</code>，所有的对象都会继承自这个类，哪怕你自己创建的对象没有指明具体继承自哪个类，但是Java会让他继承自Object类。而这个类里面也有一些每个类必有的方法如<code>getClass()</code>、<code>hashCode()</code>、<code>equals()</code>、<code>toString()</code>等一系列方法。</p>
<p>同样的，Kotlin也有这样的基类，只不过叫做<code>Any</code>。但是不同的是Kotlin的Any只有三个方法：<code>hashCode()</code>、<code>equals()</code>和<code>toString()</code>。</p>
<p>而在Java中，想要继承某一个类的话，就需要在这个类的后面用<code>extends</code>关键字 + 超类名的方法去指明这个类继承自那个类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Staff</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而在Kotlin中，就没有<code>extends</code>这个关键字了，取而代之的是我们的老朋友<code>:</code>：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Staff</span>(name: String) : Person(name) </span><br></pre></td></tr></table></figure></p>
<p>这个就代表了<code>Staff</code>类继承自<code>Person</code>类。同时基类(<code>Person</code>)必须得被<code>open</code>修饰符修饰，因为Kotlin默认所有的类都是<code>final</code>的，所以不能被继承，所以就需要<code>open</code>修饰符修饰它。</p>
<p>并且如果派生类有一个主构造函数，其基类可以（并且必须） 用派生类主构造函数的参数就地初始化。</p>
<p>如果派生类没有主构造函数，那么每个次构造函数必须使用<code>super</code>关键字初始化其基类型，或委托给另一个构造函数做到这一点。 注意，在这种情况下，不同的次构造函数可以调用基类型的不同的构造函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码非常不规范，仅作为例子参考</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">    <span class="keyword">var</span> address: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">constructor</span>(_name: String) &#123;</span><br><span class="line">        name = _name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(_name: String, _address: String) &#123;</span><br><span class="line">        name = _name</span><br><span class="line">        address = _address</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Staff</span> : <span class="type">Person</span> &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String) : <span class="keyword">super</span>(name)</span><br><span class="line">    <span class="keyword">constructor</span>(name: String, address: String) : <span class="keyword">super</span>(name, address)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-2-override"><a href="#1-4-2-override" class="headerlink" title="1.4.2 override"></a>1.4.2 <code>override</code></h3><h4 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h4><p>和Java一样，Kotlin也是通过<code>override</code>关键字来标明覆盖，只不过不同的是Java是<code>@override注解</code>而Kotlin是<code>override</code>修饰符。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">getName</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;这是<span class="variable">$this</span>, name: <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Staff</span>(name: String) : Person(name) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getName</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;这是<span class="variable">$this</span>, name: <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到<code>Staff</code>继承自<code>Person</code>并重写了<code>getName()</code>方法。<br>此时必须在<code>Staff</code>重写的<code>getName()</code>方法前加上<code>override</code>修饰符，否则编译器会报错。</p>
<p>同时，与继承类时一样，Kotlin默认方法也是<code>final</code>的，如果想让这个方法被重写，就需要加上<code>open</code>关键字。但是重写后的方法，也就是有<code>override</code>修饰的方法，默认是开放的，但是如果你想让他不再被重写，就需要手动添加<code>final</code>修饰符：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Staff</span>(name: String) : Person(name) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getName</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;这是<span class="variable">$this</span>, name: <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="覆盖属性"><a href="#覆盖属性" class="headerlink" title="覆盖属性"></a>覆盖属性</h4><p>这个就是Kotlin有但是Java没有的了。和覆盖方法一样，也就是在需要覆盖的属性前面加上<code>override</code>：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> name = <span class="string">&quot;123&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Staff</span> : <span class="type">Person</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> name = <span class="string">&quot;2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同时你可以使用<code>var</code>属性去覆盖一个<code>val</code>的属性，但是反过来就不行了。因为<code>var</code>默认会有<code>get()</code>和<code>set()</code>方法，而<code>val</code>只有<code>get()</code>方法，如果用<code>val</code>去覆盖<code>var</code>，那么<code>var</code>的<code>get()</code>方法会无法处理。</p>
<h3 id="1-4-3-初始化顺序"><a href="#1-4-3-初始化顺序" class="headerlink" title="1.4.3 初始化顺序"></a>1.4.3 初始化顺序</h3><p>在构造派生类的新实例的过程中，第一步完成其基类的初始化（在之前只有对基类构造函数参数的求值），因此发生在派生类的初始化逻辑运行之前。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Base</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123; println(<span class="string">&quot;Initializing Base&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> size: <span class="built_in">Int</span> = </span><br><span class="line">        name.length.also &#123; println(<span class="string">&quot;Initializing size in Base: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>(</span><br><span class="line">    name: String,</span><br><span class="line">    <span class="keyword">val</span> lastName: String</span><br><span class="line">) : Base(name.capitalize().also &#123; println(<span class="string">&quot;Argument for Base: <span class="variable">$it</span>&quot;</span>) &#125;) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123; println(<span class="string">&quot;Initializing Derived&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> size: <span class="built_in">Int</span> =</span><br><span class="line">        (<span class="keyword">super</span>.size + lastName.length).also &#123; println(<span class="string">&quot;Initializing size in Derived: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Constructing Derived(\&quot;hello\&quot;, \&quot;world\&quot;)&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> d = Derived(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果是：<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Constructing Derived(&quot;hello&quot;, &quot;world&quot;)</span><br><span class="line">Argument for Base: Hello</span><br><span class="line">Initializing Base</span><br><span class="line">Initializing size in Base: 5</span><br><span class="line">Initializing Derived</span><br><span class="line">Initializing size in Derived: 10</span><br></pre></td></tr></table></figure></p>
<h3 id="1-4-5-调用超类实现"><a href="#1-4-5-调用超类实现" class="headerlink" title="1.4.5 调用超类实现"></a>1.4.5 调用超类实现</h3><p>子类可以通过<code>super</code>关键字访问超类中的内容：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123; println(<span class="string">&quot;Drawing a rectangle&quot;</span>) &#125;</span><br><span class="line">    <span class="keyword">val</span> borderColor: String <span class="keyword">get</span>() = <span class="string">&quot;black&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FilledRectangle</span> : <span class="type">Rectangle</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.draw()</span><br><span class="line">        println(<span class="string">&quot;Filling the rectangle&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> fillColor: String <span class="keyword">get</span>() = <span class="keyword">super</span>.borderColor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是如果在一个内部类中访问外部类的超类的内容，可以通过外部类名限定的super关键字<code>super@Outer</code>来实现：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FilledRectangle</span>: <span class="type">Rectangle</span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123; <span class="comment">/* …… */</span> &#125;</span><br><span class="line">    <span class="keyword">val</span> borderColor: String <span class="keyword">get</span>() = <span class="string">&quot;black&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Filler</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">fill</span><span class="params">()</span></span> &#123; <span class="comment">/* …… */</span> &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">drawAndFill</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="symbol">super@</span>FilledRectangle.draw() <span class="comment">// 调用 Rectangle 的 draw() 实现</span></span><br><span class="line">            fill()</span><br><span class="line">            println(<span class="string">&quot;Drawn a filled rectangle with color <span class="subst">$&#123;super@FilledRectangle.borderColor&#125;</span>&quot;</span>) <span class="comment">// 使用 Rectangle 所实现的 borderColor 的 get()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-4-6-覆盖规则"><a href="#1-4-6-覆盖规则" class="headerlink" title="1.4.6 覆盖规则"></a>1.4.6 覆盖规则</h3><p>在 Kotlin 中，实现继承由下述规则规定：如果一个类从它的直接超类继承相同成员的多个实现， 它必须覆盖这个成员并提供其自己的实现（也许用继承来的其中之一）。 为了表示采用从哪个超类型继承的实现，我们使用由尖括号中超类型名限定的<code>super</code>，如<code>super&lt;Base&gt;</code>：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123; <span class="comment">/* …… */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Polygon</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123; <span class="comment">/* …… */</span> &#125; <span class="comment">// 接口成员默认就是“open”的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span>() : Rectangle(), Polygon &#123;</span><br><span class="line">    <span class="comment">// 编译器要求覆盖 draw()：</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;Rectangle&gt;.draw() <span class="comment">// 调用 Rectangle.draw()</span></span><br><span class="line">        <span class="keyword">super</span>&lt;Polygon&gt;.draw() <span class="comment">// 调用 Polygon.draw()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-5-抽象类"><a href="#1-5-抽象类" class="headerlink" title="1.5 抽象类"></a>1.5 抽象类</h2><p>Kotlin中的抽象类用abstract关键字。抽象成员可以在本类中不用实现。</p>
<p>同时不用说的就是，在抽象类中不需要使用open标注。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Polygon</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="type">Polygon</span>() &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-属性和字段"><a href="#2-属性和字段" class="headerlink" title="2. 属性和字段"></a>2. 属性和字段</h1><p>属性的定义我们已经在<a href="https://blog.csdn.net/a1203991686/article/details/106379486">前面</a>说到过了，主要是<code>val</code>和<code>var</code>两个关键字，而现在首先要说的，就是<code>Getter</code>和<code>Setter</code>。</p>
<h2 id="2-1-Getter和Setter"><a href="#2-1-Getter和Setter" class="headerlink" title="2.1 Getter和Setter"></a>2.1 <code>Getter</code>和<code>Setter</code></h2><p>声明一个属性完整的语法是：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure><br>其中，<code>property_initializer</code>、<code>getter</code>、<code>setter</code>都是可选的，并且如果类型可以从<code>property_initializer</code>推断出来，则也是可选的。</p>
<p>而对于不管是<code>val</code>还是<code>var</code>，如果你访问这个属性的时候就直接返回这个属性的值的话，<code>getter</code>是可以省略的，而如果你想返回的时候后做些操作的话，就可以自定义<code>getter</code>（比方说我们现在有一个<code>Person</code>类，里面有<code>name</code>、<code>age</code>以及<code>isAdult</code>三个属性，其中<code>isAdult</code>我们需要去设置他的<code>get</code>方法，当<code>age</code>大于等于18的时候就返回<code>true</code>，否则返回<code>false</code>）：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(_name: String, _age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String = _name</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span> = _age</span><br><span class="line">    <span class="keyword">val</span> isAdult: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = age &gt;= <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而同时我们需要在设置这个人的age的时候，做一个判断，如果输入的值小于0的话，就抛异常，否则才更改age的值。这个时候我们就需要自定义set方法了：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(_name: String, _age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String = _name</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = _age</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> Exception(<span class="string">&quot;年龄必须大于0&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                field = value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">val</span> isAdult: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = age &gt;= <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> person = Person(<span class="string">&quot;314&quot;</span>, <span class="number">18</span>)</span><br><span class="line">        person.age = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(e.message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果就是<code>年龄必须大于0</code>。但是这块有个小要点，就是属性的set方法在对象初始化的时候是不起作用的，也就是说，如果我给上面这个Person类创建对象的时候，给age传入0或者负数的话：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> person = Person(<span class="string">&quot;314&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        println(person.age)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(e.message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果没有任何异常，输出<code>0</code>。</p>
<p>不知道大家注意到了没有，我们给<code>setter</code>传入的是<code>value</code>，而用<code>field</code>承接了传入的<code>value</code>。</p>
<p>其实这个<code>value</code>是我们自定义的，也就是说<code>set()</code>这个括号里面的名字你可以随便写，只要符合Kotlin命名规范。<br>但是这个<code>field</code>是不可变的，这个<code>field</code>相当于是<code>this.属性</code>，也就相当于是set的这个值本身，也就是说，如果你想在<code>setter</code>中改变这个属性的值的话，就必须得把最终的值传给<code>field</code>，<code>field</code>就相当于是这个属性，而<code>setter</code>中<code>this.属性</code>是没有意义的，你写了的话，IDEA反而会提示你让你改成<code>field</code>。<br><img src="https://cdn.littlecorgi.top/mweb/2020-06-09/1.png" alt="1"></p>
<h2 id="2-2-编译器常量"><a href="#2-2-编译器常量" class="headerlink" title="2.2 编译器常量"></a>2.2 编译器常量</h2><p>如果只读属性的值在编译器是已知的，就可以使用<code>const</code>去修饰将其标记为编译器常量，这种属性需要满足下列要求：</p>
<ul>
<li>位于顶层或者是<code>object</code>声明 或<code>companion object</code>的一个成员</li>
<li>以<code>String</code>或原生类型值初始化</li>
<li>没有自定义<code>getter</code></li>
</ul>
<h2 id="2-3-延迟初始化属性与变量"><a href="#2-3-延迟初始化属性与变量" class="headerlink" title="2.3 延迟初始化属性与变量"></a>2.3 延迟初始化属性与变量</h2><p>一般，属性声明为非空类型就必须得在构造函数中去初始化。但是这样也会不是很方便，例如像Android中的view的对象(TextView、Button等view的对象，需要被<code>findViewById</code>)。在这种情况下，我们没法去提供一个构造器去让其初始化，这个时候就可以使用<code>lateinit</code>修饰符：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mTextView: TextView</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        mTextView = findViewById(R.id.textView_base_model)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在被<code>lateinit</code>修饰的变量被初始化前，如果访问这个变量的话，就会抛一个异常。</p>
<h1 id="3-接口"><a href="#3-接口" class="headerlink" title="3. 接口"></a>3. 接口</h1><p>在Kotlin中使用interface来定义接口：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cook</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 可选的方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-1-实现接口"><a href="#3-1-实现接口" class="headerlink" title="3.1 实现接口"></a>3.1 实现接口</h2><p>和Java一样，一个类可以实现多个接口：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> : <span class="type">Food</span>, <span class="type">Action</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">play</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-2-接口中的属性"><a href="#3-2-接口中的属性" class="headerlink" title="3.2 接口中的属性"></a>3.2 接口中的属性</h2><p>和Java一样，Kotlin的接口中也可以存在属性。</p>
<p>只不过如果想要在Kotlin中定义属性，必须保证这个属性要么是抽象的，要么指定了访问器。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> isCookFinished: <span class="built_in">Boolean</span> <span class="comment">// 抽象的属性</span></span><br><span class="line">    <span class="keyword">val</span> isEatFinished: <span class="built_in">Boolean</span> <span class="comment">// 指定了访问器的属性</span></span><br><span class="line">        <span class="keyword">get</span>() = isCookFinished</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cook</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 可选的方法体</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-3-接口的继承"><a href="#3-3-接口的继承" class="headerlink" title="3.3 接口的继承"></a>3.3 接口的继承</h2><p>和类一样，接口也可以继承自另外一个接口，可以在父接口的基础上去添加新的方法或者属性。</p>
<h1 id="4-可见性修饰符"><a href="#4-可见性修饰符" class="headerlink" title="4. 可见性修饰符"></a>4. 可见性修饰符</h1><p>在Kotlin中，主要有4种修饰符：</p>
<ul>
<li>private</li>
<li>protected</li>
<li>internal</li>
<li>public</li>
</ul>
<p>如果没有指定修饰符，默认是<code>public</code>。</p>
<h2 id="4-1-修饰符在包内"><a href="#4-1-修饰符在包内" class="headerlink" title="4.1 修饰符在包内"></a>4.1 修饰符在包内</h2><p>我们之前提到过，Kotlin可以直接直接在顶层声明类、函数和属性。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名：example.kt</span></span><br><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; …… &#125; <span class="comment">// 在 example.kt 内可见</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> bar: <span class="built_in">Int</span> = <span class="number">5</span> <span class="comment">// 该属性随处可见</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">set</span>         <span class="comment">// setter 只在 example.kt 内可见</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">val</span> baz = <span class="number">6</span>    <span class="comment">// 相同模块内可见</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果不指定任何修饰符，默认为public，意味着随处可见；</li>
<li>如果声明为private，它只能在声明他的文件内可见；</li>
<li>如果声明为internal，它只能在相同的模块(模块我们会在本文的4.4讲到)中可见；</li>
<li>顶层中不可使用protected(理由也很好想到——都没有类，怎么存在子类的概念)</li>
</ul>
<h2 id="4-2-修饰符在类和接口内"><a href="#4-2-修饰符在类和接口内" class="headerlink" title="4.2 修饰符在类和接口内"></a>4.2 修饰符在类和接口内</h2><p>对于在类或者接口内的方法或者属性，我们四种修饰符都可用：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">open</span> <span class="keyword">val</span> b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> c = <span class="number">3</span></span><br><span class="line">    <span class="keyword">val</span> d = <span class="number">4</span>  <span class="comment">// 默认 public</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">Nested</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> e: <span class="built_in">Int</span> = <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subclass</span> : <span class="type">Outer</span>() &#123;</span><br><span class="line">    <span class="comment">// a 不可见</span></span><br><span class="line">    <span class="comment">// b、c、d 可见</span></span><br><span class="line">    <span class="comment">// Nested 和 e 可见</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> b = <span class="number">5</span>   <span class="comment">// “b”为 protected</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Unrelated</span>(o: Outer) &#123;</span><br><span class="line">    <span class="comment">// o.a、o.b 不可见</span></span><br><span class="line">    <span class="comment">// o.c 和 o.d 可见（相同模块）</span></span><br><span class="line">    <span class="comment">// Outer.Nested 不可见，Nested::e 也不可见</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>private</code>：只在这个类的内部可见；</li>
<li><code>protected</code>：只在这个类的内部以及他的子类可见；</li>
<li><code>internal</code>：只在这个模块内可见；</li>
<li><code>public</code>：随处可见。</li>
</ul>
<h2 id="4-3-局部"><a href="#4-3-局部" class="headerlink" title="4.3 局部"></a>4.3 局部</h2><p>局部变量、函数和类不可以有可见性修饰符。</p>
<h2 id="4-4-Kotlin中的模块"><a href="#4-4-Kotlin中的模块" class="headerlink" title="4.4 Kotlin中的模块"></a>4.4 Kotlin中的模块</h2><p>可见性修饰符<code>internal</code>意味着该成员只在相同模块内可见。更具体地说， 一个模块是编译在一起的一套 Kotlin 文件：</p>
<ul>
<li>一个 IntelliJ IDEA 模块；</li>
<li>一个 Maven 项目；</li>
<li>一个 Gradle 源集（例外是<code>test</code>源集可以访问<code>main</code>的<code>internal</code>声明）；</li>
<li>一次<code>&lt;kotlinc&gt;</code>Ant 任务执行所编译的一套文件。</li>
</ul>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin入门(二)——基本类型、包</title>
    <url>/posts/eef353d0.html</url>
    <content><![CDATA[<blockquote>
<p>本章内容包括：</p>
<ul>
<li>kotlin的基本类型</li>
<li>包</li>
<li>类与对象</li>
</ul>
</blockquote>
<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>在<a href="https://blog.csdn.net/a1203991686/article/details/106379486">上篇文章</a>我们涉及到了kotlin的一些最基本的语法内容，并完成了kotlin的HelloWorld。但是上篇我们在谈到类的时候，说了只介绍下最基本的类，于是在这篇，我们就着重看下类和对象。(更新：由于类和对象的内容过多，我会放在下一篇来说这个)</p>
<p>但是在说到类之前，我们先来看下基本类型。</p>
<span id="more"></span>
<h1 id="1-kotlin的基本类型"><a href="#1-kotlin的基本类型" class="headerlink" title="1. kotlin的基本类型"></a>1. kotlin的基本类型</h1><p>在说基本类型之前，我们先提及一个Kotlin的基本定义，也是Kotlin和Java最明显的区别之一：</p>
<h4 id="在kotlin中，所有的东西都是对象"><a href="#在kotlin中，所有的东西都是对象" class="headerlink" title="在kotlin中，所有的东西都是对象"></a><em><strong>在kotlin中，所有的东西都是对象</strong></em></h4><p>那么熟悉Java的同学可能要说了：不对啊，你不是说Kotlin的基础是Java吗，那么Java的基本类型不是对象啊，那Kotlin的基本类型怎么可能不是对象了。</p>
<p>但是事实就是，<strong>Kotlin的基本类型，都是对象</strong>。</p>
<p>Kotlin的基本类型也被分为了：数字、字符、布尔值、数组与字符串。我们就来逐一谈下。</p>
<h2 id="1-1-数字"><a href="#1-1-数字" class="headerlink" title="1.1 数字"></a>1.1 数字</h2><h3 id="1-1-1-整型"><a href="#1-1-1-整型" class="headerlink" title="1.1.1 整型"></a>1.1.1 整型</h3><p>和Java一样，Kotlin也有四种不同大小的整型类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小（比特）</th>
<th style="text-align:left">最小值</th>
<th style="text-align:left">最大值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Byte</td>
<td style="text-align:left">8</td>
<td style="text-align:left">-128</td>
<td style="text-align:left">127</td>
</tr>
<tr>
<td style="text-align:left">Short</td>
<td style="text-align:left">16</td>
<td style="text-align:left">-32768</td>
<td style="text-align:left">32767</td>
</tr>
<tr>
<td style="text-align:left">Int</td>
<td style="text-align:left">32</td>
<td style="text-align:left">-2^31</td>
<td style="text-align:left">2^31 - 1</td>
</tr>
<tr>
<td style="text-align:left">Long</td>
<td style="text-align:left">64</td>
<td style="text-align:left">-2^63</td>
<td style="text-align:left">2^63 - 1</td>
</tr>
</tbody>
</table>
</div>
<p>我们上一篇说到了类性推断，所以Kotlin默认给所有未超过<code>Int</code>范围的整型值初始化时会推断为<code>Int</code>类型。如果初始值超过了<code>Int</code>，就会默认为<code>Long</code>。如果想直接定义Long的值，就需要在值后面加<code>L</code>，like:<code>123L</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> one = <span class="number">1</span> <span class="comment">// Int</span></span><br><span class="line"><span class="keyword">val</span> threeBillion = <span class="number">3000000000</span> <span class="comment">// Long</span></span><br><span class="line"><span class="keyword">val</span> oneLong = <span class="number">1L</span> <span class="comment">// Long</span></span><br><span class="line"><span class="keyword">val</span> oneByte: <span class="built_in">Byte</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1-2-浮点型"><a href="#1-1-2-浮点型" class="headerlink" title="1.1.2 浮点型"></a>1.1.2 浮点型</h3><p>对于浮点型，Kotlin也提供了两种类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小（比特）</th>
<th style="text-align:left">有效数字比特数</th>
<th style="text-align:left">指数比特数</th>
<th style="text-align:left">十进制位数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Float</td>
<td style="text-align:left">32</td>
<td style="text-align:left">24</td>
<td style="text-align:left">8</td>
<td style="text-align:left">6-7</td>
</tr>
<tr>
<td style="text-align:left">Double</td>
<td style="text-align:left">64</td>
<td style="text-align:left">53</td>
<td style="text-align:left">11</td>
<td style="text-align:left">5-16</td>
</tr>
</tbody>
</table>
</div>
<p>对于小数初始化的变量，Kotlin会默认推断为<code>Double</code>类型。而如果需要将一个数值显示指定为<code>Float</code>型，就需要在数值后面加<code>F</code>，like：<code>3.0F</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> pi = <span class="number">3.14</span> <span class="comment">// Double</span></span><br><span class="line"><span class="keyword">val</span> e = <span class="number">2.7182818284</span> <span class="comment">// Double</span></span><br><span class="line"><span class="keyword">val</span> eFloat = <span class="number">2.7182818284f</span> <span class="comment">// Float，实际值为 2.7182817</span></span><br></pre></td></tr></table></figure>
<p>但是需要注意的是，Kotlin的数字没有隐式转换（自动类型转换）。</p>
<p>比如Java会在需要的时候，能自动将低级类型数据转换成高级类型数据：</p>
<ul>
<li>数值型数据的转换：byte→short→int→long→float→double。</li>
<li>字符型转换为整型：char→int。</li>
</ul>
<p>但是Kotlin不会：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printDouble</span><span class="params">(d: <span class="type">Double</span>)</span></span> &#123; print(d) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> i = <span class="number">1</span>    </span><br><span class="line">    <span class="keyword">val</span> d = <span class="number">1.1</span></span><br><span class="line">    <span class="keyword">val</span> f = <span class="number">1.1f</span> </span><br><span class="line"></span><br><span class="line">    printDouble(d)</span><br><span class="line"><span class="comment">//    printDouble(i) // 错误：类型不匹配</span></span><br><span class="line"><span class="comment">//    printDouble(f) // 错误：类型不匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果需要将数值转换成不同类型，就需要使用显示转换(<code>as</code>)。</p>
<h3 id="1-1-3-下划线"><a href="#1-1-3-下划线" class="headerlink" title="1.1.3 下划线"></a>1.1.3 下划线</h3><p>Kotlin支持在数字中使用下划线<code>_</code>，这样能使数字常量更易读：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> oneMillion = <span class="number">1_000_000</span></span><br><span class="line"><span class="keyword">val</span> creditCardNumber = <span class="number">1234_5678_9012_3456L</span></span><br><span class="line"><span class="keyword">val</span> socialSecurityNumber = <span class="number">999_99_9999L</span></span><br><span class="line"><span class="keyword">val</span> hexBytes = <span class="number">0xFF_EC_DE_5E</span></span><br><span class="line"><span class="keyword">val</span> bytes = <span class="number">0b11010010_01101001_10010100_10010010</span></span><br></pre></td></tr></table></figure></p>
<h3 id="1-1-4-基本类型和包装类"><a href="#1-1-4-基本类型和包装类" class="headerlink" title="1.1.4 基本类型和包装类"></a>1.1.4 基本类型和包装类</h3><p>我们在开头说到过，Kotlin的基本类型全是对象。</p>
<p>但是熟悉Java的同学都知道Java中有一个基本类型和包装类。在定义普通的数值的时候，就是使用基本类型int等基本类型；但是如果需要使用泛型——比方说集合的时候——就需要使用Integer(int的包装类)等包装类。</p>
<p>我们可以使用<a href="https://blog.csdn.net/a1203991686/article/details/106379486">第一篇</a>中看Kotlin的字节码的方法来看下下面的Kotlin代码最终被转成了什么样的代码：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    println(a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> array = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    array.add(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>代码很简单，就是定义了一个基本类型Int型的变量3，然后输出他，然后有定义了一个泛型为Int的ArrayList的集合。</p>
<p>那我们现在来看下他的字节码：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> kotlin.Metadata;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Metadata(</span></span><br><span class="line"><span class="meta">   mv = &#123;1, 1, 16&#125;,</span></span><br><span class="line"><span class="meta">   bv = &#123;1, 0, 3&#125;,</span></span><br><span class="line"><span class="meta">   k = 2,</span></span><br><span class="line"><span class="meta">   d1 = &#123;<span class="string">&quot;\u0000\b\n\u0000\n\u0002\u0010\u0002\n\u0000\u001a\u0006\u0010\u0000\u001a\u00020\u0001¨\u0006\u0002&quot;</span>&#125;,</span></span><br><span class="line"><span class="meta">   d2 = &#123;<span class="string">&quot;main&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;KotlinStudy&quot;</span>&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MainKt</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> void main() &#123;</span><br><span class="line">      int a = <span class="number">3</span>;</span><br><span class="line">      boolean var1 = <span class="literal">false</span>;</span><br><span class="line">      System.<span class="keyword">out</span>.println(a);</span><br><span class="line">      ArrayList array = new ArrayList();</span><br><span class="line">      array.add(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="keyword">public</span> static void main(String[] var0) &#123;</span><br><span class="line">      main();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要是看<code>public static final void main()</code>这个方法，我们可以看到，Kotlin在编译的时候，自动帮我们将<code>Int</code>型的<code>a</code>转换成了<code>int a</code>。</p>
<p>但是由于泛型消除特性，所以这个时候我们看不懂ArrayList的泛型，但是我们都知道，Java之所以要弄出一套包装类，就是因为他们是类，可以放在泛型中，这不就是我们Kotlin的Int符合的条件吗。</p>
<p>所以可以得出一个结论，Kotlin对于基本类型在编译时，会根据情境自动转换：</p>
<ul>
<li>对于变量、属性、参数和返回类型，Kotlin的Int类型会被编译成Java的基本类型int</li>
<li>对于泛型类，Kotlin的基本类型又会被编译成Java对应的包装类</li>
</ul>
<h3 id="1-1-5-显示转换"><a href="#1-1-5-显示转换" class="headerlink" title="1.1.5 显示转换"></a>1.1.5 显示转换</h3><p>每个数字类型支持如下的转换:</p>
<ul>
<li><code>toByte(): Byte</code></li>
<li><code>toShort(): Short</code></li>
<li><code>toInt(): Int</code></li>
<li><code>toLong(): Long</code></li>
<li><code>toFloat(): Float</code></li>
<li><code>toDouble(): Double</code></li>
<li><code>toChar(): Char</code></li>
</ul>
<h3 id="1-1-6-运算"><a href="#1-1-6-运算" class="headerlink" title="1.1.6 运算"></a>1.1.6 运算</h3><h4 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h4><p>虽说在Kotlin中属于对象，但是四则运算仍然支持，可以直接使用<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>。(整数间的除法永远返回的是整数，小数部分则会被舍弃。除非将其中一个整数以浮点数的格式显式的展示出来)</p>
<p>特别可以注意下的是，Kotlin支持运算符重载。</p>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>对于位运算，没有特殊字符来表示，而只可用中缀方式调用具名函数:<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> x = (<span class="number">1</span> shl <span class="number">2</span>) and <span class="number">0x000FF000</span></span><br></pre></td></tr></table></figure></p>
<p>这是完整的位运算列表（只用于<code>Int</code>与<code>Long</code>）：</p>
<ul>
<li><code>shl(bits)</code> – 有符号左移</li>
<li><code>shr(bits)</code> – 有符号右移</li>
<li><code>ushr(bits)</code> – 无符号右移</li>
<li><code>and(bits)</code> – 位与</li>
<li><code>or(bits)</code> – 位或</li>
<li><code>xor(bits)</code> – 位异或</li>
<li><code>inv()</code> – 位非</li>
</ul>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul>
<li>相等性检测：<code>a == b</code> 与 <code>a != b</code></li>
<li>比较操作符：<code>a &lt; b</code>、 <code>a &gt; b</code>、 <code>a &lt;= b</code>、 <code>a &gt;= b</code></li>
<li>区间实例以及区间检测：<code>a..b</code>、 <code>x in a..b</code>、 <code>x !in a..b</code></li>
</ul>
<h2 id="1-2-字符"><a href="#1-2-字符" class="headerlink" title="1.2 字符"></a>1.2 字符</h2><p>字符是使用<code>Char</code>来表示，跟上面的<code>Int</code>等一样，他也是对象，也是在编译时根据具体情况编译成<code>char</code>还是<code>Character</code>。</p>
<p>我们可以显式的将字符转为<code>Int</code>数字：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">decimalDigitValue</span><span class="params">(c: <span class="type">Char</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c !<span class="keyword">in</span> <span class="string">&#x27;0&#x27;</span>..<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Out of range&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> c.toInt() - <span class="string">&#x27;0&#x27;</span>.toInt() <span class="comment">// 显式转换为数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-3-布尔"><a href="#1-3-布尔" class="headerlink" title="1.3 布尔"></a>1.3 布尔</h2><p>布尔用<code>Boolean</code>类型表示，它有两个值：<code>true</code>与<code>false</code>。</p>
<p>若需要可空引用布尔会被装箱。</p>
<p>内置的布尔运算有：</p>
<ul>
<li><code>||</code> – 短路逻辑或</li>
<li><code>&amp;&amp;</code> – 短路逻辑与</li>
<li><code>!</code> - 逻辑非</li>
</ul>
<h2 id="1-4-数组"><a href="#1-4-数组" class="headerlink" title="1.4 数组"></a>1.4 数组</h2><h3 id="1-4-1-数组基本"><a href="#1-4-1-数组基本" class="headerlink" title="1.4.1 数组基本"></a>1.4.1 数组基本</h3><p>我们前面说过，Kotlin中只有对象，所以Kotlin的数组也不会像Java那样，直接使用<code>int[]</code>这种类型的，而是引入了一个类<code>Array</code>。</p>
<p>这个类定义了<code>get</code>和<code>set</code>函数(Kotlin会将运算符重载转换为<code>[]</code>)，以及<code>size</code>属性，以及其他一些成员函数。</p>
<p>我们可以使用<code>arrayOf()</code>来创建一个数组，并将数组需要存储的值传给他。但是这个方法只能显式的设置数组的元素，并且没法直接设置数组的大小，只能通过方法中的参数也就是具体的数组的元素的个数以及类型推断出这个数组的大小以及类型：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> array1 = arrayOf(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> array2 = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>另外也可以通过<code>Array</code>构造函数来构造数组：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个代码涉及到lambda，这个以后会再来说</span></span><br><span class="line"><span class="comment">// 一个String类型的数组，容量为5，里面存的内容全是&quot;1&quot;</span></span><br><span class="line"><span class="keyword">val</span> array3 = Array(<span class="number">5</span>) &#123;</span><br><span class="line">    <span class="string">&quot;1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个Int类型的数组，容量为5，里面存的内容是[1, 4, 9, 16, 25]</span></span><br><span class="line"><span class="keyword">val</span> array4 = Array(<span class="number">5</span>) &#123;</span><br><span class="line">    it * it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-4-2-原生类型数组"><a href="#1-4-2-原生类型数组" class="headerlink" title="1.4.2 原生类型数组"></a>1.4.2 原生类型数组</h3><p>Kotlin也有专门的类来表示原生类型数组：<code>IntArray</code>、<code>CharArray</code>、<code>FloatArray</code>等等。</p>
<p>但是这些类与Array并没有继承关系，但是它们有同样的方法属性集。它们也都有相应的工厂方法:<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> x: IntArray = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">x[<span class="number">0</span>] = x[<span class="number">1</span>] + x[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大小为 5、值为 [0, 0, 0, 0, 0] 的整型数组</span></span><br><span class="line"><span class="keyword">val</span> arr = IntArray(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如：用常量初始化数组中的值</span></span><br><span class="line"><span class="comment">// 大小为 5、值为 [42, 42, 42, 42, 42] 的整型数组</span></span><br><span class="line"><span class="keyword">val</span> arr = IntArray(<span class="number">5</span>) &#123; <span class="number">42</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如：使用 lambda 表达式初始化数组中的值</span></span><br><span class="line"><span class="comment">// 大小为 5、值为 [0, 1, 2, 3, 4] 的整型数组（值初始化为其索引值）</span></span><br><span class="line"><span class="keyword">var</span> arr = IntArray(<span class="number">5</span>) &#123; it * <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-5-字符串"><a href="#1-5-字符串" class="headerlink" title="1.5 字符串"></a>1.5 字符串</h2><p>字符串应该没有啥好说的了，字符串模板我在<a href="https://blog.csdn.net/a1203991686/article/details/106379486">上一篇</a>也已经说到了。</p>
<p>Kotlin的字符串也是<code>String</code>，也支持转义字符，Java的<code>String</code>的那些方法Kotlin都有。</p>
<p>但是Kotlin新增了一个原始字符串：<br>原始字符串使用三个引号<code>&quot;&quot;&quot;</code>分界符括起来，内部没有转义并且可以包含换行以及任何其他字符：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    for (c in &quot;foo&quot;)</span></span><br><span class="line"><span class="string">        print(c)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="1-6-Kotlin中的void：Unit"><a href="#1-6-Kotlin中的void：Unit" class="headerlink" title="1.6 Kotlin中的void：Unit"></a>1.6 Kotlin中的void：Unit</h2><p>Kotlin中的Unit类型就是Java中的void。</p>
<p>用法和Java中的void没有任何区别。</p>
<h2 id="1-7-Nothing：这个函数永不返回"><a href="#1-7-Nothing：这个函数永不返回" class="headerlink" title="1.7 Nothing：这个函数永不返回"></a>1.7 Nothing：这个函数永不返回</h2><blockquote>
<p>Nothing 是一个 空类型（uninhabited type），也就是说，程序运行时不会出现任何一个 Nothing 类型对象。Nothing 还是其他所有类型的子类型。<br>(摘自其它地方)</p>
</blockquote>
<p>关于这块，我觉得我也不是很懂，所以还是不在这班门弄斧了，大家可以看下这篇文章：<a href="https://medium.com/@kazafchen/kotlin%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97-%E4%BA%8C-any%E8%88%87nothing%E9%96%93%E7%9A%84%E5%A5%87%E5%A6%99%E9%97%9C%E4%BF%82-%E4%BB%A5%E5%8F%8A%E8%88%87java%E4%B8%ADvoid%E7%9A%84%E6%84%9B%E6%81%A8%E6%83%85%E4%BB%87-f60477cab752">传送门</a></p>
<h1 id="2-包与导入"><a href="#2-包与导入" class="headerlink" title="2. 包与导入"></a>2. 包与导入</h1><h2 id="2-1-包"><a href="#2-1-包" class="headerlink" title="2.1 包"></a>2.1 包</h2><p>和Java一样，Kotlin的包也是在文件最前面用<code>package</code>开头：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> kotlinstudy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-2-导入"><a href="#2-2-导入" class="headerlink" title="2.2 导入"></a>2.2 导入</h2><p>和Java一样，Kotlin导入包也是使用<code>import</code>关键字。</p>
<p>并且也是可以单独导入一个独特的名字：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.example.Message</span><br></pre></td></tr></table></figure><br>也可以导入这个下面的所有内容：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.example.*</span><br></pre></td></tr></table></figure></p>
<p>如果出现的名字发生冲突，比方说导入的最终的名字都是<code>Message</code>，只不过属于不同的包下面的，这个时候就可以使用<code>as</code>关键字来在本地进行重命名：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.example.Message <span class="comment">// Message 可访问</span></span><br><span class="line"><span class="keyword">import</span> org.test.Message <span class="keyword">as</span> testMessage <span class="comment">// testMessage 代表“org.test.Message”</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin入门(四)——类和对象的进阶</title>
    <url>/posts/6f3ca960.html</url>
    <content><![CDATA[<h1 id="Kotlin入门-四-——类和对象的进阶"><a href="#Kotlin入门-四-——类和对象的进阶" class="headerlink" title="Kotlin入门(四)——类和对象的进阶"></a>Kotlin入门(四)——类和对象的进阶</h1><blockquote>
<p>本章内容包括：</p>
<ul>
<li>可空性</li>
<li>数据类</li>
<li>密封类</li>
<li>枚举类</li>
</ul>
</blockquote>
<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>在上一篇<a href="https://blog.csdn.net/a1203991686/article/details/106648619">《Kotlin入门(三)——类、对象、接口》</a></p>
<p>我们只聊到了Kotlin中基本类的写法以及继承，但是我们说过，Kotlin的本质就是解决Java的繁琐，如果Kotlin只有这么简单的话怎么还能被称为Kotlin。</p>
<span id="more"></span>
<p>首先我们思考在Java中的几个场景：</p>
<ul>
<li>在方法中每次都得对传进来的对象进行判空，并且很多时候都会忘记判空或者不知道别人在调用你这个方法的时候到底会不会给空，然后就导致程序空指针异常了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">nullTest</span><span class="params">(Obj obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每次在Java中写JavaBean的时候，一旦数据变多，就得写一大堆的getter、setter、toString、equals等等方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String telephone;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String firstName, String lastName, String telephone, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">        <span class="built_in">this</span>.telephone = telephone;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFirstName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirstName</span><span class="params">(String firstName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLastName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastName</span><span class="params">(String lastName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTelephone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> telephone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTelephone</span><span class="params">(String telephone)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.telephone = telephone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果在Kotlin中，上面两个问题还刚好可以通过可空性和数据类去解决。</p>
<p>那可能有的同学会问，你上面不还有一个密封类吗，那他有啥方便之处呢？这个我们先卖个关子，我们放到后面来谈这个。</p>
<h1 id="1-可空性"><a href="#1-可空性" class="headerlink" title="1. 可空性"></a>1. 可空性</h1><p>在Kotlin中，可空性是Kotlin和Java最显著的区别之一，他能非常高效的帮助我们开发者去避免<code>NullPointerException</code>。</p>
<p>Kotlin对于可空性的处理就是把这个运行时的错误转成了编译期的错误，这样我们在编译时就能发现很多存在的错误，从而减少运行时抛出异常的可能性。</p>
<h2 id="1-1-可空类型"><a href="#1-1-可空类型" class="headerlink" title="1.1 可空类型"></a>1.1 可空类型</h2><p>首先，Kotlin支持对可空类型的显式。这句话可能读起来觉得莫名其妙，其实简单点说就是：这是一种可以直接指出你的程序中哪些变量和属性允许为<code>null</code>的方式。</p>
<p>我们还是从同样的功能的代码的Java版入手。</p>
<p>我们先来看下最常见的一种Java的代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strLen</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>恐怕这个代码一写出来，很多哪怕是新手的Java程序员都能指出他的问题：如果传入的<code>s</code>是<code>null</code>，这个程序就崩溃了。</p>
<p>那我们现在来试着用Kotlin去重写这个函数，但是在重写之前，我们首先得考虑我们调用这个函数的时候，传入的实参，是否可以为null。</p>
<p>如果我们不希望传入的s为null，我们就可以直接使用最基本的Kotlin函数的写法：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strLen</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候如果我们在调用strLen的地方给他传入一个null进去，我们甚至都不用编译这段代码，IDEA就会自动帮我们把这块代码给标注出来(报错)，不能传入一个null进去:<br><img src="https://cdn.littlecorgi.top/mweb/2020-06-23/Kotlin%E5%85%A5%E9%97%A8-%E5%9B%9B-1.png" alt="Kotlin入门-四-1"></p>
<p>在这个函数中，由于函数的形参被声明为了String(请注意：这个String只是String)，所以Kotlin就会认为你传入的这个String类型的参数必须为String的对象，而不可以为null。</p>
<p>但是如果我们想让它可以传入null呢？这个时候我们就需要显式的在类型名称后面加上问号了：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strLen</span><span class="params">(s: <span class="type">String</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候我们就可以直接像上图中的那种方式去调用这个函数。</p>
<p>问号可以加在任何类型的后面，表示这个类型的变量可以为null。</p>
<p>但是其实你像我上面说的那样改了之后，其实IDEA也还是会报错：<br><img src="https://cdn.littlecorgi.top/mweb/2020-06-23/Kotlin%E5%85%A5%E9%97%A8-%E5%9B%9B-2.png" alt="Kotlin入门-四-2"></p>
<p>这是因为如果你让一个变量可空了之后，你就没办法直接对他进行操作，也不能把它赋值给非空类型的变量，也不能把可空类型的值传给拥有非空类型参数的函数。</p>
<p>但是Kotlin和Java一样，你只要在外面对s判断不等于null了之后，就可以在if的函数体中对他直接进行操作了：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strLen</span><span class="params">(s: <span class="type">String</span>?)</span></span> = <span class="keyword">if</span> (s != <span class="literal">null</span>) s.length <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>但是这个时候，你一定会满头问号，因为你一定会吐槽，这个代码和Java有啥区别，Java甚至都不需要加问号(<code>?</code>)。</p>
<p>其实我讲了这么多，只是为了引出Kotlin对于空的一大堆好用的操作，接下来，我们就先来说一下安全调用运算符。</p>
<h2 id="1-2-安全调用运算符："><a href="#1-2-安全调用运算符：" class="headerlink" title="1.2 安全调用运算符：?."></a>1.2 安全调用运算符：<code>?.</code></h2><p>回归到刚才那个问题，Kotlin是如何解决<code>if (s != null)</code>的。</p>
<p>其实要解决那个<code>if(s != null)</code>很简单，就用<code>?.</code>就行了：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strLen</span><span class="params">(s: <span class="type">String</span>?)</span></span> = s?.length</span><br></pre></td></tr></table></figure></p>
<p>其实<code>?.</code>他就是把null检查和执行代码合成了一个操作：<br><img src="https://cdn.littlecorgi.top/mweb/2020-06-23/Kotlin%E5%85%A5%E9%97%A8-%E5%9B%9B-3.jpg" alt="Kotlin入门-四-3"></p>
<p>值得注意的是，图里面后面的两个表达式其实是返回值，也就是说当<code>s</code>为<code>null</code>的时候，<code>s?.length</code>返回值其实是<code>null</code>。</p>
<p>安全调用不止可以调用方法，也可以用来访问属性。</p>
<p>但是这个时候你可能会说，这不对啊，Java的代码的作用是当<code>s</code>为<code>null</code>的时候返回<code>0</code>啊，但是你上面的那个Kotlin代码当<code>s</code>为<code>null</code>的时候，却返回了<code>null</code>。</p>
<p>我只能说你图样图森破，其实这个套路和刚才过度到<code>?.</code>的时候一样，我们可以继续用Kotlin给定的特殊语句(也就是Elvis运算符<code>?:</code>)去解决这个问题。</p>
<h2 id="1-3-Elvis运算符："><a href="#1-3-Elvis运算符：" class="headerlink" title="1.3 Elvis运算符：?:"></a>1.3 Elvis运算符：<code>?:</code></h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strLen</span><span class="params">(s: <span class="type">String</span>?)</span></span> = s?.length ?: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>同样，也会有一个流程图去让你更容易理解这个代码的流程，只不过这个时候我们需要将<code>s?.length</code>看做是一个整体：<br><img src="https://cdn.littlecorgi.top/mweb/2020-06-23/Kotlin%E5%85%A5%E9%97%A8-%E5%9B%9B-4.jpg" alt="Kotlin入门-四-4"></p>
<p>我们可以简化<code>?:</code>的用法，其实就是<code>a ?: b</code>，也就是说，当<code>a</code>的值不为<code>null</code>的时候，就返回<code>a</code>，但是当<code>a</code>的值为<code>null</code>的时候，就返回<code>b</code>。</p>
<p>也就是说，当<code>s?.length</code>的值不为<code>null</code>的时候，就返回<code>s.length</code>(因为此处<code>s?.length</code>的值不为<code>null</code>，所以就相当于<code>s.length</code>)，但是如果当<code>s?.length</code>的值为<code>null</code>的时候，就返回<code>0</code>。</p>
<p>并且对于<code>?:</code>，我们其实还有一个非常方便的操作，就是当我们需要返回null或者需要抛异常的时候：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(node: <span class="type">Node</span>)</span></span>: String? &#123;</span><br><span class="line">    <span class="keyword">val</span> parent = node.getParent() ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> name = node.getName() ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;name expected&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-4-安全转换：as"><a href="#1-4-安全转换：as" class="headerlink" title="1.4 安全转换：as?"></a>1.4 安全转换：<code>as?</code></h2><p>我们在之前说到过，Kotlin主要通过<code>as</code>运算符来进行类型转换。</p>
<p>但是和Java的类型转换一样，如果被转换的值不是你试图转换的类型时，就会抛出<code>ClassCastException</code>异常。虽说可以结合<code>is</code>检查来确定这个值拥有合适的类型，但是Kotlin一定会有更加优雅的方式。</p>
<p><code>as?</code>就可以将值转换成指定的类型，如果不是合适的类型就返回<code>null</code>：<br><img src="https://cdn.littlecorgi.top/mweb/2020-06-23/Kotlin%E5%85%A5%E9%97%A8-%E5%9B%9B-5.jpg" alt="Kotlin入门-四-5"></p>
<p>一种常见的模式就是可以用于重写<code>equals()</code>方法：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> otherPerson = other <span class="keyword">as</span>? Person ?: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> otherPerson.name == <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-5-非空断言："><a href="#1-5-非空断言：" class="headerlink" title="1.5 非空断言：!!"></a>1.5 非空断言：<code>!!</code></h2><p>非空断言是Kotlin提供的最简单粗暴的一个处理可空类型的工具。他的作用就像他的样子一样，表示我就让这个类型转换成非空类型。<br><img src="https://cdn.littlecorgi.top/mweb/2020-06-23/Kotlin%E5%85%A5%E9%97%A8-%E5%9B%9B-6.jpg" alt="Kotlin入门-四-6"></p>
<p>这种和Java一样，所以也就没啥好说的。</p>
<h2 id="1-6-let函数"><a href="#1-6-let函数" class="headerlink" title="1.6 let函数"></a>1.6 <code>let</code>函数</h2><p>其实这个<code>let</code>函数属于后面标准函数的内容，但是由于标准函数中的每一个函数都是服务于具体某个功能的，所以就放在功能这块来说这个函数。</p>
<p><code>let</code>函数天生就是为<code>?.</code>服务的。</p>
<p>我们回到上面那个例子，如果我们想在返回<code>s</code>的<code>length</code>之前先让他删除调最前面或者最后面的空格：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strLen</span><span class="params">(s: <span class="type">String</span>?)</span></span> = s?.let &#123; str -&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        str.trim()</span><br><span class="line">        str.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般情况，Kotlin的lambda表达式都会将语句的最后一句作为return。</p>
<p>但是在Kotlin的lambda表达式中，我们可以用自动生成的名字<code>it</code>：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strLen</span><span class="params">(s: <span class="type">String</span>?)</span></span> = s?.let &#123;</span><br><span class="line">    it.trim()</span><br><span class="line">    it.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至于为啥是<code>it</code>，这个是Kotlin的lambda表达式的特殊字符，就类似于setter和getter中的<code>field</code>字段一样的。</p>
<h2 id="1-7-可空类型的集合"><a href="#1-7-可空类型的集合" class="headerlink" title="1.7 可空类型的集合"></a>1.7 可空类型的集合</h2><p>Kotlin也可以创建值为null的集合，比如：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> nullsArray = arrayOfNulls&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>) <span class="comment">// 元素类型为Int，容量为1的初始值全为null的数组</span></span><br><span class="line"><span class="keyword">val</span> nullsArrayList = ArrayList&lt;<span class="built_in">Int</span>?&gt;() <span class="comment">// 泛型为Int?的ArrayList</span></span><br></pre></td></tr></table></figure></p>
<p>如果你有一个可空类型元素的集合，并且想要过滤非空元素，你可以使用<code>filterNotNull</code>来实现：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> nullableList: List&lt;<span class="built_in">Int</span>?&gt; = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> intList: List&lt;<span class="built_in">Int</span>&gt; = nullableList.filterNotNull()</span><br></pre></td></tr></table></figure></p>
<h1 id="2-数据类"><a href="#2-数据类" class="headerlink" title="2. 数据类"></a>2. 数据类</h1><p>我们在前言举的例子说到过，Kotlin对于之前的饱受诟病的JavaBean做了一个非常好的处理。</p>
<p>对于这类只需要保存数据的容器，往往你都需要去重写他们的一些方法，比如<code>toString()</code>、<code>equals()</code>、<code>hashCode()</code>等方法，这些方法的写法又特别的机械，像Idea和eclipse都提供了自动生成的方法。</p>
<p>但是在Kotlin里面，你就不必再去手动去操作这些方法了。在Kotlin中，这些类叫做数据类，并且只需要在<code>class</code>的前面添加<code>data</code>修饰符：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure></p>
<p>在声明为数据类后，Kotlin就能自动的帮你重写以下方法：</p>
<ul>
<li><code>hashCode()</code>：这个方法不用多介绍了，和Java中一样</li>
<li><code>equals()</code>：这个方法也不用多介绍了，和Java中一样</li>
<li><code>toString()</code>：这个方法仍然不用多介绍了，和Java中一样</li>
<li><code>componentN()</code>：这个函数是用来<a href="https://www.kotlincn.net/docs/reference/multi-declarations.html">解构声明</a>的，见下文</li>
<li><code>copy()</code>：见下文</li>
</ul>
<p>我们可以看一下上面那个类的字节码(<a href="https://blog.csdn.net/a1203991686/article/details/106379486#t1">看字节码的方法在此</a>)：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="meta">@NotNull</span> String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(name, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">      <span class="built_in">super</span>();</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">component1</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">component2</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Person <span class="title function_">copy</span><span class="params">(<span class="meta">@NotNull</span> String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(name, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(name, age);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Person copy$<span class="keyword">default</span>(Person var0, String var1, <span class="type">int</span> var2, <span class="type">int</span> var3, Object var4) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((var3 &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">         var1 = var0.name;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((var3 &amp; <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">         var2 = var0.age;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> var0.copy(var1, var2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Person(name=&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;, age=&quot;</span> + <span class="built_in">this</span>.age + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">var10000</span> <span class="operator">=</span> <span class="built_in">this</span>.name;</span><br><span class="line">      <span class="keyword">return</span> (var10000 != <span class="literal">null</span> ? var10000.hashCode() : <span class="number">0</span>) * <span class="number">31</span> + <span class="built_in">this</span>.age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(<span class="meta">@Nullable</span> Object var1)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span> != var1) &#123;</span><br><span class="line">         <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">var2</span> <span class="operator">=</span> (Person)var1;</span><br><span class="line">            <span class="keyword">if</span> (Intrinsics.areEqual(<span class="built_in">this</span>.name, var2.name) &amp;&amp; <span class="built_in">this</span>.age == var2.age) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，如果上面的方法中任何一个已经有了显式的实现，那么数据类在生成的时候，就不会再去重新生成这个函数，而是会直接使用显式的这个函数。</p>
<h2 id="2-1-无参构造"><a href="#2-1-无参构造" class="headerlink" title="2.1 无参构造"></a>2.1 无参构造</h2><p>如果数据类需要一个无参构造，那么就需要对每个属性都指定默认值：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String = <span class="string">&quot;&quot;</span>, <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><br>这样就会有一个无参构造。</p>
<h2 id="2-2-在类中声明的属性"><a href="#2-2-在类中声明的属性" class="headerlink" title="2.2 在类中声明的属性"></a>2.2 在类中声明的属性</h2><p>数据类也可以在类的里面去声明属性：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> address: String = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是需要注意的是，这样的话，数据类帮你生成的那些方法(<code>equals()</code>、<code>toString()</code>等)，都不会带上<code>address</code>这个属性。除非你自己显式重写对应的方法。</p>
<h2 id="2-3-copy"><a href="#2-3-copy" class="headerlink" title="2.3 copy()"></a>2.3 copy()</h2><p>我们上面说到，数据类会自动帮我们生成<code>copy()</code>方法，那么这个<code>copy</code>到底是干嘛的呢？</p>
<p>其实说句实话，我觉得这个方法的话，也有点鸡肋，也就是那种食之无味，但是又弃之可惜的东西(这么说存在一定的绝对)，但是也无所谓，能多点功能，能让我们少写点代码当然是好的了。</p>
<p>好了，说回来，这个方法到底是干嘛的呢？其实单看名字就能看出来，肯定与复制有关，但是他到底是复制啥呢。</p>
<p>其实在有些时候，如果我们需要生成这个类的另外一个对象，但是很多属性都和这个类的原本的对象都是一样的，我们只需要修改他其中的某一个属性，那么这个时候<code>copy()</code>就很有用了：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> jack = Person(<span class="string">&quot;Jack&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> oldJack = jack.copy(age = <span class="number">28</span>)</span><br></pre></td></tr></table></figure><br>我们就可以通过去调用<code>jack</code>的<code>copy()</code>方法，在参数中指定我们需要修改的属性，这样就可以返回一个除了指定的属性外，其它属性都和原对象一样的一个新对象。</p>
<p>其实这个方法也还是非常有用的，但是我为什么又在上面说食之无味弃之可惜？因为说实话，我觉得这个东西，我们日常使用的着实少，可以说少之又少，但是单看概念又挺有用，并且如果真的让我们自己去重写这个方法，虽然说在技术层面，实现这个方法着实简单，但是一旦我们属性多了起来之后，重写起来还真的得花点功夫。</p>
<h2 id="2-4-解构声明"><a href="#2-4-解构声明" class="headerlink" title="2.4 解构声明"></a>2.4 解构声明</h2><p>对于Java来说，解构声明是一个新的东西，而这个，说实话，在我看来和上面那个<code>copy()</code>差不多，也是一个食之无味弃之可惜的东西。但是，这是相对于数据类来说的。我为啥这么说呢，继续往下看就知道了。</p>
<p>首先我们直接上代码，看下解构声明到底是什么：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> jack = Person(<span class="string">&quot;Jack&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> (name, age) = jack</span><br><span class="line">println(<span class="string">&quot;<span class="variable">$name</span>&#x27;s age is <span class="variable">$age</span>&quot;</span>)</span><br></pre></td></tr></table></figure><br>其中第二行那就是解构声明，也就是说，我们可以将某个对象的所有属性给单独拎出来。</p>
<p>看到这，是不是也会和我一样产生一个感觉，这个东西着实意义不大，我们想去获取某个属性的话，直接调用这个类的属性的<code>getter</code>不就行了吗。</p>
<p>但是我刚刚说了，我觉得这个东西很鸡肋，是针对于数据类来说的，下面我给你看个代码你就会觉得这个东西非常有用了：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> map = HashMap&lt;String, Person&gt;()</span><br><span class="line"><span class="keyword">for</span> ((name, person) <span class="keyword">in</span> map) &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$name</span> to (<span class="subst">$&#123;person.name&#125;</span>, <span class="subst">$&#123;person.age&#125;</span>)&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="3-密封类"><a href="#3-密封类" class="headerlink" title="3. 密封类"></a>3. 密封类</h1><p>其实密封类很简单，没啥特别的东西，</p>
<p>我们先来看一个例子：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Expr</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Num</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) : Expr</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sum</span>(<span class="keyword">val</span> left: Expr, <span class="keyword">val</span> right: Expr) : Expr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">    <span class="keyword">when</span> (e) &#123;</span><br><span class="line">        <span class="keyword">is</span> Num -&gt; e.value</span><br><span class="line">        <span class="keyword">is</span> Sum -&gt; eval(e.left) + eval(e.right)</span><br><span class="line">        <span class="keyword">else</span> -&gt;</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Unknown expression&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>我们定义了一个父类(接口)<code>Expr</code>，以及他的两个子类：代表数字的<code>Num</code>和代表和的<code>Sum</code>，然后我们在<code>when</code>中去处理所有的操作。</p>
<p>目前来说这样很方便，但是其实有一点很多余，就是我们完全没有必要去写<code>when</code>中的<code>else</code>分支，因为他完全不可能是其他类型。并且如果我们新增了一个<code>Expr</code>的子类，万一忘记了在<code>when</code>添加对应的分支，那么程序就存在bug。</p>
<p>这个时候，我们的密封类就派上用场了。在Kotlin官方文档，对密封类的定义很简单：“密封类用来表示受限的类继承结构：当一个值为有限几种的类型、而不能有任何其他类型时。”。也就是说上面这种情况，我们非常明确Expr不可能会再有其它的子类的，所以就没有必要再去写else分支。</p>
<p>而实现密封类也很简单，在class前面加上sealed。接下来我们使用密封类改写一下上面那个例子：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Expr</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Num</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) : Expr()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sum</span>(<span class="keyword">val</span> left: Expr, <span class="keyword">val</span> right: Expr) : Expr()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">    <span class="keyword">when</span> (e) &#123;</span><br><span class="line">        <span class="keyword">is</span> Num -&gt; e.value</span><br><span class="line">        <span class="keyword">is</span> Sum -&gt; eval(e.left) + eval(e.right)</span><br><span class="line">        <span class="comment">// 不再需要else，</span></span><br><span class="line">        <span class="comment">// 并且如果你写了else，编译器会提示你&#x27;when&#x27; is exhaustive so &#x27;else&#x27; is redundant here</span></span><br><span class="line">        <span class="comment">// else -&gt;</span></span><br><span class="line">        <span class="comment">//     throw IllegalArgumentException(&quot;Unknown expression&quot;)</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="4-枚举类"><a href="#4-枚举类" class="headerlink" title="4. 枚举类"></a>4. 枚举类</h1><p>对于枚举类，Kotlin和Java的用法没啥区别。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    NORTH, SOUTH, WEST, EAST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-1-初始化"><a href="#4-1-初始化" class="headerlink" title="4.1 初始化"></a>4.1 初始化</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Color</span>(<span class="keyword">val</span> rgb: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        RED(<span class="number">0xFF0000</span>),</span><br><span class="line">        GREEN(<span class="number">0x00FF00</span>),</span><br><span class="line">        BLUE(<span class="number">0x0000FF</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-嵌套类"><a href="#5-嵌套类" class="headerlink" title="5. 嵌套类"></a>5. 嵌套类</h1><h2 id="5-1-嵌套类"><a href="#5-1-嵌套类" class="headerlink" title="5.1 嵌套类"></a>5.1 嵌套类</h2><p>在Java中，我们很多时候都会在一个类里面再去声明一个类，这种类就叫做内部类。</p>
<p>而Kotlin把这种类叫做嵌套类。简单来说就是把这个类嵌套在了另一个类里面：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name: Name = Name(<span class="string">&quot;William&quot;</span>, <span class="string">&quot;Shakespeare&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Name</span>(<span class="keyword">val</span> firstName: String, <span class="keyword">val</span> lastName: String)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但是，你如果把上面这段代码翻译成字节码的话，你会发现其实这个嵌套类，他是<code>static</code>的，也就是说，他不持有外部类的引用，并且你在嵌套类中，没法直接使用外部类的属性或者方法。</p>
<p>所以，我们在Android中写<code>Handler</code>的时候，我们就直接写一个<code>Handler</code>的嵌套类就行了。</p>
<h2 id="5-2-内部类"><a href="#5-2-内部类" class="headerlink" title="5.2 内部类"></a>5.2 内部类</h2><p>但是如果你就是想写一个普通的内部类，就是一个没有<code>static</code>修饰的内部类，那么Kotlin就提供了一个<code>inner</code>关键字：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name: Name = Name(<span class="string">&quot;William&quot;</span>, <span class="string">&quot;Shakespeare&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Name</span>(<span class="keyword">val</span> firstName: String, <span class="keyword">val</span> lastName: String) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;<span class="variable">$firstName</span> <span class="variable">$lastName</span>&#x27;s age is <span class="variable">$age</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样，<code>Name</code>这个类，就是一个非<code>static</code>的内部类了，并且他会持有外部类<code>Person</code>的引用，所以我们可以直接访问外部类的属性，上面那个<code>Name</code>类中的<code>print()</code>方法才可以去访问<code>Person</code>的属性<code>age</code>。</p>
<h2 id="5-3-匿名内部类"><a href="#5-3-匿名内部类" class="headerlink" title="5.3 匿名内部类"></a>5.3 匿名内部类</h2><p>在Java中我们经常会使用到匿名内部类，比方说我们写Callback回调的时候：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">call.enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>&lt;Translation&gt;() &#123;</span><br><span class="line">    <span class="comment">//请求成功时回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call&lt;Translation&gt; call, Response&lt;Translation&gt; response)</span> &#123;</span><br><span class="line">        <span class="comment">// 对返回数据进行处理</span></span><br><span class="line">        response.body().show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求失败时候的回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call&lt;Translation&gt; call, Throwable throwable)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>这个时候，enqueue传入的就是一个继承自Callback类的匿名内部类。</p>
<p>而在Kotlin中，也是差不多的形式，只不过我们需要借用下<code>object</code>关键字：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">call.enqueue(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">T</span>&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;连接失败&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">T</span>&gt;, response: <span class="type">Response</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        response?.body().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin入门1:Kotlin和Java区别基础篇</title>
    <url>/posts/343b01ae.html</url>
    <content><![CDATA[<h1 id="Koltin入门"><a href="#Koltin入门" class="headerlink" title="Koltin入门"></a>Koltin入门</h1><h1 id="Kotlin简介"><a href="#Kotlin简介" class="headerlink" title="Kotlin简介"></a>Kotlin简介</h1><blockquote>
<p>科特林岛(Котлин)是一座俄罗斯的岛屿,位于圣彼得堡以西约30公里处,形状狭长,东西长度约14公里,南北宽度约2公里,面积有16平方公里,扼守俄国进入芬兰湾的水道。科特林岛上建有喀琅施塔得市,为圣彼得堡下辖的城市。</p>
</blockquote>
<p>而我们虽说的kotlin，就是一门根据它命名的一种现代程序设计语言。Kotlin 是一个用于现代多平台应用的静态编程语言，由 JetBrains 开发。Kotlin可以编译成Java字节码，也可以编译JavaScript，方便在没有JVM的设备上运行。Kotlin已正式成为Android官方支持开发语言。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><span id="more"></span></h2><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>kotlin和Java的最基本的区别就是kotlin中<strong>万物皆对象</strong>，Java中还存在着int、float等基本类型，但是在kotlin中，它把这些都定义成了对象，类似于Java中的封装类</p>
<h2 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h2><p>上面说了，kotlin万物皆对象，所以所有的变量也都是对象。<br>在kotlin定义对象和Java有点小区别。<br>kotlin定义对象的格式为</p>
<blockquote>
<p> 声明类型 变量名： 变量类型</p>
</blockquote>
<p>其中：</p>
<ul>
<li>声明类型分为<code>val</code>和<code>var</code>。<code>val</code>是不可变类型，类似于const，定义时必须赋值，赋值后不能被修改。<code>var</code>是可变类型。</li>
<li>变量名就是你定义的这个变量的名称。</li>
<li>变量类型就是你这个变量对应的类的名字。</li>
</ul>
<h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><h3 id="省去变量类型"><a href="#省去变量类型" class="headerlink" title="省去变量类型"></a>省去变量类型</h3><p>kotlin里面类似c++的<code>auto</code>类型，对于基本类型，你可以不写变量类型，kotlin会自动帮你判断。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line">println(a <span class="keyword">is</span> <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = “<span class="number">123</span></span><br><span class="line">println(b <span class="keyword">is</span> String)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">1.3</span></span><br><span class="line">println(c <span class="keyword">is</span> <span class="built_in">Float</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">true</span></span><br><span class="line">println(d <span class="keyword">is</span> <span class="built_in">Boolean</span>)</span><br></pre></td></tr></table></figure>
<h3 id="is关键字"><a href="#is关键字" class="headerlink" title="is关键字"></a><code>is</code>关键字</h3><p><code>is</code>顾名思义，就是判断这个变量是不是这个类型的实例。<br>例子见上。</p>
<h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>宽度(bit)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Byte</td>
<td>8</td>
</tr>
<tr>
<td>Short</td>
<td>16</td>
</tr>
<tr>
<td>Int</td>
<td>32</td>
</tr>
<tr>
<td>Long</td>
<td>64</td>
</tr>
<tr>
<td>Float</td>
<td>32</td>
</tr>
<tr>
<td>Double</td>
<td>64</td>
</tr>
</tbody>
</table>
</div>
<p>这些类型都继承自<code>Number</code>和<code>Comparable</code>类。</p>
<h3 id="字面常量值"><a href="#字面常量值" class="headerlink" title="字面常量值"></a>字面常量值</h3><ul>
<li>十进制：<code>123</code></li>
<li>十六进制：<code>0x0f</code></li>
<li>二进制：<code>0b0010</code></li>
<li>Long类型：<code>123L</code></li>
<li>double类型：123.4</li>
<li>Float类型：<code>123.4f</code>或者<code>123.4F</code></li>
</ul>
<p>我们也可以使用下划线<code>_</code>来方便我们阅读</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="number">1_000_000</span> <span class="comment">// 1000000</span></span><br><span class="line"><span class="number">0xFF_EC</span> <span class="comment">// 0xFFEC</span></span><br></pre></td></tr></table></figure>
<h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><p>kotlin中不可隐式转换<br>比如Java 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br></pre></td></tr></table></figure>
<p>但是在kotlin中</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a : <span class="built_in">Int</span>? = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> b : <span class="built_in">Long</span>? = a; <span class="comment">// error</span></span><br><span class="line"><span class="keyword">var</span> b : <span class="built_in">Long</span>? = a.toLong()</span><br></pre></td></tr></table></figure>
<h2 id="Char类型"><a href="#Char类型" class="headerlink" title="Char类型"></a>Char类型</h2><p>kotlin中的<code>Char</code>表示字符。但是和Java不同，他不能直接当ASCII码值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(c : <span class="type">Char</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123; <span class="comment">// error </span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h2><p>kotlin中的布尔类型用<code>Boolean</code>来表示，他有两个值<code>true</code>和<code>false</code>。用法和Java一样。</p>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>和Java一样，kotlin中的字符串也是<code>String</code>。但是kotlin中<code>String</code>是不可变的。所以kotlin中<code>String</code>必须是<code>val</code>类型。同时，<code>String</code>是<code>final</code>不可继承的。</p>
<h2 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h2><p>kotlin中数组必须使用<code>Array</code>表示。<br>基本写法</p>
<blockquote>
<p>val array: Array&lt;类型&gt; = arrayOf(..)</p>
</blockquote>
<p>例如<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**整型Int的数组*/</span></span><br><span class="line"><span class="keyword">val</span> arrayOfInt: IntArray = intArrayOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line"><span class="comment">/**字符Char类型的数组*/</span></span><br><span class="line"><span class="keyword">val</span> arrayOfChar: CharArray = charArrayOf(<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"><span class="comment">/**字符串String数组*/</span></span><br><span class="line"><span class="keyword">val</span> arrayOfString: Array&lt;String&gt; = arrayOf(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;World&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//查看有多少个元素</span></span><br><span class="line">    println(arrayOfInt.size)</span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (char <span class="keyword">in</span> arrayOfChar)&#123;</span><br><span class="line">        println(char)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据所引获取数据,数组是从0开始的，现在获取第二个东京大学</span></span><br><span class="line">    println(arrayOfUniversity[<span class="number">1</span>])</span><br><span class="line">    <span class="comment">//重新给数组赋值，早稻田大学</span></span><br><span class="line">    arrayOfUniversity[<span class="number">1</span>] = University(<span class="string">&quot;早稻田大学&quot;</span>)</span><br><span class="line">    println(arrayOfUniversity[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将char连接成一个字符串,默认是自动由逗号&quot;,&quot;分割的，输出H, e, l, l, o, W, o, r, l, d</span></span><br><span class="line">    println(arrayOfChar.joinToString())</span><br><span class="line">    <span class="comment">//如果想要连成HelloWorld</span></span><br><span class="line">    println(arrayOfChar.joinToString (<span class="string">&quot;&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组的切片,输出3，5,结尾需要arrayOfInt-1，不然会报索引越界异常</span></span><br><span class="line">    println(arrayOfInt.slice(<span class="number">1.</span><span class="number">.2</span>))</span><br><span class="line"></span><br><span class="line">    println(arrayOfInt.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Next配置备份</title>
    <url>/posts/5b6e53a4.html</url>
    <content><![CDATA[<h1 id="Hexo配置备份"><a href="#Hexo配置备份" class="headerlink" title="Hexo配置备份"></a>Hexo配置备份</h1><span id="more"></span>
<h1 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h1><ul>
<li>来必力 - <a href="https://www.livere.com/">https://www.livere.com/</a></li>
<li>valine(在用) - <a href="https://valine.js.org/">https://valine.js.org/</a></li>
</ul>
<h1 id="阅读量显示"><a href="#阅读量显示" class="headerlink" title="阅读量显示"></a>阅读量显示</h1><ul>
<li>leancloud - <a href="https://leancloud.cn/">https://leancloud.cn/</a></li>
<li>valine(在用) - <a href="https://valine.js.org/">https://valine.js.org/</a></li>
</ul>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL ES 2.0笔记1——简介</title>
    <url>/posts/a92b4a54.html</url>
    <content><![CDATA[<h1 id="OpenGL是什么？OpenGL-ES又是什么？"><a href="#OpenGL是什么？OpenGL-ES又是什么？" class="headerlink" title="OpenGL是什么？OpenGL ES又是什么？"></a>OpenGL是什么？OpenGL ES又是什么？</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>OpenGL是一个跨平台的软件接口语言，用于调用硬件的2D、3D图形处理器。</p>
<p>然而受限于现在的移动设备性能，如果将OpenGL直接用在他们上面将会特别卡，于是就出现了OpenGL ES。 OpenGL ES是OpenGL的分支，他专门作用于嵌入式设备，去掉了OpenGL很多不必要的功能。</p>
<span id="more"></span>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>游戏</li>
<li>视频播放器</li>
<li>视频编辑应用</li>
<li>图片编辑应用</li>
</ul>
<p>等对图像处理的及时性要求较高的应用场景。</p>
<h2 id="Android对OpenGL-ES-的支持"><a href="#Android对OpenGL-ES-的支持" class="headerlink" title="Android对OpenGL ES 的支持"></a>Android对OpenGL ES 的支持</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">OpenGL ES 版本</th>
<th style="text-align:center">基于OpenGL的版本</th>
<th style="text-align:center">Android引入的版本</th>
<th style="text-align:center">兼容性</th>
<th style="text-align:center">功能、特色</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1.0&amp;1.1</td>
<td style="text-align:center">1.3&amp;1.5</td>
<td style="text-align:center">Android 1.0</td>
<td style="text-align:center">-</td>
<td style="text-align:center">固定的图像管道，开发难度相比2.0低</td>
</tr>
<tr>
<td style="text-align:center">2.0</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">Android 2.2</td>
<td style="text-align:center">不兼容1.x</td>
<td style="text-align:center">可编程的渲染管道，性能效率更高，开发难度更高</td>
</tr>
<tr>
<td style="text-align:center">3.0</td>
<td style="text-align:center">3.x</td>
<td style="text-align:center">Android 4.3</td>
<td style="text-align:center">兼容2.0</td>
<td style="text-align:center">性能更高，支持ETC2格式的透明纹理压缩</td>
</tr>
<tr>
<td style="text-align:center">3.1</td>
<td style="text-align:center">4.x</td>
<td style="text-align:center">Android 5.0</td>
<td style="text-align:center">兼容2.0/3.0</td>
<td style="text-align:center">新增计算着色器、单独的着色器对象等新特性</td>
</tr>
</tbody>
</table>
</div>
<h2 id="版本的选择"><a href="#版本的选择" class="headerlink" title="版本的选择"></a>版本的选择</h2><p>由于此篇博客是学习阶段写的，而我在网上找到的大部分博客都是2.0，所以就以2.0为主。</p>
<p>其实我觉得应该是3.0，2.0确实太老了，现在Android4.3的手机都较少见了，而3.1又太新了。</p>
<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>首先你得在AndroidManifest.xml中加入<br><code>&lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; android:required=&quot;true&quot; /&gt;</code></p>
<p>其中不同版本对应值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">OpenGL ES 版本</th>
<th style="text-align:center">glEsVersion 版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2.0</td>
<td style="text-align:center">0x00020000</td>
</tr>
<tr>
<td style="text-align:center">3.0</td>
<td style="text-align:center">0x00030000</td>
</tr>
<tr>
<td style="text-align:center">3.1</td>
<td style="text-align:center">0x00030001</td>
</tr>
</tbody>
</table>
</div>
<h1 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h1><p>Android框架里面提供了两个类来给你使用OpenGL ES API创建和操作图形：<code>GLSrufaceView</code>和<code>GLSurfaceView.Renderer</code>。</p>
<h2 id="GLSrufaceView"><a href="#GLSrufaceView" class="headerlink" title="GLSrufaceView"></a>GLSrufaceView</h2><p>这是一个视图类，你可以通过OpenGL ES API来绘制和操作图形对象，他在功能上很类似与<code>SurfaceView</code>。你可以通过创建一个<code>SurfaceView</code>的实例并添加你的渲染器来使用这个类。</p>
<p>他的常用方法有：</p>
<ul>
<li><code>setEGLContextClientVersion</code>：设置OpenGL ES版本，2.0则设置2</li>
<li><code>onPause</code>：暂停渲染，最好是在<code>Activity</code>、<code>Fragment</code>的<code>onPause()</code>方法内调用，减少不必要的性能开销，避免不必要的崩溃</li>
<li><code>onResume</code>：恢复渲染，用法类比<code>onPause()</code></li>
<li><code>setRenderer</code>：设置渲染器</li>
<li><code>setRenderMode</code>：设置渲染模式</li>
<li><code>requestRender</code>: 请求渲染，由于是请求异步线程进行渲染，所以不是同步方法，调用后不会立刻就进行渲染。渲染会回调到<code>Renderer</code>接口的<code>onDrawFrame()</code>方法。</li>
<li><code>queueEvent</code>：插入一个<code>Runnable</code>任务到后台渲染线程上执行。相应的，渲染线程中可以通过<code>Activity</code>的<code>runOnUIThread</code>的方法来传递事件给主线程去执行</li>
</ul>
<p>其中，GLSurfaceView的渲染模式有：</p>
<ul>
<li><code>RENDERMODE_CONTINUOUSLY</code>：不停地渲染</li>
<li><code>RENDERMODE_WHEN_DIRTY</code>：只有调用了<code>requestRender()</code>之后才会触发渲染回调onDrawFrame方法</li>
</ul>
<h2 id="GLSurfaceView-Renderer"><a href="#GLSurfaceView-Renderer" class="headerlink" title="GLSurfaceView.Renderer"></a>GLSurfaceView.Renderer</h2><p>此接口定义了在GLSurfaceView中绘制图形所需的方法。必须将此接口的实现作为单独的类提供，并使用GLSurfaceView.setRenderer()将其添加到GLSurfaceView的实现类中。</p>
<p>他的主要方法有三个：</p>
<ul>
<li><code>onSurfaceCreated(GL10 gl, EGLConfig config)</code>：GLSurfaceView内的Surface被创建时会被调用到</li>
<li><code>onSurfaceChanged(GL10 gl, int width, int height)</code>：Surface尺寸改变时调用到</li>
<li><code>onDrawFrame(GL10 gl)</code>：渲染绘制每一帧时调用到</li>
</ul>
<p>一般情况下，首次创建GLSurfaceView时，会顺序调用<code>onSurfaceCreated()</code> -&gt; <code>onSurfaceChanged()</code> -&gt; <code>onDrawFrame()</code>。然后每绘制一帧，都会不停地回调<code>onDrawFrame()</code>方法。</p>
<h1 id="编写流程"><a href="#编写流程" class="headerlink" title="编写流程"></a>编写流程</h1><p>首先我们来写一个基本框架。</p>
<p>创建一个Android项目，然后Activity选择EmptyActivity。</p>
<p><strong>注意：本项目某些类或者方法通过AndroidStudio导入的时候会让你选择是从哪个包里面导入，一致选择<code>android.opengl.GLES20</code></strong></p>
<h2 id="编写Activity"><a href="#编写Activity" class="headerlink" title="编写Activity"></a>编写Activity</h2><p>打开我们项目的MainActivity，你就能看到熟悉的onCreate方法，接下来我们要对这个Activity进行一些更改。</p>
<p>首先，我们要创建一个GLSurfaceView的对象,并添加一个新的成员变量：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> GLSurfaceView glSurfaceView;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">rendererSet</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<p>接下来将<code>setContentView()</code>移除，并对glSurfaceView进行初始化：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    glSurfaceView = <span class="keyword">new</span> <span class="title class_">GLSurfaceView</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于我们是在写OpenGL ES2.0的代码，所以我们需要检测当前运行APP的系统支不支持OpenGL ES2.0。我们将下面几行代码添加到onCreate()里面去:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ActivityManager</span> <span class="variable">activityManager</span> <span class="operator">=</span> (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line"><span class="keyword">final</span> <span class="type">ConfigurationInfo</span> <span class="variable">configurationInfo</span> <span class="operator">=</span> activityManager.deviceConfigurationInfo();</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">supportsEs2</span> <span class="operator">=</span> configurationInfo.reqGlEsVersion &gt;= <span class="number">0x20000</span>;</span><br></pre></td></tr></table></figure></p>
<p>但是这段代码在模拟器上不能工作，因为GPU模拟部分有缺陷。为了使代码在模拟器上运行，我们要按如下代码修改检查条件：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">supportsEs2</span> <span class="operator">=</span> configurationInfo.reqGlEsVersion &gt;= <span class="number">0x20000</span></span><br><span class="line">    || (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1</span><br><span class="line">    &amp;&amp; (Build.FINGERPRINT.startsWith(<span class="string">&quot;generic&quot;</span>)</span><br><span class="line">    || Build.FINGERPRINT.startsWith(<span class="string">&quot;unknown&quot;</span>)</span><br><span class="line">    || Build.MODEL.contains(<span class="string">&quot;google_sdk&quot;</span>)</span><br><span class="line">    || Build.MODEL.contains(<span class="string">&quot;Emulator&quot;</span>)</span><br><span class="line">    || Build.MODEL.contains(<span class="string">&quot;Android SDK build for x86&quot;</span>)))</span><br></pre></td></tr></table></figure></p>
<p>接下来就是配置渲染表面：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (supportsEs2) &#123;</span><br><span class="line">    <span class="comment">// 配置这个surface视图</span></span><br><span class="line">    glSurfaceView.setEGLContextClientVersion(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置Renderer</span></span><br><span class="line">    glSurfaceView.setRenderer(FirstOpenGLProjectRenderer());</span><br><span class="line">    rendererSet = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;This device does not support OpenGL ES 2.0&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setContentView(glSurfaceView);</span><br></pre></td></tr></table></figure></p>
<p>最后我们还得处理下Activity的生命周期，也就是将GLSurfaceView的生命周期跟Activity的生命周期绑定起来：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onPause();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rendererSet)</span><br><span class="line">        glSurfaceView.onPause();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onResume();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rendererSet)</span><br><span class="line">        glSurfaceView.onResume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="编写Renderer"><a href="#编写Renderer" class="headerlink" title="编写Renderer"></a>编写Renderer</h2><p>创建一个新的文件，命名为FirstOpenGLProjectRenderer，让让这个类继承自GLSurfaceView.Renderer。</p>
<p>接着就实现三个必备方法:</p>
<ul>
<li><code>onSurfaceCreate()</code>：创建时被调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSurfaceCreated</span><span class="params">(GL10 glUnsed, EGLConfig config)</span> &#123;</span><br><span class="line">    glClearColor(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>); <span class="comment">//设置一个清空屏幕用的颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>onSurfaceChanged()</code>：创建后每当Surface尺寸改变时，都调用此方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSurfaceChanged</span><span class="params">(GL10 glUnsed, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height); <span class="comment">//设置视窗尺寸</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>onDrawFrame()</code>：绘制每一帧时调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDrawFrame</span><span class="params">(GL10 glUnsed)</span> &#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT); <span class="comment">//清空屏幕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以运行程序了，你就可以看到整个屏幕都成了红色，这是为啥呢？<br>因为我们在onSurfaceCreated方法里面设置了glClearColor(1.0f,0.0f,0.0f,0.0f)。这个方法的参数对应的是RGBA，然后我们又在onDrawFrame方法中设置了清屏，所以这样你就会看到的是红色了。</p>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>OpenGL</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL ES 2.0笔记2——顶点、坐标、图元</title>
    <url>/posts/268eb1c2.html</url>
    <content><![CDATA[<blockquote>
<p>上节我们对OpenGL做了一个大致的介绍，并写了一个基本框架，在这节中我们将会介绍顶点、坐标系和图元</p>
</blockquote>
<span id="more"></span>
<h1 id="顶点"><a href="#顶点" class="headerlink" title="顶点"></a>顶点</h1><p>在OpenGL中，所有的东西的结构都是从一个顶点开始的。</p>
<p>所谓顶点，就是一个几何图形的拐点。在介绍顶点之前，我们首先介绍下OpenGL坐标。</p>
<h2 id="OpenGL坐标系"><a href="#OpenGL坐标系" class="headerlink" title="OpenGL坐标系"></a>OpenGL坐标系</h2><p>如果有会Android开发的朋友，一定会默认为从屏幕的左上角开始，水平往右是x轴，竖直向下是y轴。</p>
<p>但是在OpenGL中是不同的，OpenGL是从显示视窗的正中心是中心，也就是$(0, 0)$，而屏幕最左边的x轴坐标是-1，屏幕最右边的x轴坐标是1，屏幕最上面的y轴坐标是1，屏幕最下面的y轴坐标是-1，也就是下面这幅图：</p>
<p><img src="https://cdn.littlecorgi.top/mweb/2019-10-18/opengl_coordinate.png" alt="opengl_coordinate"></p>
<h2 id="在代码中定义顶点"><a href="#在代码中定义顶点" class="headerlink" title="在代码中定义顶点"></a>在代码中定义顶点</h2><p>在OpenGL中定义顶点有点特殊，我们第一反应都是直接拿数组将顶端存起来就行了，但是在OpenGL中，你除了要将顶点的坐标用数组存起来以外，还得定义一个常量，用来标记一个顶点有两个分量：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">POSITION_COMPONENT_COUNT</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">float</span>[] tableVerticesWithTriangles = &#123;</span><br><span class="line">    <span class="comment">// Triangle 1</span></span><br><span class="line">    -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, </span><br><span class="line">    <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    -<span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Triangle 2</span></span><br><span class="line">    -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, </span><br><span class="line">    <span class="number">0.5f</span>, -<span class="number">0.5f</span>, </span><br><span class="line">    <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Line 1</span></span><br><span class="line">    -<span class="number">0.5f</span>, <span class="number">0f</span>, </span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mallets</span></span><br><span class="line">    <span class="number">0f</span>, -<span class="number">0.25f</span>, </span><br><span class="line">    <span class="number">0f</span>,  <span class="number">0.25f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们采用浮点数的顺序列表定义顶点数据，这个数组通常被成为顶点属性。</p>
<h1 id="图元"><a href="#图元" class="headerlink" title="图元"></a>图元</h1><p>在OpenGL中，只能绘制点、直线和三角形，这三个也被称为图元。</p>
<p>也就意味着，其它所有的图形都得通过这三个基本图元来实现。</p>
<p>如果我们需要绘制一个点，那么一个坐标就可以了，但是如果我们需要绘制一条直线，就需要两个坐标，如果绘制一个三角形，就需要三个坐标。</p>
<p>那么我们就以绘制一个正方形举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span>[] squareVerticesWithTriangles = &#123;</span><br><span class="line">    -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, </span><br><span class="line">    <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    -<span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">0.5f</span>, -<span class="number">0.5f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.littlecorgi.top/mweb/2019-10-18/%E5%9D%90%E6%A0%87.png" alt="坐标"></p>
<p>如果我要在这个正方形中间加一个横线的话，那么就直接在上面的数组里面去加，到时候要将顶点着色器加载到图形中的时候再去处理：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span>[] squareVerticesWithTriangles = &#123;</span><br><span class="line">    <span class="comment">// Square</span></span><br><span class="line">    -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, </span><br><span class="line">    <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    -<span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">0.5f</span>, -<span class="number">0.5f</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Line</span></span><br><span class="line">    -<span class="number">0.5f</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://cdn.littlecorgi.top/mweb/2019-10-18/%E7%BA%BF%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%9D%90%E6%A0%87.png" alt="线正方形坐标"></p>
<h1 id="让数据可以被OpenGL读取"><a href="#让数据可以被OpenGL读取" class="headerlink" title="让数据可以被OpenGL读取"></a>让数据可以被OpenGL读取</h1><p>在上面，我们已经完成了顶点的定义，但是现在OpenGL尚还不能读取他们。其原因是这些代码的运行环境与OpenGL运行环境使用了不一样的语言。</p>
<p>当我们运行Java语言的时候，并不是直接运行在硬件上的，而是运行在JVM(纯Java)或者Dalvik(Android)虚拟机上的，并且运行在这些虚拟机上的时候，并不能直接访问本地环境；其次，虚拟机还采用的垃圾回收机制，当检测到变量、对象不再被使用时，就自动释放掉这些内存。</p>
<p>但是本地环境不能这样，因为他是直接运行在硬件上的，他不希望内存会被移来移去或者自动释放。</p>
<p>所以我们就需要一个方案，让Android程序与OpenGL进行通信。<br>其实Android代码与硬件通信有两种方法：</p>
<ol>
<li>通过JNI技术；</li>
<li>通过调用android.opengl.GLES20包里面的方法。</li>
</ol>
<p>我们这块主要是通过第二种方法。</p>
<p>Java中有一种特殊的集合，可以分配本地的内存块，并将Java的数据复制到本地内存。代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为Java中国一个Float型数据占4个字节</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BYTES_PER_FLOAT</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 声明一个字节缓冲区</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FloatBuffer vertexData;</span><br><span class="line"> </span><br><span class="line">vertexData = ByteBuffer</span><br><span class="line">    <span class="comment">// 分配一块本地内存，所以是数组长度 * 类型所占字节</span></span><br><span class="line">    .allocateDirect(tableVerticesWithTriangles.length * BYTES_PER_FLOAT)</span><br><span class="line">    <span class="comment">// 按照本地字节序组织内容</span></span><br><span class="line">    .order(ByteOrder.nativeOrder())</span><br><span class="line">    .asFloatBuffer();</span><br><span class="line">    <span class="comment">// 将数据存入</span></span><br><span class="line">    .put(tableVerticesWithTriangles);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>OpenGL</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>View的事件分发</title>
    <url>/posts/bfb9e8a9.html</url>
    <content><![CDATA[<p>从我刚进实验室的时候，学长学姐就说View的事件分发机制是Android里面一个很重要的内容，要我们好好学。</p>
<p>但是随着自己对Android了解的深入，越发觉得这个东西很有必要了解下，正好Android艺术开发探索也看到了View这块，也看了<a href="https://blog.csdn.net/guolin_blog/article/details/9097463">郭霖大神的博客</a>和<a href="https://www.jianshu.com/p/ea0108d8510e">另一位大神的博客</a>，所以就好好学习了一番，并写了此博客。</p>
<h1 id="1-MotionEvent"><a href="#1-MotionEvent" class="headerlink" title="1. MotionEvent"></a>1. MotionEvent</h1><p>在开始讲View事件分发之前，我们先来了解下MotionEvent。</p>
<p>这个就是手指解除到屏幕后所产生的一系列事件，主要为一下三个典型事件：</p>
<ul>
<li>ACTION_DOWM——手指刚接触屏幕</li>
<li>ACTION_MOVE——手指在屏幕上移动</li>
<li>ACTION_UP——手指从屏幕上松开</li>
<li>ACTION_CANCEL——结束事件（非人为）</li>
</ul>
<p>正常情况下，一次手指触摸屏幕然后离开可能触发一下两种情况：</p>
<ul>
<li>点击屏幕然后松开：ACTION_DOWN -&gt; ACTION_UP</li>
<li>点击屏幕然后滑动再松开：ACTION_DOWN -&gt; ACTION_MOVE -&gt; ACTION_UP</li>
</ul>
<p>下面一个图片来概括下：<br><img src="https://cdn.littlecorgi.top/mweb/2019-10-31/MotionEvent.png" alt="MotionEvent"></p>
<h1 id="2-事件分发传递规则"><a href="#2-事件分发传递规则" class="headerlink" title="2. 事件分发传递规则"></a>2. 事件分发传递规则</h1><p>众所周知，AndroidUI是由Activity、ViewGroup、View及其派生类组成的。</p>
<p>大致示意图如下：<br><img src="https://cdn.littlecorgi.top/mweb/2019-10-31/AndroidUI.jpg" alt="AndroidUI"></p>
<p>其中：</p>
<ul>
<li>Activity：控制生命周期或者处理事件</li>
<li>ViewGroup：一组View或者多个View的集合。也是布局Layout的基类。但是特别的是，他也集成自View。</li>
<li>View：所有UI组件的基类</li>
</ul>
<p>从上图我们就可以看出来，事件分发的顺序就是：Activity -&gt; ViewGroup -&gt; View。也就是说一个点击事件产生，先交由Activity，再传到ViewGroup，再传到View。这个过程中只要有一个部分说要拦截，就不会再继续往下传递。</p>
<h1 id="3-事件分发的核心方法"><a href="#3-事件分发的核心方法" class="headerlink" title="3. 事件分发的核心方法"></a>3. 事件分发的核心方法</h1><p>其实时间分发的核心方法很简单，就由三个方法组成：</p>
<ul>
<li>public boolean dispatchTouchEvent(MotionEvent ev)<br>用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。</li>
<li><p>public boolean onInterceptTouchEvent(MotionEvent event)<br>在dispatchTouchEvent方法内部调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一事件序列当中，此方法不会再次被调用，返回结果表示是否拦截当前事件。（只有ViewGroup中才有此方法，View中没有）</p>
</li>
<li><p>public boolean onTouchEvent(MotionEvent event)<br>在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。</p>
</li>
</ul>
<p>三个方法间的关系可以按下面一段伪代码表示：（<a href="https://www.jianshu.com/p/ea0108d8510e">参考</a>的代码）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 点击事件产生后 </span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  <span class="comment">// 步骤1：调用dispatchTouchEvent（）</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">consume</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//代表 是否会消费事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤2：判断是否拦截事件</span></span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev)) &#123;</span><br><span class="line">      <span class="comment">// a. 若拦截，则将该事件交给当前View进行处理</span></span><br><span class="line">      <span class="comment">// 即调用onTouchEvent (）方法去处理点击事件</span></span><br><span class="line">        consume = onTouchEvent (ev) ;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// b. 若不拦截，则将该事件传递到下层</span></span><br><span class="line">      <span class="comment">// 即 下层元素的dispatchTouchEvent（）就会被调用，重复上述过程</span></span><br><span class="line">      <span class="comment">// 直到点击事件被最终处理为止</span></span><br><span class="line">      consume = child.dispatchTouchEvent (ev) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤3：最终返回通知 该事件是否被消费（接收 &amp; 处理）</span></span><br><span class="line">    <span class="keyword">return</span> consume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于一个根ViewGroup，点击事件产生后，就会传递给他，这时他的dispatchTouchEvent就会被调用，然后就开始判断他是否拦截。如果拦截，那么点击事件就会给ViewGroup去处理，如果不拦截，就调用child.dispatchTouchEvent (ev) 传给子控件的dispatchTouchEvent方法。然后继续循环，直到到最底层view，也就是没有child的时候，或者直到事件被拦截。</p>
<h1 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4. 源码分析"></a>4. 源码分析</h1><h2 id="4-1-Activity事件分发"><a href="#4-1-Activity事件分发" class="headerlink" title="4.1 Activity事件分发"></a>4.1 Activity事件分发</h2><p>首先先来看dispatchTouchEvent方法：</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">        <span class="comment">// -&gt;&gt; 分析1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析1：onUserInteraction()</span></span><br><span class="line"><span class="comment">  * 这个方法就是个空方法，但是我是在没搞懂这个方法是干嘛的，所以就直接粘贴了carson这位大神的说明</span></span><br><span class="line"><span class="comment">  * 作用：实现屏保功能</span></span><br><span class="line"><span class="comment">  * 注：</span></span><br><span class="line"><span class="comment">  *    a. 该方法为空方法</span></span><br><span class="line"><span class="comment">  *    b. 当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onUserInteraction</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析2：getWindow().superDispatchTouchEvent(ev)</span></span><br><span class="line"><span class="comment">  * 点开之后进入Window类，</span></span><br><span class="line"><span class="comment">  * 但是发现这个类是个抽象类，这个方法是个抽象方法。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * 了解过View的同学都知道，Window的唯一实现类就是PhoneWindow</span></span><br><span class="line"><span class="comment">  * 那我们进入PhoneWindow看下他的superDispatchTouchEvent方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span>;</span><br><span class="line"><span class="comment">// -&gt;&gt; 分析3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析3：PhoneWindow.superDispatchTouchEvent()</span></span><br><span class="line"><span class="comment">  * 实际上又调用了DecorView的superDispatchTouchEvent方法，DecorView是最顶层的View</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析4：DecorView.superDispatchTouchEvent()</span></span><br><span class="line"><span class="comment"> * 注：</span></span><br><span class="line"><span class="comment"> *     a. DecorView继承自FrameLayout，而FrameLayout继承自ViewGroup，也就是说DecorView就是ViewGroup。</span></span><br><span class="line"><span class="comment"> *     b. DecorView调用了父类的dispatchTouchEvent方法，也就相当于ViewGroup的dispatchTouchEvent方法，就把事件交给了ViewGroup去处理，这块后面再说</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析5：return onTouchEvent(ev)</span></span><br><span class="line"><span class="comment"> * 当触摸屏事件未由其下的任何视图处理时调用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mWindow.shouldCloseOnTouch(<span class="built_in">this</span>, event)) &#123;</span><br><span class="line">    <span class="comment">// -&gt;&gt; 分析6</span></span><br><span class="line">        finish();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 只有在点击事件在Window边界外才会返回true，一般情况都返回false，分析完毕</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 分析6：Window.shouldCloseOnTouch()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 返回：</span></span><br><span class="line"><span class="comment"> *         返回true：说明事件在边界外，即 消费事件</span></span><br><span class="line"><span class="comment"> *         返回false：未消费（默认）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldCloseOnTouch</span><span class="params">(Context context, MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isOutside</span> <span class="operator">=</span></span><br><span class="line">            event.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; isOutOfBounds(context, event)</span><br><span class="line">            || event.getAction() == MotionEvent.ACTION_OUTSIDE;</span><br><span class="line">    <span class="comment">// 主要是对于处理边界外点击事件的判断：是否是DOWN事件，event的坐标是否在边界内等</span></span><br><span class="line">    <span class="keyword">if</span> (mCloseOnTouchOutside &amp;&amp; peekDecorView() != <span class="literal">null</span> &amp;&amp; isOutside) &#123;</span><br><span class="line">        <span class="comment">// peekDecorView是返回PhoneWindow的mDecor</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="https://cdn.littlecorgi.top/mweb/2019-10-31/Activity%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B.jpg" alt="Activity事件分发流程"></p>
<h2 id="4-2-ViewGroup事件分发"><a href="#4-2-ViewGroup事件分发" class="headerlink" title="4.2 ViewGroup事件分发"></a>4.2 ViewGroup事件分发</h2><h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><p>由于此部分代码过长，我们将代码拆分成两部分：</p>
<h4 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    ...<span class="comment">// 仅贴出关键代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * onFilterTouchEventForSecurity(ev)</span></span><br><span class="line"><span class="comment">     * 筛选touch事件，进去之后的判断核心就是当前视图是否被其它窗口遮挡或者隐藏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> ev.getAction();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">actionMasked</span> <span class="operator">=</span> action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle an initial down.</span></span><br><span class="line">        <span class="comment">// -&gt;&gt; 分析1</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">            <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">            <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">            cancelAndClearTouchTargets(ev);</span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check for interception.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> intercepted;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 分析2</span></span><br><span class="line"><span class="comment">         * 可以看到会有两种情况下拦截事件：事件类型为DOWN，或者mFirstTouchTarget != null。</span></span><br><span class="line"><span class="comment">         * 那么这个mFirstTouchTarget是什么呢？</span></span><br><span class="line"><span class="comment">         * 从后面的代码我们可以得知，当ViewGroup不拦截事件交给子元素处理的时候，mFirstTouchTarget不为null。</span></span><br><span class="line"><span class="comment">         * 所以，也就是说当MotionEvent为UP或者MOVE的时候，都进不去这个方法，也就是不调用ViewGroup的onInterceptTouchEvent，他不拦截事件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                || mFirstTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">            <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">            intercepted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析1</span></span><br><span class="line"><span class="comment"> * 事件开始时会调用resetTouchState()来清空mFirstAndClearTouchTarget</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    cancelAndClearTouchTargets(ev);</span><br><span class="line">    <span class="comment">// 核心目的就是清空mFirstAndClearTouchTarget</span></span><br><span class="line">    resetTouchState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        ...<span class="comment">//省略中间代码</span></span><br><span class="line">        <span class="comment">// 进入if语句，判断条件为没有对事件进行拦截，同时事件没有结束。对ViewGroup的子元素进行遍历</span></span><br><span class="line">        <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">        </span><br><span class="line">            ...<span class="comment">//继续省略中间代码</span></span><br><span class="line">            </span><br><span class="line">                    <span class="comment">// 得到所有的子View</span></span><br><span class="line">                    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                    <span class="comment">// 对子View进行遍历</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childIndex</span> <span class="operator">=</span> getAndVerifyPreorderedIndex(</span><br><span class="line">                                childrenCount, i, customOrder);</span><br><span class="line">                        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getAndVerifyPreorderedView(</span><br><span class="line">                                preorderedList, children, childIndex);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// If there is a view that has accessibility focus we want it</span></span><br><span class="line">                        <span class="comment">// to get the event first and if not handled we will perform a</span></span><br><span class="line">                        <span class="comment">// normal dispatch. We may do a double iteration but this is</span></span><br><span class="line">                        <span class="comment">// safer given the timeframe.</span></span><br><span class="line">                        <span class="comment">// 该viewgroup设置事件了指向焦点View并且焦点View在前面已经找到了</span></span><br><span class="line">                        <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 判断遍历的此View是否是焦点View，如果不是就直接下一遍循环</span></span><br><span class="line">                            <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 如果是的话就将找到的焦点view置空</span></span><br><span class="line">                            <span class="comment">// i回到到数第一个下标</span></span><br><span class="line">                            <span class="comment">// 这样做的目的是先让该焦点view尝试进行下面的普通分发操作</span></span><br><span class="line">                            <span class="comment">// 如果成功了，会在下面跳出循环。</span></span><br><span class="line">                            <span class="comment">// 如果不成功，就将记录的焦点view置空，</span></span><br><span class="line">                            <span class="comment">// 从最后一个开始重新遍历，不再进入这个判断。</span></span><br><span class="line">                            childWithAccessibilityFocus = <span class="literal">null</span>;</span><br><span class="line">                            i = childrenCount - <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 判断当前子View是否能获取焦点或者是否正在做动画</span></span><br><span class="line">                        <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                                || !isTransformedTouchPointInView(x, y, child, <span class="literal">null</span>)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="literal">false</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        newTouchTarget = getTouchTarget(child);</span><br><span class="line">                        <span class="keyword">if</span> (newTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">                            <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        resetCancelNextUpFlag(child);</span><br><span class="line">                        <span class="comment">// -&gt;&gt; 分析1</span></span><br><span class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="literal">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                            <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                            <span class="keyword">if</span> (preorderedList != <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (chifcldren[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                        mLastTouchDownIndex = j;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                mLastTouchDownIndex = childIndex;</span><br><span class="line">                            &#125;</span><br><span class="line">                            mLastTouchDownX = ev.getX();</span><br><span class="line">                            mLastTouchDownY = ev.getY();</span><br><span class="line">                            <span class="comment">// -&gt;&gt; 分析2</span></span><br><span class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                            alreadyDispatchedToNewTouchTarget = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// The accessibility focus didn&#x27;t handle the event, so clear</span></span><br><span class="line">                        <span class="comment">// the flag and do a normal dispatch to all children.</span></span><br><span class="line">                        ev.setTargetAccessibilityFocus(<span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                  </span><br><span class="line">                  ... <span class="comment">//省略</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析1 dispatchTransformedTouchEvent()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 核心就是那个if (child == null)。</span></span><br><span class="line"><span class="comment"> * 如果child不为空，那么事件就交给子View处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="type">boolean</span> cancel,</span></span><br><span class="line"><span class="params">        View child, <span class="type">int</span> desiredPointerIdBits)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Canceling motions is a special case.  We don&#x27;t need to perform any transformations</span></span><br><span class="line">    <span class="comment">// or filtering.  The important part is the action, not the contents.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">oldAction</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">            handled = <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">    ...<span class="comment">//省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析2</span></span><br><span class="line"><span class="comment"> * 如果子View能处理点击事件，那么就调用addTouchTarget方法，对mFirstTouchTarget方法进行复制，然后再进入part1中分析2。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> TouchTarget <span class="title function_">addTouchTarget</span><span class="params">(<span class="meta">@NonNull</span> View child, <span class="type">int</span> pointerIdBits)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">TouchTarget</span> <span class="variable">target</span> <span class="operator">=</span> TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">    target.next = mFirstTouchTarget;</span><br><span class="line">    mFirstTouchTarget = target;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="part3"><a href="#part3" class="headerlink" title="part3"></a>part3</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="comment">// Dispatch to touch targets.</span></span><br><span class="line">        <span class="comment">// 如果part2开头的那个if没有进，也就是对事件进行拦截的话，直接到这来</span></span><br><span class="line">        <span class="comment">// 并且如果没有进入part2，那么mFirstTouchTarget仍然为空，那么就进入if</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">            <span class="comment">// 此处在上面分析过了，但是不同的是由于child直接传入了null，那么就执行super.dispatchTouchEven。</span></span><br><span class="line">            <span class="comment">// 那么super是谁呢？我们在前面说过，ViewGroup是继承自View的，那么他就是执行View的dispatchTouchEvent。</span></span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="literal">null</span>,</span><br><span class="line">                    TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ... <span class="comment">//省略</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer up or cancel, if needed.</span></span><br><span class="line">        <span class="keyword">if</span> (canceled</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                <span class="comment">// -&gt;&gt; 分析1</span></span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">actionIndex</span> <span class="operator">=</span> ev.getActionIndex();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">idBitsToRemove</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">            removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...<span class="comment">//省略</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析1</span></span><br><span class="line"><span class="comment"> * 在同一事件系列结束后调用resetTouchState();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resetTouchState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 对mFirstTouchTarget清空还原</span></span><br><span class="line">    clearTouchTargets();</span><br><span class="line">    resetCancelNextUpFlag(<span class="built_in">this</span>);</span><br><span class="line">    mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">    mNestedScrollAxes = SCROLL_AXIS_NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><p>此图搬自<a href="https://www.jianshu.com/p/38015afcdb58">Carson_Ho大佬的博客</a><br><img src="https://cdn.littlecorgi.top/mweb/2019-10-31/15725314562031.jpg" alt=""></p>
<h2 id="4-3-View事件分发"><a href="#4-3-View事件分发" class="headerlink" title="4.3 View事件分发"></a>4.3 View事件分发</h2><h3 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h3><h4 id="dispatchTouchEvent"><a href="#dispatchTouchEvent" class="headerlink" title="dispatchTouchEvent"></a>dispatchTouchEvent</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    ...<span class="comment">//省略</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    ...<span class="comment">//省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和ViewGroup一样的判断，判断当前视图是否被遮挡或者不可见</span></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">        <span class="type">ListenerInfo</span> <span class="variable">li</span> <span class="operator">=</span> mListenerInfo;</span><br><span class="line">        <span class="comment">// 检测有没有设置OnTOuchListener，如果有，并且onTouch方法返回true那么进入if，结果导致onTouchEvent不被执行</span></span><br><span class="line">        <span class="keyword">if</span> (li != <span class="literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="built_in">this</span>, event)) &#123;</span><br><span class="line">                </span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没进入上面的if，也就相当于没有设置OnTouchListener，那么执行onTOuchEvent</span></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...<span class="comment">//省略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看出，<strong>onTouch的优先级高于onTouchEvent</strong>。</p>
<h4 id="onTouchEvent"><a href="#onTouchEvent" class="headerlink" title="onTouchEvent"></a>onTouchEvent</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> <span class="variable">x</span> <span class="operator">=</span> event.getX();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> <span class="variable">y</span> <span class="operator">=</span> event.getY();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">viewFlags</span> <span class="operator">=</span> mViewFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> event.getAction();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注释1 </span></span><br><span class="line"><span class="comment">     * 只有在Click、LongClick、contextClick都不可用的时候才为false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">clickable</span> <span class="operator">=</span> ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">            || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">            || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先判断是不是不可用，如果是，则进入if</span></span><br><span class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">            setPressed(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">        <span class="comment">// A disabled view that is clickable still consumes the touch</span></span><br><span class="line">        <span class="comment">// events, it just doesn&#x27;t respond to them.</span></span><br><span class="line">        <span class="comment">// -&gt;&gt; 注释1（见上面👆）</span></span><br><span class="line">        <span class="keyword">return</span> clickable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果View有代理会执行这个方法</span></span><br><span class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这块我们只调出ACTION_UP来看</span></span><br><span class="line">    <span class="comment">// 只要clickable为true(见上面注释1👆)或者TOOLTIP(可能是Android8.0新出的提示功能吧)</span></span><br><span class="line">    <span class="keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line"></span><br><span class="line">                ...<span class="comment">//省略</span></span><br><span class="line">                </span><br><span class="line">                    <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                        <span class="comment">// This is a tap, so remove the longpress check</span></span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Only perform take click actions if we were in the pressed state</span></span><br><span class="line">                        <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                            <span class="comment">// Use a Runnable and post this rather than calling</span></span><br><span class="line">                            <span class="comment">// performClick directly. This lets other visual state</span></span><br><span class="line">                            <span class="comment">// of the view update before click actions start.</span></span><br><span class="line">                            <span class="keyword">if</span> (mPerformClick == <span class="literal">null</span>) &#123;</span><br><span class="line">                                mPerformClick = <span class="keyword">new</span> <span class="title class_">PerformClick</span>();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                <span class="comment">// -&gt;&gt; 分析1</span></span><br><span class="line">                                performClickInternal();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ... <span class="comment">//省略</span></span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                mIgnoreNextUpEvent = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            ... <span class="comment">//省略其它几种MotionEvent</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由代码可知只要上面的if语句成立，不管进入switch中的任何ACTION或是都不进入，返回值都是true，即事件消费了。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析1：performClick（）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">performClick</span><span class="params">()</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mOnClickListener != <span class="literal">null</span>) &#123;  </span><br><span class="line">        playSoundEffect(SoundEffectConstants.CLICK);  </span><br><span class="line">        mOnClickListener.onClick(<span class="built_in">this</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        <span class="comment">// 只要我们通过setOnClickListener（）为控件cvView注册1个点击事件</span></span><br><span class="line">        <span class="comment">// 那么就会给mOnClickListener变量赋值（即不为空）</span></span><br><span class="line">        <span class="comment">// 则会往下回调onClick（） &amp; performClick（）返回true</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h3><p><img src="https://cdn.littlecorgi.top/mweb/2019-10-31/15725337657670.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
        <tag>源码</tag>
        <tag>事件分发</tag>
      </tags>
  </entry>
  <entry>
    <title>ijkPlayer编译-Android</title>
    <url>/posts/d61d5542.html</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>ijkplayer是哔哩哔哩的一个开源视频播放框架，支持Android、iOS。底层是ffplay。</p>
<p>Github地址：<a href="https://github.com/bilibili/ijkplayer">bilibili/ijkplayer</a><br><span id="more"></span></p>
<h1 id="2-编译方法"><a href="#2-编译方法" class="headerlink" title="2. 编译方法"></a>2. 编译方法</h1><p>由于通过Gradle编译起来很慢而且一旦失败又得重头来，所以这块就使用AndroidNDK的方式来编译。</p>
<h2 id="2-1-编译之前"><a href="#2-1-编译之前" class="headerlink" title="2.1 编译之前"></a>2.1 编译之前</h2><p>首先你得配置好等会编译需要的东西。这块我们都会使用<a href="https://brew.sh/index_zh-cn">Homebrew</a>来安装git和yasm。<br>Homebrew类似于Ubuntu的dpkg、RedHat和centOS的yum，他是macOS上的一个软件包管理器。但是后来出了Linux版。<br>由于ijkplayer官方说用的它，那咱们就用它吧。</p>
<h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><h4 id="1-先把目前已有的包更新"><a href="#1-先把目前已有的包更新" class="headerlink" title="1. 先把目前已有的包更新"></a>1. 先把目前已有的包更新</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 从镜像站下载软件列表，并检查有没有需要更新的包</span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">// 更新需要更新的包</span><br><span class="line">sudo apt upgrade</span><br><span class="line"></span><br><span class="line">// 自动卸载掉当初为了安装其他软件或其他原因而安装但是目前已经没用的包</span><br><span class="line">sudo apt autoremove</span><br></pre></td></tr></table></figure>
<h4 id="2-安装Homebrew"><a href="#2-安装Homebrew" class="headerlink" title="2. 安装Homebrew"></a>2. 安装Homebrew</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 首先确定是否安装ruby  </span><br><span class="line">    apt install ruby<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">2. 然后通过ruby安装Homebrew  </span></span><br><span class="line"><span class="string">    ruby -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Linuxbrew/install/master/install.sh)&quot;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">3. 再通过Homebrew安装git和yasm</span></span><br><span class="line"><span class="string">    brew install git</span></span><br><span class="line"><span class="string">    brew install yasm</span></span><br></pre></td></tr></table></figure>
<h4 id="3-配置Android-SDK和NDK"><a href="#3-配置Android-SDK和NDK" class="headerlink" title="3. 配置Android SDK和NDK"></a>3. 配置Android SDK和NDK</h4><ol>
<li><p>Android SDK<br> 你可以打开你的AndroidStudio，进入<code>Preferences -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; Android SDK</code>。这块就会显示你SDK安装目录。<br> 然后在终端中输入<code>vim ~/.bash_profile</code>。然后输入以下内容：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ANDROID_SDK_HOME=AndroidSDK的目录/android-sdk-linux</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$&#123;ANDROID_SDK_HOME&#125;</span>/tools</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$&#123;ANDROID_SDK_HOME&#125;</span>/platform-tools</span><br></pre></td></tr></table></figure>
<p> 保存，然后再在终端输入<code>source ~/.bash_profile</code>，就可以了。</p>
</li>
<li><p>Android NDK<br> 首先你得到官网下载NDK：<a href="https://developer.android.com/ndk/downloads/older_releases.html?hl=zh-cn">NDK 归档</a>。而且你只能下载r10e版本的，下载其它版本编译会报错。<br> 下载下来解压后，同样和上面一样得配置环境变量：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ANDROID_NDK_HOME=NDK目录</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$&#123;ANDROID_SDK_HOME&#125;</span></span><br></pre></td></tr></table></figure>
<p> 保存，然后再在终端输入<code>source ~/.bash_profile</code>，就可以了。</p>
</li>
</ol>
<h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p>安装Homebrew，由于macOS自带ruby，所以我们直接可以开始安装Homebrew。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></span><br><span class="line">brew install git</span><br><span class="line">brew install yasm</span><br></pre></td></tr></table></figure><br>然后就是配置你的Android SDK和Android NDK：<br>和上面Ubuntu下一样。</p>
<h2 id="2-2-编译Android"><a href="#2-2-编译Android" class="headerlink" title="2.2 编译Android"></a>2.2 编译Android</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Bilibili/ijkplayer.git ijkplayer-android</span><br><span class="line"><span class="built_in">cd</span> ijkplayer-android</span><br><span class="line">git checkout -B latest k0.8.8</span><br><span class="line"></span><br><span class="line">./init-android.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> android/contrib</span><br><span class="line">./compile-ffmpeg.sh clean</span><br><span class="line">// 这步特慢，耗时很长</span><br><span class="line">./compile-ffmpeg.sh all</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">./compile-ijk.sh all</span><br></pre></td></tr></table></figure>
<p>上面这些执行完就可以了。<br>然后你就能在你的<code>/ijkplayer-android/android/ijkplayer</code>路径下就能看到编译后的项目了，其中每个<code>module的/src/mian/libs</code>里面就是so文件。</p>
<h1 id="3-最后"><a href="#3-最后" class="headerlink" title="3. 最后"></a>3. 最后</h1><p>你可以直接通过AndroidStudio打开<code>/ijkplayer-android/android/ijkplayer</code>，然后在里面的<code>/ijkplayer-example</code>下谢你自己的代码就可以了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ijkplayer</tag>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>Koin-1-Intro(介绍)</title>
    <url>/posts/fd6f0996.html</url>
    <content><![CDATA[<blockquote>
<p><a href="https://start.insert-koin.io/#/introduction">https://start.insert-koin.io/#/introduction</a></p>
<p>开始</p>
<ul>
<li><a href="/posts/fd6f0996.html">Intro(介绍)</a></li>
<li><a href="/posts/b075de90.html">Setup(初始化)</a></li>
</ul>
<p>Koin in 5 minutes (5分钟快速入手Koin)</p>
<ul>
<li><a href="/posts/f88fedb6.html">Kotlin</a></li>
<li><a href="/posts/2a806fe1.html">Android</a></li>
<li><a href="/posts/e7ad0613.html">Android Java</a></li>
<li><a href="/posts/6d1e0fe7.html">Android ViewModel</a></li>
</ul>
<p>Getting Started (开始)</p>
<ul>
<li><a href="/posts/c99907a8.html">Starting Koin(开始使用Koin)</a></li>
<li><a href="/posts/d8ca0532.html">Modules &amp; definitions(模块和定义)</a></li>
<li><a href="/posts/f85e8eae.html">Koin Components(Koin组件)</a></li>
<li><a href="/posts/63fa5724.html">Testing(测试)</a></li>
<li><a href="/posts/ebed2a69.html">Koin for Java</a></li>
<li><a href="/posts/f5a785d7.html">Koin for Android</a></li>
</ul>
</blockquote>
<h2 id="KOIN是什么"><a href="#KOIN是什么" class="headerlink" title="KOIN是什么?"></a><a href="https://start.insert-koin.io/#/introduction?id=what-is-koin">KOIN是什么?</a></h2><p>给Kotlin开发者的一个实用的轻量级的Kotlin依赖注入框架。</p>
<p>用纯Kotlin编写，仅使用函数来解决：无代理，无代码生成，无反射。</p>
<p><code>Koin is a DSL, a light container and a pragmatic API</code></p>
<h3 id="最新消息-🌐"><a href="#最新消息-🌐" class="headerlink" title="最新消息 🌐"></a><a href="https://start.insert-koin.io/#/introduction?id=latest-news-🌐">最新消息 🌐</a></h3><ul>
<li>在Twitter上Follow us来获取最新消息: <a href="https://twitter.com/insertkoin_io">@insertkoin_io</a></li>
<li>Koin developers on Medium: <a href="https://medium.com/koin-developers">koin developers hub</a></li>
</ul>
<h3 id="获取帮助-🚒"><a href="#获取帮助-🚒" class="headerlink" title="获取帮助 🚒"></a><a href="https://start.insert-koin.io/#/introduction?id=getting-help-🚒">获取帮助 🚒</a></h3><p>关于Koin使用的任何问题</p>
<ul>
<li>在slack上和我们讨论 <a href="https://kotlinlang.slack.com/?redir=%2Fmessages%2Fkoin">#koin channel</a></li>
<li>在 <a href="https://stackoverflow.com/questions/tagged/koin">Stackoverflow - #koin tag</a> 上向我们提问</li>
</ul>
<h3 id="提交-issues-🛠"><a href="#提交-issues-🛠" class="headerlink" title="提交 issues 🛠"></a><a href="https://start.insert-koin.io/#/introduction?id=reporting-issues-🛠">提交 issues 🛠</a></h3><p>发现了一个bug或者问题？在<a href="https://github.com/InsertKoinIO/koin/issues">Github issues</a>上开启一个issue</p>
]]></content>
      <categories>
        <category>Koin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Koin</tag>
      </tags>
  </entry>
  <entry>
    <title>Koin-10-Testing(测试)</title>
    <url>/posts/63fa5724.html</url>
    <content><![CDATA[<blockquote>
<p><a href="https://start.insert-koin.io/#/getting-started/testing">https://start.insert-koin.io/#/getting-started/testing</a></p>
<p>开始</p>
<ul>
<li><a href="/posts/fd6f0996.html">Intro(介绍)</a></li>
<li><a href="/posts/b075de90.html">Setup(初始化)</a></li>
</ul>
<p>Koin in 5 minutes (5分钟快速入手Koin)</p>
<ul>
<li><a href="/posts/f88fedb6.html">Kotlin</a></li>
<li><a href="/posts/2a806fe1.html">Android</a></li>
<li><a href="/posts/e7ad0613.html">Android Java</a></li>
<li><a href="/posts/6d1e0fe7.html">Android ViewModel</a></li>
</ul>
<p>Getting Started (开始)</p>
<ul>
<li><a href="/posts/c99907a8.html">Starting Koin(开始使用Koin)</a></li>
<li><a href="/posts/d8ca0532.html">Modules &amp; definitions(模块和定义)</a></li>
<li><a href="/posts/f85e8eae.html">Koin Components(Koin组件)</a></li>
<li><a href="/posts/63fa5724.html">Testing(测试)</a></li>
<li><a href="/posts/ebed2a69.html">Koin for Java</a></li>
<li><a href="/posts/f5a785d7.html">Koin for Android</a></li>
</ul>
</blockquote>
<p><code>Koin-test</code> 项目能提供给你轻量但是强大的工具来测试你的Koin应用程序。</p>
<h2 id="获取组件"><a href="#获取组件" class="headerlink" title="获取组件"></a><a href="https://start.insert-koin.io/#/getting-started/testing?id=getting-your-components">获取组件</a></h2><p>只要用 <code>KoinTest</code> 标记你的测试类，你就可以解锁KoinComponent &amp;测试特性：</p>
<ul>
<li><code>by inject()</code> - 延迟注入一个实例</li>
<li><code>get()</code> - 检索一个实例</li>
</ul>
<p>按照以下来定义：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> appModule = module &#123;</span><br><span class="line">    single &#123; ComponentA() &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你就能像下面这样来写一个测试：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTest</span> : <span class="type">KoinTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lazy inject property</span></span><br><span class="line">    <span class="keyword">val</span> componentA : ComponentA <span class="keyword">by</span> inject()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use it in your tests :)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `make a test with Koin`<span class="params">()</span></span> &#123;</span><br><span class="line">        startKoin &#123; modules(appModule) &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use componentA here!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你能使用 <code>KoinTestRule</code> JUnit规则来开启或关闭你的Koin上下文：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTest</span> : <span class="type">KoinTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@get:Rule</span></span><br><span class="line">    <span class="keyword">val</span> koinTestRule = KoinTestRule.create &#123;</span><br><span class="line">        modules(appModule)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lazy inject property</span></span><br><span class="line">    <span class="keyword">val</span> componentA : ComponentA <span class="keyword">by</span> inject()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use it in your tests :)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `make a test with Koin`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// use componentA here!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="检查你的模块"><a href="#检查你的模块" class="headerlink" title="检查你的模块"></a><a href="https://start.insert-koin.io/#/getting-started/testing?id=checking-your-modules">检查你的模块</a></h2><p>我们可以使用Koin Gradle插件来让我们运行我们的模块检查：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">&quot;org.koin:koin-gradle-plugin:$koin_version&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: <span class="string">&#x27;koin&#x27;</span></span><br></pre></td></tr></table></figure>
<p>按照如下来写检查测试：</p>
<ul>
<li>使用一个JUnit <code>CheckModuleTest</code> 类别</li>
<li>通过 <code>checkModules &#123; &#125;</code> API来测试模块</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Category(CheckModuleTest::class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModuleCheckTest</span> : <span class="type">AutoCloseKoinTest</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">checkModules</span><span class="params">()</span></span> = checkModules &#123;</span><br><span class="line">        modules(appModule)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们通过Gradle命令来检查我们的模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./gradlew checkModules</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./gradlew checkModules --continuous</span><br></pre></td></tr></table></figure>
<h2 id="动态Mock"><a href="#动态Mock" class="headerlink" title="动态Mock"></a><a href="https://start.insert-koin.io/#/getting-started/testing?id=mocking-on-the-fly">动态Mock</a></h2><p>Once you have tagged your class with <code>KoinTest</code> interface, you can use the <code>declareMock</code> function to declare mocks &amp; behavior on the fly:</p>
<p>一旦你用 <code>KoinTest</code> 接口标记了你的类，你就能使用 <code>declareMock</code> 函数来动态声明mocks(模拟)或者behavior(行为):</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTest</span> : <span class="type">KoinTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@get:Rule</span></span><br><span class="line">    <span class="keyword">val</span> koinTestRule = KoinTestRule.create &#123;</span><br><span class="line">        modules(appModule)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// required to make your Mock via Koin</span></span><br><span class="line">    <span class="meta">@get:Rule</span></span><br><span class="line">    <span class="keyword">val</span> mockProvider = MockProviderRule.create &#123; clazz -&gt;</span><br><span class="line">        Mockito.mock(clazz.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> componentA : ComponentA <span class="keyword">by</span> inject()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `declareMock with KoinTest`<span class="params">()</span></span> &#123;</span><br><span class="line">        declareMock&lt;ComponentA&gt; &#123;</span><br><span class="line">            <span class="comment">// do your given behavior here</span></span><br><span class="line">            given(<span class="keyword">this</span>.sayHello()).willReturn(<span class="string">&quot;Hello mock&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开始或停止测试"><a href="#开始或停止测试" class="headerlink" title="开始或停止测试"></a><a href="https://start.insert-koin.io/#/getting-started/testing?id=starting-amp-stopping-for-tests">开始或停止测试</a></h2><p>请注意在每个测试之间都需要通知你的Koin实例(如果你使用 <code>startKoin</code> 在你的测试中)。否则，请确保对本地koin实例使用 <code>koinApplication</code> 或 <code>stopKoin()</code> 来停止当前的全局实例。</p>
]]></content>
      <categories>
        <category>Koin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Koin</tag>
      </tags>
  </entry>
  <entry>
    <title>Koin-11-Koin for Java</title>
    <url>/posts/ebed2a69.html</url>
    <content><![CDATA[<blockquote>
<p><a href="https://start.insert-koin.io/#/getting-started/koin-for-java">https://start.insert-koin.io/#/getting-started/koin-for-java</a></p>
<p>开始</p>
<ul>
<li><a href="/posts/fd6f0996.html">Intro(介绍)</a></li>
<li><a href="/posts/b075de90.html">Setup(初始化)</a></li>
</ul>
<p>Koin in 5 minutes (5分钟快速入手Koin)</p>
<ul>
<li><a href="/posts/f88fedb6.html">Kotlin</a></li>
<li><a href="/posts/2a806fe1.html">Android</a></li>
<li><a href="/posts/e7ad0613.html">Android Java</a></li>
<li><a href="/posts/6d1e0fe7.html">Android ViewModel</a></li>
</ul>
<p>Getting Started (开始)</p>
<ul>
<li><a href="/posts/c99907a8.html">Starting Koin(开始使用Koin)</a></li>
<li><a href="/posts/d8ca0532.html">Modules &amp; definitions(模块和定义)</a></li>
<li><a href="/posts/f85e8eae.html">Koin Components(Koin组件)</a></li>
<li><a href="/posts/63fa5724.html">Testing(测试)</a></li>
<li><a href="/posts/ebed2a69.html">Koin for Java</a></li>
<li><a href="/posts/f5a785d7.html">Koin for Android</a></li>
</ul>
</blockquote>
<p>下面是 <code>koin-java</code> 特性的简短描述。这个项目是帮助java开发人员的静态utils的一个小子集。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a><a href="https://start.insert-koin.io/#/getting-started/koin-for-java?id=start-koin">开始</a></h2><p>Just use the <code>startKoin()</code> static function (with the static import to reduce the syntax):</p>
<p>只需要使用 <code>startKoin()</code> 静态函数(通过静态导入来减少语法)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.koin.core.context.GlobalContext.start;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Build KoinApplication instance</span></span><br><span class="line"><span class="comment">// Builder API style</span></span><br><span class="line"><span class="type">KoinApplication</span> <span class="variable">koinApp</span> <span class="operator">=</span> KoinApplication.create()</span><br><span class="line">                .printLogger()</span><br><span class="line">                .modules(koinModule);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Statr KoinApplication instance</span></span><br><span class="line">start(koinApp);</span><br></pre></td></tr></table></figure>
<p>您可以访问与Kotlin <code>startKoin()</code> <a href="(/docs//quick-references/koin-core/#start-koin">相同的选项</a>)。</p>
<h2 id="Kotlin中的Java友好模块"><a href="#Kotlin中的Java友好模块" class="headerlink" title="Kotlin中的Java友好模块"></a><a href="https://start.insert-koin.io/#/getting-started/koin-for-java?id=java-friendly-module-in-kotlin">Kotlin中的Java友好模块</a></h2><p>你需要使用 <code>@JvmField</code> 标记你的module变量，以便其可以从Java中读取：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JvmField</span></span><br><span class="line"><span class="keyword">val</span> koinModule = module &#123;</span><br><span class="line">    single &#123; ComponentA() &#125;</span><br><span class="line">    single &#123; ComponentB(<span class="keyword">get</span>()) &#125;</span><br><span class="line">    single &#123; ComponentC(<span class="keyword">get</span>(), <span class="keyword">get</span>()) &#125;</span><br><span class="line"></span><br><span class="line">    module(<span class="string">&quot;anotherModule&quot;</span>) &#123;</span><br><span class="line">        single &#123; ComponentD(<span class="keyword">get</span>()) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在静态函数中注入"><a href="#在静态函数中注入" class="headerlink" title="在静态函数中注入"></a><a href="https://start.insert-koin.io/#/getting-started/koin-for-java?id=inject-with-static-functions">在静态函数中注入</a></h2><p><code>KoinJavaComponent</code> 类是第一个静态的helper，他能将Koin的功能引入Java：</p>
<ul>
<li><code>inject()</code> - 延迟注入一个实例</li>
<li><code>get()</code> - 检索实例</li>
<li><code>getKoin()</code> - 获取Koin上下文</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.koin.java.standalone.KoinJavaComponent.*;</span><br><span class="line"></span><br><span class="line"><span class="type">ComponentA</span> <span class="variable">a</span> <span class="operator">=</span> get(ComponentA.class);</span><br><span class="line">Lazy&lt;ComponentA&gt; lazy_a = inject(ComponentA.class);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Koin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Koin</tag>
      </tags>
  </entry>
  <entry>
    <title>Koin-12-Koin for Android</title>
    <url>/posts/f5a785d7.html</url>
    <content><![CDATA[<blockquote>
<p><a href="https://start.insert-koin.io/#/getting-started/koin-for-android">https://start.insert-koin.io/#/getting-started/koin-for-android</a></p>
<p>开始</p>
<ul>
<li><a href="/posts/fd6f0996.html">Intro(介绍)</a></li>
<li><a href="/posts/b075de90.html">Setup(初始化)</a></li>
</ul>
<p>Koin in 5 minutes (5分钟快速入手Koin)</p>
<ul>
<li><a href="/posts/f88fedb6.html">Kotlin</a></li>
<li><a href="/posts/2a806fe1.html">Android</a></li>
<li><a href="/posts/e7ad0613.html">Android Java</a></li>
<li><a href="/posts/6d1e0fe7.html">Android ViewModel</a></li>
</ul>
<p>Getting Started (开始)</p>
<ul>
<li><a href="/posts/c99907a8.html">Starting Koin(开始使用Koin)</a></li>
<li><a href="/posts/d8ca0532.html">Modules &amp; definitions(模块和定义)</a></li>
<li><a href="/posts/f85e8eae.html">Koin Components(Koin组件)</a></li>
<li><a href="/posts/63fa5724.html">Testing(测试)</a></li>
<li><a href="/posts/ebed2a69.html">Koin for Java</a></li>
<li><a href="/posts/f5a785d7.html">Koin for Android</a></li>
</ul>
</blockquote>
<h2 id="在Android中开始"><a href="#在Android中开始" class="headerlink" title="在Android中开始"></a><a href="https://start.insert-koin.io/#/getting-started/koin-for-android?id=starting-koin-for-android">在Android中开始</a></h2><p>在任何一个Android类中：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainApplication</span> : <span class="type">Application</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line"></span><br><span class="line">        startKoin &#123;</span><br><span class="line">            <span class="comment">// use AndroidLogger as Koin Logger - default Level.INFO</span></span><br><span class="line">            <span class="comment">// 使用AndroidLogger代替KoinLogger - 默认Lovel.INFO</span></span><br><span class="line">            androidLogger()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// use the Android context given there 在这使用给定的AndroidContext</span></span><br><span class="line">            androidContext(<span class="keyword">this</span><span class="symbol">@MainApplication</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// load properties from assets/koin.properties file</span></span><br><span class="line">            <span class="comment">// 从assets/koin.properties文件中加载属性</span></span><br><span class="line">            androidFileProperties()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// module list 模块列表</span></span><br><span class="line">            modules(offlineWeatherApp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你不能注入Android上下文或者application，请确保使用 <code>androidContext()</code> 函数在你的Koin应用程序声明。</p>
<h2 id="使用Android-Context"><a href="#使用Android-Context" class="headerlink" title="使用Android Context"></a><a href="https://start.insert-koin.io/#/getting-started/koin-for-android?id=use-the-android-context">使用Android Context</a></h2><p>在你的定义中，你能通过 <code>androidContext()</code> 和 <code>androidApplication()</code> 函数注入 <code>Context</code> 和 <code>Application</code> ：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">module &#123;</span><br><span class="line">    single &#123; MyAndroidComponent(androidContext()) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Android组件作为Koin组件"><a href="#Android组件作为Koin组件" class="headerlink" title="Android组件作为Koin组件"></a><a href="https://start.insert-koin.io/#/getting-started/koin-for-android?id=android-components-as-koincomponents">Android组件作为Koin组件</a></h2><p>Koin对 <code>Activity</code>, <code>Fragment</code> &amp; <code>Service</code> 进行了扩展，以将其视为现成的KoinComponents：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyActivity</span> : <span class="type">AppCompatActivity</span>()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inject MyPresenter</span></span><br><span class="line">    <span class="keyword">val</span> presenter : MyPresenter <span class="keyword">by</span> inject()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// or directly retrieve instance</span></span><br><span class="line">        <span class="keyword">val</span> presenter : MyPresenter = <span class="keyword">get</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些类能被使用：</p>
<ul>
<li><code>get()</code> or <code>by inject()</code> instance retrieving 检索实例</li>
<li><code>getKoin()</code> to access th current <code>Koin</code> instance 访问当前 <code>Koin</code> 实例</li>
</ul>
<p>如果您需要注入来自另一个类的依赖项，并且无法在模块中声明它，则仍然可以使用 <code>KoinComponent</code> 接口对其进行标记。</p>
<h2 id="Extended-Scope-API"><a href="#Extended-Scope-API" class="headerlink" title="Extended Scope API"></a><a href="https://start.insert-koin.io/#/getting-started/koin-for-android?id=extended-scope-api">Extended Scope API</a></h2><blockquote>
<p>for Android (koin-android-scope or koin-androidx-scope projects)</p>
</blockquote>
<p>Scope API更接近Android平台。<code>Activity</code> 和 <code>Fragment</code> 都具有Scope API的扩展：<code>currentScope</code> 获取当前关联的Koin scopr。 此scope已创建并绑定到组件的生命周期。</p>
<p>你能直接使用关联的Koin scope来检索组件：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DetailActivity</span> : <span class="type">AppCompatActivity</span>(), DetailContract.View &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject from current activity scope instance</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> presenter: DetailContract.Presenter <span class="keyword">by</span> currentScope.inject()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很容易来声明你的Android组件scope:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">module &#123;</span><br><span class="line">    <span class="comment">// declare a scope for DetailActivity</span></span><br><span class="line">    scope(named&lt;DetailActivity&gt;)&gt; &#123;</span><br><span class="line">        scoped&lt;DetailContract.Presenter&gt; &#123; DetailPresenter(<span class="keyword">get</span>(), <span class="keyword">get</span>()) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何Activity和Fragment都能直接使用scopeAPI： <code>createScope()</code>, <code>getScope()</code> and <code>deleteScope()</code>。</p>
<h2 id="Android-ViewModel"><a href="#Android-ViewModel" class="headerlink" title="Android ViewModel"></a><a href="https://start.insert-koin.io/#/getting-started/koin-for-android?id=android-viewmodel">Android ViewModel</a></h2><blockquote>
<p>(koin-android-viewmodel or koin-androidx-viewmodel projects)</p>
</blockquote>
<p>Koin也带来了一些特殊的特性来管理ViewModel：</p>
<ul>
<li><code>viewModel</code> 特殊的DSL关键来来声明一个ViewModel</li>
<li><code>by viewModel()</code> &amp; <code>getViewModel()</code> 注入ViewModel实例(from <code>Activity</code> &amp; <code>Fragment</code>)</li>
<li><code>by sharedViewModel()</code> &amp; <code>getSharedViewModel()</code> 从宿主Activity中复用ViewModel实例(来自Fragment)</li>
</ul>
<p>让我们在模块中声明一个ViewModel：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> myModule : Module = module &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewModel instance of MyViewModel</span></span><br><span class="line">    <span class="comment">// get() will resolve Repository instance</span></span><br><span class="line">    viewModel &#123; MyViewModel(<span class="keyword">get</span>()) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Single instance of Repository</span></span><br><span class="line">    single&lt;Repository&gt; &#123; MyRepository() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个Activity中注入它：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyActivity</span> : <span class="type">AppCompatActivity</span>()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lazy inject MyViewModel</span></span><br><span class="line">    <span class="keyword">val</span> model : MyViewModel <span class="keyword">by</span> viewModel()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// or also direct retrieve instance</span></span><br><span class="line">        <span class="keyword">val</span> model : MyViewModel = getViewModel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Koin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Koin</tag>
      </tags>
  </entry>
  <entry>
    <title>Koin-2-Setup(初始化)</title>
    <url>/posts/b075de90.html</url>
    <content><![CDATA[<blockquote>
<p><a href="https://start.insert-koin.io/#/setup/index">https://start.insert-koin.io/#/setup/index</a></p>
<p>开始</p>
<ul>
<li><a href="/posts/fd6f0996.html">Intro(介绍)</a></li>
<li><a href="/posts/b075de90.html">Setup(初始化)</a></li>
</ul>
<p>Koin in 5 minutes (5分钟快速入手Koin)</p>
<ul>
<li><a href="/posts/f88fedb6.html">Kotlin</a></li>
<li><a href="/posts/2a806fe1.html">Android</a></li>
<li><a href="/posts/e7ad0613.html">Android Java</a></li>
<li><a href="/posts/6d1e0fe7.html">Android ViewModel</a></li>
</ul>
<p>Getting Started (开始)</p>
<ul>
<li><a href="/posts/c99907a8.html">Starting Koin(开始使用Koin)</a></li>
<li><a href="/posts/d8ca0532.html">Modules &amp; definitions(模块和定义)</a></li>
<li><a href="/posts/f85e8eae.html">Koin Components(Koin组件)</a></li>
<li><a href="/posts/63fa5724.html">Testing(测试)</a></li>
<li><a href="/posts/ebed2a69.html">Koin for Java</a></li>
<li><a href="/posts/f5a785d7.html">Koin for Android</a></li>
</ul>
</blockquote>
<h1 id="为您的项目配置Koin"><a href="#为您的项目配置Koin" class="headerlink" title="为您的项目配置Koin"></a>为您的项目配置Koin</h1><h3 id="最新版本"><a href="#最新版本" class="headerlink" title="最新版本"></a><a href="https://start.insert-koin.io/#/setup/index?id=current-version">最新版本</a></h3><p>Koin的最新版本：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最新的stable版本</span></span><br><span class="line">koin_version= <span class="string">&quot;2.1.6&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最新的unstable版本</span></span><br><span class="line">koin_version= <span class="string">&quot;2.2.0-rc-1&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="Gradle-依赖"><a href="#Gradle-依赖" class="headerlink" title="Gradle 依赖"></a><a href="https://start.insert-koin.io/#/setup/index?id=gradle-dependencies">Gradle 依赖</a></h3><p>添加下面这些Gradle依赖来将Koin添加到您的项目中：</p>
<blockquote>
<p>Koin已经在Jcenter上发布</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add Jcenter to your repositories if needed</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Koin for Kotlin</span></span><br><span class="line">implementation <span class="string">&quot;org.koin:koin-core:$koin_version&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Koin Extended &amp; experimental features</span></span><br><span class="line">implementation <span class="string">&quot;org.koin:koin-core-ext:$koin_version&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Koin for Unit tests</span></span><br><span class="line">testImplementation <span class="string">&quot;org.koin:koin-test:$koin_version&quot;</span></span><br></pre></td></tr></table></figure>
<p>Gradle Plugin</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&quot;org.koin:koin-gradle-plugin:$koin_version&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;koin&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Android</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Koin for Android</span></span><br><span class="line">implementation <span class="string">&quot;org.koin:koin-android:$koin_version&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Koin Android Scope feature</span></span><br><span class="line">implementation <span class="string">&quot;org.koin:koin-android-scope:$koin_version&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Koin Android ViewModel feature</span></span><br><span class="line">implementation <span class="string">&quot;org.koin:koin-android-viewmodel:$koin_version&quot;</span></span><br></pre></td></tr></table></figure>
<p>AndroidX</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Koin AndroidX Scope feature</span></span><br><span class="line">implementation <span class="string">&quot;org.koin:koin-androidx-scope:$koin_version&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Koin AndroidX ViewModel feature</span></span><br><span class="line">implementation <span class="string">&quot;org.koin:koin-androidx-viewmodel:$koin_version&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Koin AndroidX Fragment Factory</span></span><br><span class="line">implementation <span class="string">&quot;org.koin:koin-androidx-fragment:$koin_version&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Koin AndroidX Work Manager (unstable version)</span></span><br><span class="line">implementation <span class="string">&quot;org.koin:koin-androidx-workmanager:$koin_version&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Koin AndroidX Compose (unstable version)</span></span><br><span class="line">implementation <span class="string">&quot;org.koin:koin-androidx-compose:$koin_version&quot;</span></span><br></pre></td></tr></table></figure>
<p>Ktor</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Koin for Ktor Kotlin</span></span><br><span class="line">implementation <span class="string">&quot;org.koin:koin-ktor:$koin_version&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Koin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Koin</tag>
      </tags>
  </entry>
  <entry>
    <title>Koin-3-Kotlin</title>
    <url>/posts/f88fedb6.html</url>
    <content><![CDATA[<blockquote>
<p><a href="https://start.insert-koin.io/#/quickstart/kotlin?id=getting-started-with-kotlin-app">https://start.insert-koin.io/#/quickstart/kotlin?id=getting-started-with-kotlin-app</a></p>
<p>开始</p>
<ul>
<li><a href="/posts/fd6f0996.html">Intro(介绍)</a></li>
<li><a href="/posts/b075de90.html">Setup(初始化)</a></li>
</ul>
<p>Koin in 5 minutes (5分钟快速入手Koin)</p>
<ul>
<li><a href="/posts/f88fedb6.html">Kotlin</a></li>
<li><a href="/posts/2a806fe1.html">Android</a></li>
<li><a href="/posts/e7ad0613.html">Android Java</a></li>
<li><a href="/posts/6d1e0fe7.html">Android ViewModel</a></li>
</ul>
<p>Getting Started (开始)</p>
<ul>
<li><a href="/posts/c99907a8.html">Starting Koin(开始使用Koin)</a></li>
<li><a href="/posts/d8ca0532.html">Modules &amp; definitions(模块和定义)</a></li>
<li><a href="/posts/f85e8eae.html">Koin Components(Koin组件)</a></li>
<li><a href="/posts/63fa5724.html">Testing(测试)</a></li>
<li><a href="/posts/ebed2a69.html">Koin for Java</a></li>
<li><a href="/posts/f5a785d7.html">Koin for Android</a></li>
</ul>
</blockquote>
<h1 id="在Kotlin-app中使用"><a href="#在Kotlin-app中使用" class="headerlink" title="在Kotlin app中使用"></a><a href="https://start.insert-koin.io/#/quickstart/kotlin?id=getting-started-with-kotlin-app">在Kotlin app中使用</a></h1><blockquote>
<p>本教程将会告诉你如何使用Koin注入和检索组件来编写一个Kotlin app。</p>
</blockquote>
<h2 id="获取实例代码"><a href="#获取实例代码" class="headerlink" title="获取实例代码"></a><a href="https://start.insert-koin.io/#/quickstart/kotlin?id=get-the-code">获取实例代码</a></h2><p>可以直接在Github上查看项目或者下载zip</p>
<blockquote>
<p>🚀 Go to <a href="https://github.com/InsertKoinIO/getting-started-koin-core">Github</a> or <a href="https://github.com/InsertKoinIO/getting-started-koin-core/archive/master.zip">download Zip</a></p>
</blockquote>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a><a href="https://start.insert-koin.io/#/quickstart/kotlin?id=setup">配置</a></h2><p>首先，检查下 <code>koin-core</code> 依赖是不是按照如下形式添加了：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add Jcenter to your repositories if needed</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()    </span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// Koin for Kotlin apps</span></span><br><span class="line">    compile <span class="string">&quot;org.koin:koin-core:$koin_version&quot;</span></span><br><span class="line">    <span class="comment">// Testing</span></span><br><span class="line">    testCompile <span class="string">&quot;org.koin:koin-test:$koin_version&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a><a href="https://start.insert-koin.io/#/quickstart/kotlin?id=the-application">Application</a></h2><p>在我们的小型App上，我们只需要有2个组件：</p>
<ul>
<li>HelloMessageData - 持有数据(data)</li>
<li>HelloService - 使用和显示HelloMessageData上的数据</li>
<li>HelloApplication - 检索和使用HelloService</li>
</ul>
<h3 id="Data-holder"><a href="#Data-holder" class="headerlink" title="Data holder"></a><a href="https://start.insert-koin.io/#/quickstart/kotlin?id=data-holder">Data holder</a></h3><p>让我们创建一个 <code>HelloMessageData</code> 数据类来持有我们的数据：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A class to hold our message data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">HelloMessageData</span>(<span class="keyword">val</span> message : String = <span class="string">&quot;Hello Koin!&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a><a href="https://start.insert-koin.io/#/quickstart/kotlin?id=service">Service</a></h3><p>让我们创建一个service来显示 <code>HelloMessageData</code> 中的数据。写一个 <code>HelloServiceImpl</code> 类以及他的接口 <code>HelloService</code> ：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hello Service - interface</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span>: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hello Service Impl</span></span><br><span class="line"><span class="comment"> * Will use HelloMessageData data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span>(<span class="keyword">private</span> <span class="keyword">val</span> helloMessageData: HelloMessageData) : HelloService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> = <span class="string">&quot;Hey, <span class="subst">$&#123;helloMessageData.message&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="The-application-class"><a href="#The-application-class" class="headerlink" title="The application class"></a><a href="https://start.insert-koin.io/#/quickstart/kotlin?id=the-application-class">The application class</a></h2><p>为了让HelloService组件能运行，我们还需要创建一个runtime组件。</p>
<p>让我们写一个 <code>HelloApplication</code> 类并让他实现 <code>KoinComponent</code> 接口。这能让我们稍后可以通过 <code>by inject()</code> 函数来检索我们的组件：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HelloApplication - Application Class</span></span><br><span class="line"><span class="comment"> * use HelloService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloApplication</span> : <span class="type">KoinComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inject HelloService</span></span><br><span class="line">    <span class="keyword">val</span> helloService <span class="keyword">by</span> inject&lt;HelloService&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// display our data</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> = println(helloService.hello())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="声明依赖"><a href="#声明依赖" class="headerlink" title="声明依赖"></a><a href="https://start.insert-koin.io/#/quickstart/kotlin?id=declaring-dependencies">声明依赖</a></h2><p>现在，让我们使用Koin module来将 <code>HelloMessageData</code> 和 <code>HelloService</code> 组装在一起：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> helloModule = module &#123;</span><br><span class="line"></span><br><span class="line">    single &#123; HelloMessageData() &#125;</span><br><span class="line"></span><br><span class="line">    single &#123; HelloServiceImpl(<span class="keyword">get</span>()) <span class="keyword">as</span> HelloService &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用 <code>single</code> 来将每一个组件声明成单例对象。</p>
<ul>
<li><code>single &#123; HelloMessageData() &#125;</code> : 声明一个单例的 <code>HelloMessageData</code> 对象</li>
<li><code>single &#123; HelloServiceImpl(get()) as HelloService &#125;</code> : 使用注入的 <code>HelloMessageData</code> 来构造<code>HelloServiceImpl</code> 对象，并声明成 <code>HelloService</code> 的单例对象。</li>
</ul>
<h2 id="这就完成啦！"><a href="#这就完成啦！" class="headerlink" title="这就完成啦！"></a><a href="https://start.insert-koin.io/#/quickstart/kotlin?id=thats-it">这就完成啦！</a></h2><p>只需要通过一个 <code>main</code> 函数来启动我们的app：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(<span class="keyword">vararg</span> args: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    startKoin &#123;</span><br><span class="line">        <span class="comment">// use Koin logger</span></span><br><span class="line">        printLogger()</span><br><span class="line">        <span class="comment">// declare modules</span></span><br><span class="line">        modules(helloModule)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HelloApplication().sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Koin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Koin</tag>
      </tags>
  </entry>
  <entry>
    <title>Koin-4-Android</title>
    <url>/posts/2a806fe1.html</url>
    <content><![CDATA[<blockquote>
<p><a href="https://start.insert-koin.io/#/quickstart/android">https://start.insert-koin.io/#/quickstart/android</a></p>
<p>开始</p>
<ul>
<li><a href="/posts/fd6f0996.html">Intro(介绍)</a></li>
<li><a href="/posts/b075de90.html">Setup(初始化)</a></li>
</ul>
<p>Koin in 5 minutes (5分钟快速入手Koin)</p>
<ul>
<li><a href="/posts/f88fedb6.html">Kotlin</a></li>
<li><a href="/posts/2a806fe1.html">Android</a></li>
<li><a href="/posts/e7ad0613.html">Android Java</a></li>
<li><a href="/posts/6d1e0fe7.html">Android ViewModel</a></li>
</ul>
<p>Getting Started (开始)</p>
<ul>
<li><a href="/posts/c99907a8.html">Starting Koin(开始使用Koin)</a></li>
<li><a href="/posts/d8ca0532.html">Modules &amp; definitions(模块和定义)</a></li>
<li><a href="/posts/f85e8eae.html">Koin Components(Koin组件)</a></li>
<li><a href="/posts/63fa5724.html">Testing(测试)</a></li>
<li><a href="/posts/ebed2a69.html">Koin for Java</a></li>
<li><a href="/posts/f5a785d7.html">Koin for Android</a></li>
</ul>
</blockquote>
<h1 id="在Android-application中使用"><a href="#在Android-application中使用" class="headerlink" title="在Android application中使用"></a><a href="https://start.insert-koin.io/#/quickstart/android?id=getting-started-with-android-application">在Android application中使用</a></h1><blockquote>
<p>这个教程将会告诉你如何使用Koin注入和检索组件来编写一个Android/Kotlin application。</p>
</blockquote>
<h2 id="Get-the-code"><a href="#Get-the-code" class="headerlink" title="Get the code"></a><a href="https://start.insert-koin.io/#/quickstart/android?id=get-the-code">Get the code</a></h2><p>可以直接在Github上查看项目或者下载zip</p>
<blockquote>
<p>🚀 Go to <a href="https://github.com/InsertKoinIO/getting-started-koin-android">Github</a> or <a href="https://github.com/InsertKoinIO/getting-started-koin-android/archive/master.zip">download Zip</a></p>
</blockquote>
<h2 id="配置Gradle"><a href="#配置Gradle" class="headerlink" title="配置Gradle"></a><a href="https://start.insert-koin.io/#/quickstart/android?id=gradle-setup">配置Gradle</a></h2><p>通过如下方式添加 Koin Android 的依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add Jcenter to your repositories if needed</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()    </span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// Koin for Android</span></span><br><span class="line">    compile <span class="string">&quot;org.koin:koin-android:$koin_version&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a><a href="https://start.insert-koin.io/#/quickstart/android?id=our-components">组件</a></h2><p>让我们来创建一个 <code>HelloRepository</code> 来提供一些数据：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">HelloRepository</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">giveHello</span><span class="params">()</span></span>: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloRepositoryImpl</span>() : HelloRepository &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">giveHello</span><span class="params">()</span></span> = <span class="string">&quot;Hello Koin&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建一个presenter类来消费这个数据：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySimplePresenter</span>(<span class="keyword">val</span> repo: HelloRepository) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> = <span class="string">&quot;<span class="subst">$&#123;repo.giveHello()&#125;</span> from <span class="variable">$this</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编写Koin-Module"><a href="#编写Koin-Module" class="headerlink" title="编写Koin Module"></a><a href="https://start.insert-koin.io/#/quickstart/android?id=writing-the-koin-module">编写Koin Module</a></h2><p>使用 <code>module</code> 函数来声明一个module，让我们来声明我们的第一个组件：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> appModule = module &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// single instance of HelloRepository</span></span><br><span class="line">    single&lt;HelloRepository&gt; &#123; HelloRepositoryImpl() &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Simple Presenter Factory</span></span><br><span class="line">    factory &#123; MySimplePresenter(<span class="keyword">get</span>()) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将我们的 <code>MySimplePresenter</code> 类声明为一个 <code>factory</code> 来让每当我们的Activity需要一个时就创建一个新的对象。</p>
<h2 id="开始使用Koin"><a href="#开始使用Koin" class="headerlink" title="开始使用Koin"></a><a href="https://start.insert-koin.io/#/quickstart/android?id=start-koin">开始使用Koin</a></h2><p>现在我们已经有了一个module，我们就可以使用Koin了。打开你的Application类，或者创建一个(不要忘了在你的Manifest.xml中声明它)。然后只需要调用 <code>startKoin()</code> 函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyApplication</span> : <span class="type">Application</span>()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        <span class="comment">// Start Koin</span></span><br><span class="line">        startKoin&#123;</span><br><span class="line">            androidLogger()</span><br><span class="line">            androidContext(<span class="keyword">this</span><span class="symbol">@MyApplication</span>)</span><br><span class="line">            modules(appModule)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注入依赖"><a href="#注入依赖" class="headerlink" title="注入依赖"></a><a href="https://start.insert-koin.io/#/quickstart/android?id=injecting-dependencies">注入依赖</a></h2><p><code>MySimplePresenter</code> 组件将会被通过 <code>HelloRepository</code> 实例所创建。为了在我们的Activity中获取到它，就需要使用 <code>by inject()</code> 委托注入器来注入它：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySimpleActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lazy injected MySimplePresenter</span></span><br><span class="line">    <span class="keyword">val</span> firstPresenter: MySimplePresenter <span class="keyword">by</span> inject()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>by inject()</code> 函数允许我们在Android组件(Activity, fragment, Service…)运行时再来检索Koin实例。</p>
<p><code>get()</code> 函数在这可以非延迟的直接检索一个实例。</p>
</blockquote>
]]></content>
      <categories>
        <category>Koin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Koin</tag>
      </tags>
  </entry>
  <entry>
    <title>Koin-5-Android_Java</title>
    <url>/posts/e7ad0613.html</url>
    <content><![CDATA[<blockquote>
<p><a href="https://start.insert-koin.io/#/quickstart/android-java">https://start.insert-koin.io/#/quickstart/android-java</a></p>
<p>开始</p>
<ul>
<li><a href="/posts/fd6f0996.html">Intro(介绍)</a></li>
<li><a href="/posts/b075de90.html">Setup(初始化)</a></li>
</ul>
<p>Koin in 5 minutes (5分钟快速入手Koin)</p>
<ul>
<li><a href="/posts/f88fedb6.html">Kotlin</a></li>
<li><a href="/posts/2a806fe1.html">Android</a></li>
<li><a href="/posts/e7ad0613.html">Android Java</a></li>
<li><a href="/posts/6d1e0fe7.html">Android ViewModel</a></li>
</ul>
<p>Getting Started (开始)</p>
<ul>
<li><a href="/posts/c99907a8.html">Starting Koin(开始使用Koin)</a></li>
<li><a href="/posts/d8ca0532.html">Modules &amp; definitions(模块和定义)</a></li>
<li><a href="/posts/f85e8eae.html">Koin Components(Koin组件)</a></li>
<li><a href="/posts/63fa5724.html">Testing(测试)</a></li>
<li><a href="/posts/ebed2a69.html">Koin for Java</a></li>
<li><a href="/posts/f5a785d7.html">Koin for Android</a></li>
</ul>
</blockquote>
<h1 id="在Android-Java-application中使用"><a href="#在Android-Java-application中使用" class="headerlink" title="在Android Java application中使用"></a><a href="https://start.insert-koin.io/#/quickstart/android-java?id=getting-started-with-android-java-application">在Android Java application中使用</a></h1><blockquote>
<p>这个教程将会告诉你如何使用Koin注入和检索组件来编写一个Android Java application。</p>
</blockquote>
<h2 id="Get-the-code"><a href="#Get-the-code" class="headerlink" title="Get the code"></a><a href="https://start.insert-koin.io/#/quickstart/android-java?id=get-the-code">Get the code</a></h2><p>可以直接在Github上查看项目或者下载zip</p>
<blockquote>
<p>🚀 Go to <a href="https://github.com/InsertKoinIO/getting-started-koin-android">Github</a> or <a href="https://github.com/InsertKoinIO/getting-started-koin-android/archive/master.zip">download Zip</a></p>
</blockquote>
<h2 id="配置Gradle"><a href="#配置Gradle" class="headerlink" title="配置Gradle"></a><a href="https://start.insert-koin.io/#/quickstart/android-java?id=gradle-setup">配置Gradle</a></h2><p>通过如下方式添加 Koin Android 的依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add Jcenter to your repositories if needed</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()    </span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// Koin for Android</span></span><br><span class="line">    compile <span class="string">&quot;org.koin:koin-android:$koin_version&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="我们的组件-Java-amp-Kotlin"><a href="#我们的组件-Java-amp-Kotlin" class="headerlink" title="我们的组件 (Java &amp; Kotlin)"></a><a href="https://start.insert-koin.io/#/quickstart/android-java?id=our-components-java-amp-kotlin">我们的组件 (Java &amp; Kotlin)</a></h2><p>让我们创建一个 <code>HelloRepository</code> 来提供一些数据：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">HelloRepository</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">giveHello</span><span class="params">()</span></span>: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloRepositoryImpl</span>() : HelloRepository &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">giveHello</span><span class="params">()</span></span> = <span class="string">&quot;Hello Koin&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们创建一个Java presenter类，来消费这些数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJavaPresenter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HelloRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyJavaPresenter</span><span class="params">(HelloRepository repository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> repository.giveHello();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hello+<span class="string">&quot; from &quot;</span>+<span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编写Koin-Module"><a href="#编写Koin-Module" class="headerlink" title="编写Koin Module"></a><a href="https://start.insert-koin.io/#/quickstart/android-java?id=writing-the-koin-module">编写Koin Module</a></h2><p>使用 <code>module</code> 函数来声明一个module。让我们来声明我们的第一个组件：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> appModule = module &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// single instance of HelloRepository</span></span><br><span class="line">    single&lt;HelloRepository&gt; &#123; HelloRepositoryImpl() &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Simple Presenter Factory</span></span><br><span class="line">    factory &#123; MyJavaPresenter(<span class="keyword">get</span>()) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将 <code>MyJavaPresenter</code> 类声明成 <code>factory</code> 来让每当我们的Activity需要一个时就创建一个新的对象。</p>
<h2 id="开始使用Koin"><a href="#开始使用Koin" class="headerlink" title="开始使用Koin"></a><a href="https://start.insert-koin.io/#/quickstart/android-java?id=start-koin">开始使用Koin</a></h2><p>现在我们已经有了一个module，我们就可以使用Koin了。打开你的Application类，或者创建一个(不要忘了在你的Manifest.xml中声明它)。然后只需要调用 <code>startKoin()</code> 函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyApplication</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">        <span class="comment">// Start Koin</span></span><br><span class="line">        <span class="type">KoinApplication</span> <span class="variable">koin</span> <span class="operator">=</span> KoinAndroidApplication.create(<span class="built_in">this</span>)</span><br><span class="line">            .modules(appModule);</span><br><span class="line">        startKoin(<span class="keyword">new</span> <span class="title class_">GlobalContext</span>(), koin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在Java-Activity中注入依赖"><a href="#在Java-Activity中注入依赖" class="headerlink" title="在Java Activity中注入依赖"></a><a href="https://start.insert-koin.io/#/quickstart/android-java?id=injecting-dependencies-into-java-activity">在Java Activity中注入依赖</a></h2><p><code>MyJavaPresenter</code> 组件将会被通过 <code>HelloRepository</code> 实例所创建。为了在我们的Activity中获取到它，就需要使用 <code>by inject()</code> 委托注入器来注入它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import inject</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.koin.java.standalone.KoinJavaComponent.inject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lazy&lt;MySimplePresenter&gt; presenter = inject(MySimplePresenter.class);</span><br><span class="line">    <span class="keyword">private</span> Lazy&lt;MyJavaPresenter&gt; javaPresenter = inject(MyJavaPresenter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_simple);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>by inject()</code> 函数允许我们在Android组件(Activity, fragment, Service…)运行时再来检索Koin实例。</p>
<p><code>get()</code> 函数在这可以非延迟的直接检索一个实例。</p>
</blockquote>
]]></content>
      <categories>
        <category>Koin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Koin</tag>
      </tags>
  </entry>
  <entry>
    <title>Koin-6-Android_ViewModel</title>
    <url>/posts/6d1e0fe7.html</url>
    <content><![CDATA[<blockquote>
<p><a href="https://start.insert-koin.io/#/quickstart/android-viewmodel">https://start.insert-koin.io/#/quickstart/android-viewmodel</a></p>
<p>开始</p>
<ul>
<li><a href="/posts/fd6f0996.html">Intro(介绍)</a></li>
<li><a href="/posts/b075de90.html">Setup(初始化)</a></li>
</ul>
<p>Koin in 5 minutes (5分钟快速入手Koin)</p>
<ul>
<li><a href="/posts/f88fedb6.html">Kotlin</a></li>
<li><a href="/posts/2a806fe1.html">Android</a></li>
<li><a href="/posts/e7ad0613.html">Android Java</a></li>
<li><a href="/posts/6d1e0fe7.html">Android ViewModel</a></li>
</ul>
<p>Getting Started (开始)</p>
<ul>
<li><a href="/posts/c99907a8.html">Starting Koin(开始使用Koin)</a></li>
<li><a href="/posts/d8ca0532.html">Modules &amp; definitions(模块和定义)</a></li>
<li><a href="/posts/f85e8eae.html">Koin Components(Koin组件)</a></li>
<li><a href="/posts/63fa5724.html">Testing(测试)</a></li>
<li><a href="/posts/ebed2a69.html">Koin for Java</a></li>
<li><a href="/posts/f5a785d7.html">Koin for Android</a></li>
</ul>
</blockquote>
<h1 id="在Android-ViewModel-application中使用"><a href="#在Android-ViewModel-application中使用" class="headerlink" title="在Android ViewModel application中使用"></a><a href="https://start.insert-koin.io/#/quickstart/android-viewmodel?id=getting-started-with-android-viewmodel-application">在Android ViewModel application中使用</a></h1><blockquote>
<p>这个教程将会告诉你如何使用Koin注入和检索ViewModel组件来编写一个Android/Kotlin application。</p>
</blockquote>
<h2 id="Get-the-code"><a href="#Get-the-code" class="headerlink" title="Get the code"></a><a href="https://start.insert-koin.io/#/quickstart/android-viewmodel?id=get-the-code">Get the code</a></h2><p>可以直接在Github上查看项目或者下载zip</p>
<blockquote>
<p>🚀 Go to <a href="https://github.com/InsertKoinIO/getting-started-koin-android">Github</a> or <a href="https://github.com/InsertKoinIO/getting-started-koin-android/archive/master.zip">download Zip</a></p>
</blockquote>
<h2 id="配置Gradle"><a href="#配置Gradle" class="headerlink" title="配置Gradle"></a><a href="https://start.insert-koin.io/#/quickstart/android-viewmodel?id=gradle-setup">配置Gradle</a></h2><p>通过如下方式添加 Koin Android 的依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add Jcenter to your repositories if needed</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()    </span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// Koin for Android - Scope feature</span></span><br><span class="line">    <span class="comment">// include koin-android-scope &amp; koin-android</span></span><br><span class="line">    compile <span class="string">&quot;org.koin:koin-android-viewmodel:$koin_version&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="我们的组件"><a href="#我们的组件" class="headerlink" title="我们的组件"></a><a href="https://start.insert-koin.io/#/quickstart/android-viewmodel?id=our-components">我们的组件</a></h2><p>让我们创建一个 <code>HelloRepository</code> 来提供一些数据：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">HelloRepository</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">giveHello</span><span class="params">()</span></span>: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloRepositoryImpl</span>() : HelloRepository &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">giveHello</span><span class="params">()</span></span> = <span class="string">&quot;Hello Koin&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们创建一个ViewModel类，来消费这些数据：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyViewModel</span>(<span class="keyword">val</span> repo : HelloRepository) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> = <span class="string">&quot;<span class="subst">$&#123;repo.giveHello()&#125;</span> from <span class="variable">$this</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编写Koin-module"><a href="#编写Koin-module" class="headerlink" title="编写Koin module"></a><a href="https://start.insert-koin.io/#/quickstart/android-viewmodel?id=writing-the-koin-module">编写Koin module</a></h2><p>使用 <code>module</code> 函数来声明一个module。让我们声明我们的第一个组件：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> appModule = module &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// single instance of HelloRepository</span></span><br><span class="line">    single&lt;HelloRepository&gt; &#123; HelloRepositoryImpl() &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MyViewModel ViewModel</span></span><br><span class="line">    viewModel &#123; MyViewModel(<span class="keyword">get</span>()) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个 <code>module</code> 中，我们将我们的 <code>MyViewModel</code> 类声明成一个 <code>viewModel</code>。Koin将会将这个 <code>MyViewModel</code> 交给Lifecycle ViewModelFactory并帮我们将它绑定到当前的组件上。</p>
<h2 id="开始使用Koin"><a href="#开始使用Koin" class="headerlink" title="开始使用Koin"></a><a href="https://start.insert-koin.io/#/quickstart/android-viewmodel?id=start-koin">开始使用Koin</a></h2><p>现在我们已经有了一个module，我们就可以使用Koin了。打开你的Application类，或者创建一个(不要忘了在你的Manifest.xml中声明它)。然后只需要调用 <code>startKoin()</code> 函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyApplication</span> : <span class="type">Application</span>()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        <span class="comment">// Start Koin</span></span><br><span class="line">        startKoin&#123;</span><br><span class="line">            androidLogger()</span><br><span class="line">            androidContext(<span class="keyword">this</span><span class="symbol">@MyApplication</span>)</span><br><span class="line">            modules(appModule)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注入依赖"><a href="#注入依赖" class="headerlink" title="注入依赖"></a><a href="https://start.insert-koin.io/#/quickstart/android-viewmodel?id=injecting-dependencies">注入依赖</a></h2><p><code>MyViewModel</code> 组件将会被通过 <code>HelloRepository</code> 实例所创建。为了在我们的Activity中获取到它，就需要使用 <code>by viewModel()</code> 委托注入器来注入它：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyViewModelActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lazy Inject ViewModel</span></span><br><span class="line">    <span class="keyword">val</span> myViewModel: MyViewModel <span class="keyword">by</span> viewModel()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_simple)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>by viewModel()</code> 函数允许我们从Koin中检索一个ViewModel实例，链接到Android ViewModelFactory。</p>
<p><code>getViewModel()</code> 函数能非延迟的直接检索一个实例。</p>
</blockquote>
]]></content>
      <categories>
        <category>Koin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Koin</tag>
      </tags>
  </entry>
  <entry>
    <title>Koin-7-Starting_Koin</title>
    <url>/posts/c99907a8.html</url>
    <content><![CDATA[<blockquote>
<p><a href="https://start.insert-koin.io/#/getting-started/starting-koin">https://start.insert-koin.io/#/getting-started/starting-koin</a></p>
<p>开始</p>
<ul>
<li><a href="/posts/fd6f0996.html">Intro(介绍)</a></li>
<li><a href="/posts/b075de90.html">Setup(初始化)</a></li>
</ul>
<p>Koin in 5 minutes (5分钟快速入手Koin)</p>
<ul>
<li><a href="/posts/f88fedb6.html">Kotlin</a></li>
<li><a href="/posts/2a806fe1.html">Android</a></li>
<li><a href="/posts/e7ad0613.html">Android Java</a></li>
<li><a href="/posts/6d1e0fe7.html">Android ViewModel</a></li>
</ul>
<p>Getting Started (开始)</p>
<ul>
<li><a href="/posts/c99907a8.html">Starting Koin(开始使用Koin)</a></li>
<li><a href="/posts/d8ca0532.html">Modules &amp; definitions(模块和定义)</a></li>
<li><a href="/posts/f85e8eae.html">Koin Components(Koin组件)</a></li>
<li><a href="/posts/63fa5724.html">Testing(测试)</a></li>
<li><a href="/posts/ebed2a69.html">Koin for Java</a></li>
<li><a href="/posts/f5a785d7.html">Koin for Android</a></li>
</ul>
<p>Koin is a DSL, a container &amp; a pragamtic API to leverage your dependencies.</p>
<p>Koin是一个DSL、一个容器、一个实用的API来有效利用我们的依赖</p>
</blockquote>
<p>Koin DSL包含这些：</p>
<ul>
<li>KoinApplication DSL: 描述如何配置你的Koin Application</li>
<li>Module DSL: 描述你的定义</li>
</ul>
<p>开始使用Koin可以通过如下几种使用 <code>startKoin</code> 的形式：</p>
<h2 id="StartKoin"><a href="#StartKoin" class="headerlink" title="StartKoin"></a><a href="https://start.insert-koin.io/#/getting-started/starting-koin?id=startkoin">StartKoin</a></h2><p>在一个Kotlin文件中：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(<span class="keyword">vararg</span> args: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    startKoin &#123;</span><br><span class="line">        <span class="comment">// enable Printlogger with default Level.INFO 使用默认Level.INFO来开启Printlogger</span></span><br><span class="line">        <span class="comment">// can have Level &amp; implementation 有Level和implementation</span></span><br><span class="line">        <span class="comment">// equivalent to logger(Level.INFO, PrintLogger()) 相当于Logger</span></span><br><span class="line">        printlogger() </span><br><span class="line"></span><br><span class="line">        <span class="comment">// declare properties from given map 从给定的map中声明属性</span></span><br><span class="line">        properties( <span class="comment">/* properties map */</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load properties from koin.properties file or given file name </span></span><br><span class="line">        <span class="comment">// 从koin.properties文件或者给定的文件名中加载属性</span></span><br><span class="line">        fileProperties()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load properties from environment 从环境中加载属性</span></span><br><span class="line">        environmentProperties()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// list all used modules 列出所有的module</span></span><br><span class="line">        <span class="comment">// as list or vararg 通过list或者可变长度的参数</span></span><br><span class="line">        modules(myModules) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Starting-for-Android"><a href="#Starting-for-Android" class="headerlink" title="Starting for Android"></a><a href="https://start.insert-koin.io/#/getting-started/starting-koin?id=starting-for-android">Starting for Android</a></h2><p>在任何一个Android类中：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainApplication</span> : <span class="type">Application</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line"></span><br><span class="line">        startKoin &#123;</span><br><span class="line">            <span class="comment">// use AndroidLogger as Koin Logger - default Level.INFO</span></span><br><span class="line">            <span class="comment">// 使用AndroidLogger作为Koin Logger - 默认Level.INFO</span></span><br><span class="line">            androidLogger()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// use the Android context given there 使用这给出的Android context</span></span><br><span class="line">            androidContext(<span class="keyword">this</span><span class="symbol">@MainApplication</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// load properties from assets/koin.properties file 从assets/koin.properties文件中加载属性</span></span><br><span class="line">            androidFileProperties()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// module list</span></span><br><span class="line">            modules(myModules)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你不能注入Android context或者application，那就确保在你的Koin application声明中使用 <code>androidContext()</code> 函数。</p>
<h2 id="Starting-for-Ktor"><a href="#Starting-for-Ktor" class="headerlink" title="Starting for Ktor"></a><a href="https://start.insert-koin.io/#/getting-started/starting-koin?id=starting-for-ktor">Starting for Ktor</a></h2><p>Starting Koin from your <code>Application</code> extension function:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Application.<span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Install Ktor features</span></span><br><span class="line">    install(Koin) &#123;</span><br><span class="line">        <span class="comment">// Use SLF4J Koin Logger at Level.INFO</span></span><br><span class="line">        slf4jLogger()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// declare used modules</span></span><br><span class="line">        modules(myModules)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义Koin实例"><a href="#自定义Koin实例" class="headerlink" title="自定义Koin实例"></a><a href="https://start.insert-koin.io/#/getting-started/starting-koin?id=custom-koin-instance">自定义Koin实例</a></h2><p>Here below are the KoinApplication builders:</p>
<p>下面这些是KoinApplicatioon builders(构造者)：</p>
<ul>
<li><code>startKoin &#123; &#125;</code> - 创建并注册如下的KoinApplication实例</li>
<li><code>koinApplication &#123; &#125;</code> - 创建KoinApplication实例</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create and register following KoinApplication instance</span></span><br><span class="line">startKoin &#123;</span><br><span class="line">    logger()</span><br><span class="line">    modules(coffeeAppModule)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create KoinApplication instance</span></span><br><span class="line">koinApplication &#123;</span><br><span class="line">    logger()</span><br><span class="line">    modules(coffeeAppModule)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a><a href="https://start.insert-koin.io/#/getting-started/starting-koin?id=logging">Logging</a></h2><p>开始时，Koin log就需要被定义他的名字或类型(如果log是活跃状态)：(<em>At start, Koin log what definition is bound by name or type (if log is activated):</em>)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[INFO] [Koin] bind type:&#x27;org.koin.example.CoffeeMaker&#x27; ~ [type:Single,class:&#x27;org.koin.example.CoffeeMaker&#x27;]</span><br><span class="line">[INFO] [Koin] bind type:&#x27;org.koin.example.Pump&#x27; ~ [type:Single,class:&#x27;org.koin.example.Pump&#x27;]</span><br><span class="line">[INFO] [Koin] bind type:&#x27;org.koin.example.Heater&#x27; ~ [type:Single,class:&#x27;org.koin.example.Heater&#x27;]</span><br></pre></td></tr></table></figure>
<h2 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a><a href="https://start.insert-koin.io/#/getting-started/starting-koin?id=dsl">DSL</a></h2><p>快速回顾一下Koin DSL关键字：</p>
<ul>
<li><code>startKoin &#123; &#125;</code> - 创建和注册如下的KoinApplication实例</li>
<li><code>koinApplication &#123; &#125;</code> - 创建KoinApplication实例</li>
<li><code>modules(...)</code> - 声明使用的modules</li>
<li><code>logger()</code> - 声明Printlogger</li>
<li><code>properties(...)</code> - 声明map属性</li>
<li><code>fileProperties()</code> - 从文件中使用属性</li>
<li><code>environmentProperties()</code> - 从环境中使用属性</li>
<li><code>androidLogger()</code> - 声明 Android Koin logger</li>
<li><code>androidContext(...)</code> - 使用给出的Android context</li>
<li><code>androidFileProperties()</code> - 使用 Android assets 中的属性文件</li>
<li><code>slf4jLogger(...)</code> - 使用SLF4J Logger</li>
</ul>
]]></content>
      <categories>
        <category>Koin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Koin</tag>
      </tags>
  </entry>
  <entry>
    <title>Koin-8-Modules &amp; definitions(模块和定义)</title>
    <url>/posts/d8ca0532.html</url>
    <content><![CDATA[<blockquote>
<p><a href="https://start.insert-koin.io/#/getting-started/modules-definitions">https://start.insert-koin.io/#/getting-started/modules-definitions</a></p>
<p>开始</p>
<ul>
<li><a href="/posts/fd6f0996.html">Intro(介绍)</a></li>
<li><a href="/posts/b075de90.html">Setup(初始化)</a></li>
</ul>
<p>Koin in 5 minutes (5分钟快速入手Koin)</p>
<ul>
<li><a href="/posts/f88fedb6.html">Kotlin</a></li>
<li><a href="/posts/2a806fe1.html">Android</a></li>
<li><a href="/posts/e7ad0613.html">Android Java</a></li>
<li><a href="/posts/6d1e0fe7.html">Android ViewModel</a></li>
</ul>
<p>Getting Started (开始)</p>
<ul>
<li><a href="/posts/c99907a8.html">Starting Koin(开始使用Koin)</a></li>
<li><a href="/posts/d8ca0532.html">Modules &amp; definitions(模块和定义)</a></li>
<li><a href="/posts/f85e8eae.html">Koin Components(Koin组件)</a></li>
<li><a href="/posts/63fa5724.html">Testing(测试)</a></li>
<li><a href="/posts/ebed2a69.html">Koin for Java</a></li>
<li><a href="/posts/f5a785d7.html">Koin for Android</a></li>
</ul>
</blockquote>
<p>用Koin编写定义是通过Kotlin函数完成的，该函数描述了实例的构建方式。 </p>
<p>配置完Koin应用程序后，让我们来编写一些模块和定义。</p>
<h2 id="模块-amp-定义"><a href="#模块-amp-定义" class="headerlink" title="模块 &amp; 定义"></a><a href="https://start.insert-koin.io/#/getting-started/modules-definitions?id=module-amp-definitions">模块 &amp; 定义</a></h2><p>给出我们需要去注入的类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataRepository</span>()</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Presenter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPresenter</span>(<span class="keyword">val</span> repository : Repository) : Presenter</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpClient</span>(<span class="keyword">val</span> url : String)</span><br></pre></td></tr></table></figure>
<p>下面展示如何定义这些组件：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// declare a module</span></span><br><span class="line"><span class="comment">// 定义一个module</span></span><br><span class="line"><span class="keyword">val</span> myModule = module &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define a singleton for type DataRepository</span></span><br><span class="line">    <span class="comment">// 为DataRepository定义一个单例</span></span><br><span class="line">    single &#123; DataRepository() &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define a factory (create a new instance each time) for type Presenter (infered parameter in &lt;&gt;)</span></span><br><span class="line">    <span class="comment">// Resolve constructor dependency with get()</span></span><br><span class="line">    <span class="comment">// 为Presenter(在&lt;&gt;中推断类型)定义一个factory(每次都创建一个新的实例)</span></span><br><span class="line">    <span class="comment">// 使用 get() 解析构造函数依赖</span></span><br><span class="line">    factory&lt;Presenter&gt; &#123; MyPresenter(<span class="keyword">get</span>()) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define a singleton of type HttpClient</span></span><br><span class="line">    <span class="comment">// inject property &quot;server_url&quot; from Koin properties</span></span><br><span class="line">    <span class="comment">// 定义一个HttpClient类的单利</span></span><br><span class="line">    <span class="comment">// 从Koin属性中注入&quot;server_url&quot;这个属性</span></span><br><span class="line">    single &#123; HttpClient(getProperty(<span class="string">&quot;server_url&quot;</span>)) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a><a href="https://start.insert-koin.io/#/getting-started/modules-definitions?id=qualifiers">修饰符</a></h2><p>你可以给组件提供一个修饰符。这个修饰符可以是string或者type，并通过 <code>named()</code> 函数进行配置：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> myModule = module &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define a singleton for type  DataRepository</span></span><br><span class="line">    <span class="comment">// 为DataRepository定义一个单例</span></span><br><span class="line">    single &#123; DataRepository() &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mock</span></span><br><span class="line">    single(named(<span class="string">&quot;mock&quot;</span>)) &#123; MockDataRepository() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>修饰符可以与枚举类关联，也可以直接与类型关联：</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Type qualifier</span></span><br><span class="line">single(named&lt;MyClass&gt;()) &#123; MockDataRepository() &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enum qualifier</span></span><br><span class="line">single(named&lt;MyEnum.MyValue&gt;()) &#123; MockDataRepository() &#125;</span><br></pre></td></tr></table></figure>
<h2 id="其它类型"><a href="#其它类型" class="headerlink" title="其它类型"></a><a href="https://start.insert-koin.io/#/getting-started/modules-definitions?id=additional-types">其它类型</a></h2><p>在DLS模块中，对于一个定义，你可以使用 <code>bind</code> 操作符(KClass列表使用 <code>binds</code>)来给定一些额外的类型去绑定：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">module &#123;</span><br><span class="line">    single &#123; Component1() &#125; bind ComponentInterface1::<span class="keyword">class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后你就能通过 <code>get&lt;Component1&gt;()</code> 或者 <code>get&lt;ComponentInterface1&gt;()</code> 来请求到你的实例了。</p>
<p>你也能给多个定义绑定同一个type：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">module &#123;</span><br><span class="line">    single &#123; Component1() &#125; bind ComponentInterface1::<span class="keyword">class</span></span><br><span class="line">    <span class="title class_">single</span> &#123; Component2() &#125; bind ComponentInterface1::<span class="keyword">class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在这你不能通过 <code>get&lt;Simple.ComponentInterface1&gt;()</code> 来请求一个实例。你只能使用 <code>koin.bind&lt;Component1,ComponentInterface1&gt;()</code> 来检索一个具有 <code>Component1</code> 实现的 <code>ComponentInterface1</code> 的实例。</p>
<p>请注意，您还可以查找绑定给定类型的所有组件： <code>getAll&lt;ComponentInterface1&gt;()</code> 将请求所有绑定 <code>ComponentInterface1</code> 类的实例。</p>
<h2 id="组合模块"><a href="#组合模块" class="headerlink" title="组合模块"></a><a href="https://start.insert-koin.io/#/getting-started/modules-definitions?id=combining-several-modules">组合模块</a></h2><p>Koin没有导入(import)的概念。所以只需结合几个互补的模块定义。</p>
<p>让我们在两个模块中分发定义：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> module1 = module &#123;</span><br><span class="line">    single &#123; DataRepository() &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> module2 = module &#123;</span><br><span class="line">    factory&lt;Presenter&gt; &#123; MyPresenter(<span class="keyword">get</span>()) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只需要为Koin列出他们：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">startKoin &#123;</span><br><span class="line">    modules(module1,module2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="启动后加载"><a href="#启动后加载" class="headerlink" title="启动后加载"></a><a href="https://start.insert-koin.io/#/getting-started/modules-definitions?id=loading-after-start">启动后加载</a></h2><p>在Koin通过 <code>startKoin &#123; &#125;</code> 函数启动后，我们还可以使用 <code>loadKoinModules(modules...)</code> 函数来加载其它定义模块。</p>
<h2 id="删除定义"><a href="#删除定义" class="headerlink" title="删除定义"></a><a href="https://start.insert-koin.io/#/getting-started/modules-definitions?id=dropping-definitions">删除定义</a></h2><p>一旦一个模块被加载到了Koin中，我们就可以取消加载他然后删除掉与这些定义相关的定义和实例。为此，我们可以使用 <code>unloadKoinModules(modules...)</code> ：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> module = module &#123;</span><br><span class="line">    single &#123; (id: <span class="built_in">Int</span>) -&gt; Simple.MySingle(id) &#125;</span><br><span class="line">&#125;</span><br><span class="line">startKoin &#123;</span><br><span class="line">    printLogger(Level.DEBUG)</span><br><span class="line">    modules(module)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">get</span>&lt;Simple.MySingle&gt; &#123; parametersOf(<span class="number">42</span>) &#125; -&gt; id <span class="keyword">is</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unload definitions for given module</span></span><br><span class="line">unloadKoinModules(module)</span><br><span class="line"><span class="comment">// load definitions for given module</span></span><br><span class="line">loadKoinModules(module)</span><br><span class="line"></span><br><span class="line"><span class="keyword">get</span>&lt;Simple.MySingle&gt; &#123; parametersOf(<span class="number">24</span>) &#125; -&gt; id <span class="keyword">is</span> <span class="number">24</span></span><br></pre></td></tr></table></figure>
<h2 id="即时声明"><a href="#即时声明" class="headerlink" title="即时声明"></a><a href="https://start.insert-koin.io/#/getting-started/modules-definitions?id=declare-on-the-fly">即时声明</a></h2><p>Koin 1.0的最后一个向后移植<em>(译者注：原文是backport)</em>功能之一是能够动态声明实例。现在可以在Koin.declare（）或Scope.declare（）上使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> koin = koinApplication &#123;</span><br><span class="line">    <span class="comment">// no def</span></span><br><span class="line">    modules()</span><br><span class="line">&#125;.koin</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an instance</span></span><br><span class="line"><span class="keyword">val</span> a = Simple.ComponentA()</span><br><span class="line"></span><br><span class="line"><span class="comment">// declare it</span></span><br><span class="line">koin.declare(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// retrieve it</span></span><br><span class="line">assertEquals(a, koin.<span class="keyword">get</span>&lt;Simple.ComponentA&gt;())</span><br></pre></td></tr></table></figure>
<p>你也能通过一个修饰符或者次要类型来帮助你创建定义：</p>
<ul>
<li><code>koin.declare(myInstance, named(&quot;qualifier&quot;))</code></li>
<li><code>koin.declare(myInstance, secondaryTypes = listOf())</code></li>
</ul>
<h2 id="DSL回顾"><a href="#DSL回顾" class="headerlink" title="DSL回顾"></a><a href="https://start.insert-koin.io/#/getting-started/modules-definitions?id=dsl-recap">DSL回顾</a></h2><p>快速回顾下这些Koin关键字：</p>
<ul>
<li><code>module &#123; &#125;</code> - 创建一个Koin模块或者子模块(在一个模块里面)</li>
<li><code>factory &#123; &#125;</code> - 提供一个 <em>factory工厂</em> bean定义</li>
<li><code>single &#123; &#125;</code> - 提供一个bean定义</li>
<li><code>get()</code> - 解析一个组件依赖</li>
<li><code>named()</code> - 通过type、枚举或者字符串来定义一个修饰符</li>
<li><code>bind</code> - 给给定的bean定义绑定其它Kolin类型</li>
<li><code>binds</code> - 给给定的bean定义绑定其他Kotlin类型列表</li>
<li><code>getProperty()</code> - 解析一个Koin属性</li>
</ul>
]]></content>
      <categories>
        <category>Koin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Koin</tag>
      </tags>
  </entry>
  <entry>
    <title>Koin-9-Koin Components(组件)</title>
    <url>/posts/f85e8eae.html</url>
    <content><![CDATA[<blockquote>
<p><a href="https://start.insert-koin.io/#/getting-started/koin-components">https://start.insert-koin.io/#/getting-started/koin-components</a></p>
<p>开始</p>
<ul>
<li><a href="/posts/fd6f0996.html">Intro(介绍)</a></li>
<li><a href="/posts/b075de90.html">Setup(初始化)</a></li>
</ul>
<p>Koin in 5 minutes (5分钟快速入手Koin)</p>
<ul>
<li><a href="/posts/f88fedb6.html">Kotlin</a></li>
<li><a href="/posts/2a806fe1.html">Android</a></li>
<li><a href="/posts/e7ad0613.html">Android Java</a></li>
<li><a href="/posts/6d1e0fe7.html">Android ViewModel</a></li>
</ul>
<p>Getting Started (开始)</p>
<ul>
<li><a href="/posts/c99907a8.html">Starting Koin(开始使用Koin)</a></li>
<li><a href="/posts/d8ca0532.html">Modules &amp; definitions(模块和定义)</a></li>
<li><a href="/posts/f85e8eae.html">Koin Components(Koin组件)</a></li>
<li><a href="/posts/63fa5724.html">Testing(测试)</a></li>
<li><a href="/posts/ebed2a69.html">Koin for Java</a></li>
<li><a href="/posts/f5a785d7.html">Koin for Android</a></li>
</ul>
</blockquote>
<p>有时不能仅通过Koin声明组件。依赖于你的运行时技术，你可能需要在一个不是用Koin创建的类中从Koin检索实例（例如Android）。</p>
<h2 id="Koin组件实例"><a href="#Koin组件实例" class="headerlink" title="Koin组件实例"></a><a href="https://start.insert-koin.io/#/getting-started/koin-components?id=the-koincomponent-interface">Koin组件实例</a></h2><p>通过 <code>KoinComponent</code> 接口来标记你的类就能解锁Koin的注入功能：</p>
<ul>
<li><code>by inject()</code> - 延迟注入一个实例</li>
<li><code>get()</code> - 检索一个实例</li>
<li><code>getProperty()</code> - 获得一个Koin属性</li>
</ul>
<p>我们可以将上面的模块注入到类属性中：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tag class with KoinComponent</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloApp</span> : <span class="type">KoinComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lazy inject dependency</span></span><br><span class="line">    <span class="keyword">val</span> helloService: HelloServiceImpl <span class="keyword">by</span> inject()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        helloService.sayHello()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就只需要开启Koin并运行我们的类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a module with our declared Koin dependencies </span></span><br><span class="line"><span class="keyword">val</span> helloModule = module &#123;</span><br><span class="line">    single &#123; HelloServiceImpl() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(<span class="keyword">vararg</span> args: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start Koin</span></span><br><span class="line">    startKoin &#123;</span><br><span class="line">        modules(helloModule)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run our Koin component</span></span><br><span class="line">    HelloApp().sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引导"><a href="#引导" class="headerlink" title="引导"></a><a href="https://start.insert-koin.io/#/getting-started/koin-components?id=bootstrapping">引导</a></h4><blockquote>
<p><code>KoinComponent</code> 接口也能被用来协助你从Koin外部引导一个应用程序。另外，您可以通过扩展函数直接在一些目标类上引入“KoinComponent”特性（即：Android中的Activity、Fragment have KoinComponent特性）。</p>
</blockquote>
<h2 id="Bridge-with-Koin-instance"><a href="#Bridge-with-Koin-instance" class="headerlink" title="Bridge with Koin instance"></a><a href="https://start.insert-koin.io/#/getting-started/koin-components?id=bridge-with-koin-instance">Bridge with Koin instance</a></h2><p><code>KoinComponent</code> 接口主要带来了如下内容：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">KoinComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the associated Koin instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getKoin</span><span class="params">()</span></span>: Koin = GlobalContext.<span class="keyword">get</span>().koin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他带来了如下的可能性：</p>
<blockquote>
<p>然后可以重新定义 <code>getKoin()</code> 函数，以重定向到本地自定义Koin实例</p>
</blockquote>
]]></content>
      <categories>
        <category>Koin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Koin</tag>
      </tags>
  </entry>
  <entry>
    <title>uCrop框架用法和源码解析</title>
    <url>/posts/4e4b8b52.html</url>
    <content><![CDATA[<blockquote>
<p>本人能力不足，在看到源码最后一部分的时候大量抄袭<a href="https://www.jianshu.com/p/1d3fb16fb412">可能是最详细的UCrop源码解析</a></p>
</blockquote>
<h1 id="1-uCrop简介"><a href="#1-uCrop简介" class="headerlink" title="1. uCrop简介"></a>1. uCrop简介</h1><p>uCrop是目前较火的图片裁剪框架，开发者宣称他会比目前市面上所有的图片裁剪方案都要更流畅。外加他封装程度较高，可自定义，而且颜值很高（似乎这个才是重点），现在越来越多APP选择使用它。<br><a href="https://github.com/Yalantis/uCrop">github</a><br><span id="more"></span></p>
<h1 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2. 使用方法"></a>2. 使用方法</h1><p>得益于uCrop优秀的封装，uCrop的使用方法特简单。</p>
<h2 id="2-1-导入依赖"><a href="#2-1-导入依赖" class="headerlink" title="2.1 导入依赖"></a>2.1 导入依赖</h2><ol>
<li><p>先在项目的<code>build.gradle</code>中添加</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    maven &#123; url <span class="string">&quot;https://jitpack.io&quot;</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 并在<code>module</code>的<code>build.gradle</code>中添加</p>
<p> <code>implementation &#39;com.github.yalantis:ucrop:2.2.3&#39;</code> - 轻量级框架</p>
<p> <code>implementation &#39;com.github.yalantis:ucrop:2.2.3-native&#39;</code> - 获得框架全部强大的功能以及图片的高质量(最终可能会导致apk的大小增加1.5MB以上)</p>
</li>
<li>由于框架的本质是调用到另一个Activity去处理图片，所以需要在AndroidManifest.xml中将UCropActivity添加进去 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;com.yalantis.ucrop.UCropActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:screenOrientation</span>=<span class="string">&quot;portrait&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.AppCompat.Light.NoActionBar&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>到这你就能把cUrop全部导入到你的项目里面了，接下来咱们就拉将如何调用</p>
<h2 id="2-2-开始基本的调用"><a href="#2-2-开始基本的调用" class="headerlink" title="2.2 开始基本的调用"></a>2.2 开始基本的调用</h2><p>调用起来很简单：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UCrop.of(sourceUri, destinationUri)</span><br><span class="line">    .start(context);</span><br></pre></td></tr></table></figure><br>其中<code>sourceUri</code>是输入图片的<code>Uri</code>，<code>destinationUri</code>是输出图片的<code>Uri</code>。然后他就会由<code>Intent</code>的调动跳到<code>UCropActivity</code>，用户就在<code>UCropActivity</code>里面进行图片裁剪操作，然后最后由<code>UCropActivity</code>发起一个<code>Intent</code>回到你的<code>Activity</code>。</p>
<h2 id="2-3-处理回来的数据"><a href="#2-3-处理回来的数据" class="headerlink" title="2.3 处理回来的数据"></a>2.3 处理回来的数据</h2><p>由于是从<code>UCropAcitivity</code>传回数据，所以你需要在你的<code>Activity</code>里面的<code>onActivityResult</code>方法处理<code>uCrop</code>返回的信息：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="type">int</span> resultCode, Intent data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (resultCode == RESULT_OK &amp;&amp; requestCode == UCrop.REQUEST_CROP) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Uri</span> <span class="variable">resultUri</span> <span class="operator">=</span> UCrop.getOutput(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resultCode == UCrop.RESULT_ERROR) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Throwable</span> <span class="variable">cropError</span> <span class="operator">=</span> UCrop.getError(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这，基本用法就完了，你就可以尽情的使用uCrop。但是我前面说过，uCrop封装程度好，这点很多图片处理框架都可以做到，基本上都是把需要的数据传到自己的Activity之后由自己的Activity处理，所以很多框架看起来都有优秀的封装，那uCrop相比其他又有啥好呢，答案就是自定义灵活：</p>
<h2 id="2-4-uCrop高阶用法"><a href="#2-4-uCrop高阶用法" class="headerlink" title="2.4 uCrop高阶用法"></a>2.4 uCrop高阶用法</h2><h3 id="2-4-1-配置uCrop"><a href="#2-4-1-配置uCrop" class="headerlink" title="2.4.1 配置uCrop"></a>2.4.1 配置uCrop</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 启动裁剪</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> activity 上下文</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> sourceFilePath 需要裁剪图片的绝对路径</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> requestCode 比如：UCrop.REQUEST_CROP</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> aspectRatioX 裁剪图片宽高比</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> aspectRatioY 裁剪图片宽高比</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">startUCrop</span><span class="params">(Activity activity, String sourceFilePath, </span></span><br><span class="line"><span class="params">	<span class="type">int</span> requestCode, <span class="type">float</span> aspectRatioX, <span class="type">float</span> aspectRatioY)</span> &#123;</span><br><span class="line">    <span class="type">Uri</span> <span class="variable">sourceUri</span> <span class="operator">=</span> Uri.fromFile(<span class="keyword">new</span> <span class="title class_">File</span>(sourceFilePath));</span><br><span class="line">    <span class="type">File</span> <span class="variable">outDir</span> <span class="operator">=</span> Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);</span><br><span class="line">    <span class="keyword">if</span> (!outDir.exists()) &#123;</span><br><span class="line">        outDir.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">File</span> <span class="variable">outFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(outDir, System.currentTimeMillis() + <span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//裁剪后图片的绝对路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cameraScalePath</span> <span class="operator">=</span> outFile.getAbsolutePath();</span><br><span class="line">    <span class="type">Uri</span> <span class="variable">destinationUri</span> <span class="operator">=</span> Uri.fromFile(outFile);</span><br><span class="line">    <span class="comment">//初始化，第一个参数：需要裁剪的图片；第二个参数：裁剪后图片</span></span><br><span class="line">    <span class="type">UCrop</span> <span class="variable">uCrop</span> <span class="operator">=</span> UCrop.of(sourceUri, destinationUri);</span><br><span class="line">    <span class="comment">//初始化UCrop配置</span></span><br><span class="line">    UCrop.<span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UCrop</span>.Options();</span><br><span class="line">    <span class="comment">//设置裁剪图片可操作的手势</span></span><br><span class="line">    options.setAllowedGestures(UCropActivity.SCALE, UCropActivity.ROTATE, UCropActivity.ALL);</span><br><span class="line">    <span class="comment">//是否隐藏底部容器，默认显示</span></span><br><span class="line">    options.setHideBottomControls(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//设置toolbar颜色</span></span><br><span class="line">    options.setToolbarColor(ActivityCompat.getColor(activity, R.color.colorPrimary));</span><br><span class="line">    <span class="comment">//设置状态栏颜色</span></span><br><span class="line">    options.setStatusBarColor(ActivityCompat.getColor(activity, R.color.colorPrimary));</span><br><span class="line">    <span class="comment">//是否能调整裁剪框</span></span><br><span class="line">    options.setFreeStyleCropEnabled(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//UCrop配置</span></span><br><span class="line">    uCrop.withOptions(options);</span><br><span class="line">    <span class="comment">//设置裁剪图片的宽高比，比如16：9</span></span><br><span class="line">    uCrop.withAspectRatio(aspectRatioX, aspectRatioY);</span><br><span class="line">    <span class="comment">//uCrop.useSourceImageAspectRatio();</span></span><br><span class="line">    <span class="comment">//跳转裁剪页面</span></span><br><span class="line">    uCrop.start(activity, requestCode);</span><br><span class="line">    <span class="keyword">return</span> cameraScalePath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-2-其他配置"><a href="#2-4-2-其他配置" class="headerlink" title="2.4.2 其他配置"></a>2.4.2 其他配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置Toolbar标题</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setToolbarTitle</span><span class="params">(<span class="meta">@Nullable</span> String text)</span></span><br><span class="line"><span class="comment">//设置裁剪的图片格式</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setCompressionFormat</span><span class="params">(<span class="meta">@NonNull</span> Bitmap.CompressFormat format)</span></span><br><span class="line"><span class="comment">//设置裁剪的图片质量，取值0-100</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setCompressionQuality</span><span class="params">(<span class="meta">@IntRange(from = 0)</span> <span class="type">int</span> compressQuality)</span></span><br><span class="line"><span class="comment">//设置最多缩放的比例尺</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setMaxScaleMultiplier</span><span class="params">(<span class="meta">@FloatRange(from = 1.0, fromInclusive = false)</span> <span class="type">float</span> maxScaleMultiplier)</span></span><br><span class="line"><span class="comment">//动画时间</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setImageToCropBoundsAnimDuration</span><span class="params">(<span class="meta">@IntRange(from = 100)</span> <span class="type">int</span> durationMillis)</span></span><br><span class="line"><span class="comment">//设置图片压缩最大值</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setMaxBitmapSize</span><span class="params">(<span class="meta">@IntRange(from = 100)</span> <span class="type">int</span> maxBitmapSize)</span></span><br><span class="line"><span class="comment">//是否显示椭圆裁剪框阴影</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setOvalDimmedLayer</span><span class="params">(<span class="type">boolean</span> isOval)</span> </span><br><span class="line"><span class="comment">//设置椭圆裁剪框阴影颜色</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setDimmedLayerColor</span><span class="params">(<span class="meta">@ColorInt</span> <span class="type">int</span> color)</span></span><br><span class="line"><span class="comment">//是否显示裁剪框</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setShowCropFrame</span><span class="params">(<span class="type">boolean</span> show)</span></span><br><span class="line"><span class="comment">//设置裁剪框边的宽度</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setCropFrameStrokeWidth</span><span class="params">(<span class="meta">@IntRange(from = 0)</span> <span class="type">int</span> width)</span></span><br><span class="line"><span class="comment">//是否显示裁剪框网格</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setShowCropGrid</span><span class="params">(<span class="type">boolean</span> show)</span> </span><br><span class="line"><span class="comment">//设置裁剪框网格颜色</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setCropGridColor</span><span class="params">(<span class="meta">@ColorInt</span> <span class="type">int</span> color)</span></span><br><span class="line"><span class="comment">//设置裁剪框网格宽</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setCropGridStrokeWidth</span><span class="params">(<span class="meta">@IntRange(from = 0)</span> <span class="type">int</span> width)</span></span><br></pre></td></tr></table></figure>
<h1 id="3-源码解析"><a href="#3-源码解析" class="headerlink" title="3. 源码解析"></a>3. 源码解析</h1><blockquote>
<p>在我开始说源码之前，我建议大家可以先看下我下面的连接，因为本框架的作者真的是个好人，他不仅为我们贡献了这么好的一个框架，还把自己写这个框架的思路都写了出来，大家可以看看<br><a href="https://yalantis.com/blog/how-we-created-ucrop-our-own-image-cropping-library-for-android/">英文原版</a><br><a href="https://blog.csdn.net/wood_water_peng/article/details/51306274">国内网友翻译版</a><br><a href="https://fanyi.baidu.com/transpage?query=https%3A%2F%2Fyalantis.com%2Fblog%2Fhow-we-created-ucrop-our-own-image-cropping-library-for-android%2F%23&amp;source=url&amp;ie=utf8&amp;from=auto&amp;to=zh&amp;render=1">百度网页翻译机翻版</a><br>其实我个人感觉百度机翻没有谷歌翻译的好，大家有条件的可以使用谷歌翻译浏览器插件翻译整个网页（谷歌翻译好像国内可以直接访问）</p>
</blockquote>
<p>代码结构大致分为三个部分:</p>
<h2 id="3-1-第一部分：UCropActivity（整个框架的外在，用户操作图片的地方）"><a href="#3-1-第一部分：UCropActivity（整个框架的外在，用户操作图片的地方）" class="headerlink" title="3.1 第一部分：UCropActivity（整个框架的外在，用户操作图片的地方）"></a>3.1 第一部分：UCropActivity（整个框架的外在，用户操作图片的地方）</h2><p>他的功能就是项目主要的界面，以及实现一些基本的初始化。你跳转到uCrop看到的那个操作图片的界面就是它。</p>
<p>这块看源码的时候代码居多，但是，说实话，就像刚刚说的一样，他除了初始化还是初始化。初始化完<code>Toolbar</code>接着初始化<code>ViewGroup</code>，初始化完<code>ViewGroup</code>接着初始化<code>Image</code>数据等等。所以这块我就没咋细看<del>（其实是因为代码太长了，逃）</del></p>
<h2 id="3-2-第二部分：OverlayView（绘制裁剪框）"><a href="#3-2-第二部分：OverlayView（绘制裁剪框）" class="headerlink" title="3.2 第二部分：OverlayView（绘制裁剪框）"></a>3.2 第二部分：OverlayView（绘制裁剪框）</h2><p>这一块主要就是来画你所看到的图片中的裁剪的辅助线。</p>
<p>在构造方法里面就调用了一个方法，就是<code>init()</code>，而<code>init()</code>方法也就干了一件事——判断。当系统小于<code>JELLY_BEA_MR2</code>也就是<code>Android4.3</code>时，启动了硬件加速，至于为什么<code>setLayerType(LAYER_TYPE_SOFTWARE, null);</code>这个看着就像启动硬件加速的方法，甚至参数里面还有软件这个单词的方法能启动硬件加速，请大家移步<a href="https://hencoder.com/ui-1-8/">HenCoder Android 自定义 View 1-8 硬件加速</a>（进去直接搜索这个方法即可，就能找到解释的地方），我再次不做解释。</p>
<p>这个类主要有两个方法</p>
<ol>
<li><code>drawDimmedLayer()</code>绘制裁剪框之外的灰色部分</li>
<li><code>drawCropGrid()</code>绘制裁剪框</li>
</ol>
<p>那我们分别来看下这两个方法：</p>
<h3 id="3-2-1-drawDimmedLayer"><a href="#3-2-1-drawDimmedLayer" class="headerlink" title="3.2.1 drawDimmedLayer()"></a>3.2.1 drawDimmedLayer()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">drawDimmedLayer</span><span class="params">(<span class="meta">@NonNull</span> Canvas canvas)</span> &#123;</span><br><span class="line">    <span class="comment">//先保存当前当前画布</span></span><br><span class="line">    canvas.save();</span><br><span class="line">    <span class="comment">//判断是否显示圆框</span></span><br><span class="line">    <span class="keyword">if</span> (mCircleDimmedLayer) &#123;</span><br><span class="line">        <span class="comment">//按Path路径裁剪</span></span><br><span class="line">        canvas.clipPath(mCircularPath, Region.Op.DIFFERENCE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//裁剪矩形</span></span><br><span class="line">        canvas.clipRect(mCropViewRect, Region.Op.DIFFERENCE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//着色</span></span><br><span class="line">    canvas.drawColor(mDimmedColor);</span><br><span class="line">    <span class="comment">//恢复之前保存的Canvas的状态</span></span><br><span class="line">    canvas.restore();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mCircleDimmedLayer) &#123; <span class="comment">// 绘制1px笔划以修复反锯齿</span></span><br><span class="line">        canvas.drawCircle(mCropViewRect.centerX(), mCropViewRect.centerY(),</span><br><span class="line">                Math.min(mCropViewRect.width(), mCropViewRect.height()) / <span class="number">2.f</span>, mDimmedStrokePaint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先就是一个<code>mCircleDimmedLayer</code>，这个我真的很迷，因为我不知道她是咋来的，于是我就看<code>OverlayView</code>有没有对这个变量的赋值，于是整个类我就找到了一个<code>setCircleDimmedLayer()</code>方法，于是我看这个方法是在哪被调用了的，然后我就找到他分别被UCropActivity和UCropFragment两个类调用到，而且一个是<code>intent.getBooleanExtra()</code>方法一个是<code>bundle.getBoolean()</code>方法，看到这个我相信大家都有点数了，这明显就是其他类传过来的啊，我发现他两的key的值都是<code>UCrop.Options.EXTRA_CIRCLE_DIMMED_LAYER</code>，那我就懂了，找整个框架里面哪儿提到过这个值不就得了，于是我就发现除了上面两个方法以及他的初始化以外，我发现了第4个调用的地方，也是唯一一个调用的地方——Ucrop.setCircleDimmedLayer()：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> isCircle - set it to true if you want dimmed layer to have an circle inside</span></span><br><span class="line"><span class="comment"> * iscircle-如果希望暗显层中有一个圆，请将其设置为true。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCircleDimmedLayer</span><span class="params">(<span class="type">boolean</span> isCircle)</span> &#123;</span><br><span class="line">    mOptionBundle.putBoolean(EXTRA_CIRCLE_DIMMED_LAYER, isCircle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注释上面是原话，下面是我百度机翻的翻译。看了就懂了吧，反正我没懂，我也完全没有见到哪调用过这个方法，我更不懂啥叫希望暗显层有个圆，啥玩意？充满线条的黑？？？<br>直到我将UCrop的调用方法修改了并运行之后我才懂了：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">options</span> <span class="operator">=</span> UCrop.Options()</span><br><span class="line">options.setCircleDimmedLayer(<span class="literal">true</span>)</span><br><span class="line">UCrop.of(uri, destinationUri)</span><br><span class="line">        .withOptions(options)</span><br><span class="line">        .start(<span class="built_in">this</span>)</span><br></pre></td></tr></table></figure><br>结果是：<br><img src="https://cdn.littlecorgi.top/mweb/Screenshot_20190802-211515_PhotoXiu_puzzle.jpg" alt="Screenshot_20190802-211515_PhotoXiu_puzzle"></p>
<p>然后就懂了，应该是能截一个圆形的图案吧，然后我点下了✔️，然后……</p>
<p><img src="https://cdn.littlecorgi.top/mweb/Screenshot_20190802-211547_PhotoXiu_puzzle.jpg" alt="Screenshot_20190802-211547_PhotoXiu_puzzle"><br>无话可说，作者牛逼！！！</p>
<p>回去回去，刚刚说到<code>drawDimmedLayer()</code>，可以看到，如果<code>mCircleDimmedLayer</code>为<code>true</code>就调用<code>clipPath()</code>跟着路径裁切一个矩形加原，不然的话就调用<code>clipRect()</code>裁切一个矩形。然后加入颜色，然后完了</p>
<h3 id="3-2-2-drawCropGrid"><a href="#3-2-2-drawCropGrid" class="headerlink" title="3.2.2 drawCropGrid()"></a>3.2.2 drawCropGrid()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">drawCropGrid</span><span class="params">(<span class="meta">@NonNull</span> Canvas canvas)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否显示剪裁框</span></span><br><span class="line">    <span class="keyword">if</span> (mShowCropGrid) &#123;</span><br><span class="line">        <span class="comment">// 判断矩形数据是否为空，mGridPoints 如果等于空的话进入填充数据</span></span><br><span class="line">        <span class="keyword">if</span> (mGridPoints == <span class="literal">null</span> &amp;&amp; !mCropViewRect.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 该数组为 canvas.drawLines 的第一个参数，该参数要求其元素个数为 4 的倍数</span></span><br><span class="line">            mGridPoints = <span class="keyword">new</span> <span class="title class_">float</span>[(mCropGridRowCount) * <span class="number">4</span> + (mCropGridColumnCount) * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 组装数据，数据为每一组线段的坐标点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mCropGridRowCount; i++) &#123;</span><br><span class="line">                mGridPoints[index++] = mCropViewRect.left;</span><br><span class="line">                mGridPoints[index++] = (mCropViewRect.height() * (((<span class="type">float</span>) i + <span class="number">1.0f</span>) / (<span class="type">float</span>) (mCropGridRowCount + <span class="number">1</span>))) + mCropViewRect.top;</span><br><span class="line">                mGridPoints[index++] = mCropViewRect.right;</span><br><span class="line">                mGridPoints[index++] = (mCropViewRect.height() * (((<span class="type">float</span>) i + <span class="number">1.0f</span>) / (<span class="type">float</span>) (mCropGridRowCount + <span class="number">1</span>))) + mCropViewRect.top;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mCropGridColumnCount; i++) &#123;</span><br><span class="line">                mGridPoints[index++] = (mCropViewRect.width() * (((<span class="type">float</span>) i + <span class="number">1.0f</span>) / (<span class="type">float</span>) (mCropGridColumnCount + <span class="number">1</span>))) + mCropViewRect.left;</span><br><span class="line">                mGridPoints[index++] = mCropViewRect.top;</span><br><span class="line">                mGridPoints[index++] = (mCropViewRect.width() * (((<span class="type">float</span>) i + <span class="number">1.0f</span>) / (<span class="type">float</span>) (mCropGridColumnCount + <span class="number">1</span>))) + mCropViewRect.left;</span><br><span class="line">                mGridPoints[index++] = mCropViewRect.bottom;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//绘制线段</span></span><br><span class="line">        <span class="keyword">if</span> (mGridPoints != <span class="literal">null</span>) &#123;</span><br><span class="line">            canvas.drawLines(mGridPoints, mCropGridPaint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绘制矩形包裹线段</span></span><br><span class="line">    <span class="keyword">if</span> (mShowCropFrame) &#123;</span><br><span class="line">        canvas.drawRect(mCropViewRect, mCropFramePaint);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绘制边角包裹,mFreestyleCropMode此参数如果等于1的话 剪裁框为可移动状态，一般不用</span></span><br><span class="line">    <span class="keyword">if</span> (mFreestyleCropMode != FREESTYLE_CROP_MODE_DISABLE) &#123;</span><br><span class="line">        canvas.save();</span><br><span class="line"></span><br><span class="line">        mTempRect.set(mCropViewRect);</span><br><span class="line">        mTempRect.inset(mCropRectCornerTouchAreaLineLength, -mCropRectCornerTouchAreaLineLength);</span><br><span class="line">        canvas.clipRect(mTempRect, Region.Op.DIFFERENCE);</span><br><span class="line"></span><br><span class="line">        mTempRect.set(mCropViewRect);</span><br><span class="line">        mTempRect.inset(-mCropRectCornerTouchAreaLineLength, mCropRectCornerTouchAreaLineLength);</span><br><span class="line">        canvas.clipRect(mTempRect, Region.Op.DIFFERENCE);</span><br><span class="line"></span><br><span class="line">        canvas.drawRect(mCropViewRect, mCropFrameCornersPaint);</span><br><span class="line"></span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开头又是一个和上面类似的变量<code>mShowCropGrid</code>，这下我就不说我找的具体步骤，他的功能就是如果他是<code>true</code>就会在裁剪框中显示9宫格线，为<code>false</code>就没有。接着就是画线部分，我觉得这个我不用讲啥，也没啥讲的，唯一就是为什么mGridPoints这个数组的大小是4的倍数，大家可以看下这个博客<a href="https://blog.csdn.net/pimkle/article/details/16946423">Android Canvas DrawLines中第一个参数的解释</a></p>
<h2 id="3-3-第三部分：GestureCropImageView（正在框架的内在，代码操作操作图片的地方）"><a href="#3-3-第三部分：GestureCropImageView（正在框架的内在，代码操作操作图片的地方）" class="headerlink" title="3.3 第三部分：GestureCropImageView（正在框架的内在，代码操作操作图片的地方）"></a>3.3 第三部分：GestureCropImageView（正在框架的内在，代码操作操作图片的地方）</h2><p>这个是整个项目最核心的地方。前面的两部分都是UI的，而这个才是真正的对图片进行处理的部分，也是我最想知道了解的部分。<br>这部分作者也在他的博客里面说的最多最清楚。<br>作者把这部分的逻辑分为了三个部分</p>
<ol>
<li><p><code>TransformImageView extends ImageView</code><br> 他处理了</p>
<ol>
<li>从源拿到图片</li>
<li>将图片进变换（平移、缩放、旋转），并应用到当前图片上</li>
</ol>
</li>
<li><p><code>CropImageView extends TransformImageView</code><br> 他处理了</p>
<ol>
<li>绘制裁剪边框和网格</li>
<li>为裁剪区域设置一张图片（如果用户对图片操作导致裁剪区域出现了空白，那么图片应自动移动到边界填充空白区域）</li>
<li>继承父类方法，使用更精准的规则来操作矩阵（限制最大和最小缩放比）</li>
<li>添加方法和缩小的方法</li>
<li>裁剪图片</li>
</ol>
</li>
<li><code>GestureCropImageView extends CropImageView</code><br> 他处理了<ol>
<li>监听用户手势，并调用对应的正确的方法</li>
</ol>
</li>
</ol>
<h3 id="3-3-1-TransformImageView"><a href="#3-3-1-TransformImageView" class="headerlink" title="3.3.1 TransformImageView"></a>3.3.1 TransformImageView</h3><p>作者说这是最容易的部分。<br>在看这个类之前我们先来看看<code>BitmapLoadTask</code>类，这个类是一切图像处理的基础，这个类负责了<code>Uri</code>解码<code>bitmap</code>，并处理分辨率：<br>首先根据拿到的<code>Uri</code>解析位图：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ParcelFileDescriptor parcelFileDescriptor;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    parcelFileDescriptor = mContext.getContentResolver().openFileDescriptor(mInputUri, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BitmapWorkerResult</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> FileDescriptor fileDescriptor;</span><br><span class="line"><span class="keyword">if</span> (parcelFileDescriptor != <span class="literal">null</span>) &#123;</span><br><span class="line">    fileDescriptor = parcelFileDescriptor.getFileDescriptor();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BitmapWorkerResult</span>(<span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;ParcelFileDescriptor was null for given Uri: [&quot;</span> + mInputUri + <span class="string">&quot;]&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现在，可以使用<code>BitmapFactory</code>方法解码<code>FileDescriptor</code>。</p>
<p>但在解码位图之前，有必要知道它的大小，因为如果分辨率太高，位图将被二次采样。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> BitmapFactory.<span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitmapFactory</span>.Options();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">options.inJustDecodeBounds = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">BitmapFactory.decodeFileDescriptor(fileDescriptor, <span class="literal">null</span>, options);</span><br><span class="line"></span><br><span class="line">options.inSampleSize = calculateInSampleSize(options, requiredWidth, requiredHeight);</span><br><span class="line"></span><br><span class="line">options.inJustDecodeBounds = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Bitmap</span> <span class="variable">decodeSampledBitmap</span> <span class="operator">=</span> BitmapFactory.decodeFileDescriptor(fileDescriptor, <span class="literal">null</span>, options);</span><br><span class="line"></span><br><span class="line">close(parcelFileDescriptor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ExifInterface</span> <span class="variable">exif</span> <span class="operator">=</span> getExif(uri);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (exif != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">exifOrientation</span> <span class="operator">=</span> exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> rotateBitmap(decodeSampledBitmap, exifToDegrees(exifOrientation));</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> decodeSampledBitmap;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样就拿到了<code>bitmap</code>实例了，就可以去<code>TansformImageView</code>去对图片进行调整了。<br>其实这个类我也不知道说啥😂，我觉得这个类也就是把<code>Matrix</code>的<code>postTranslate()</code>、<code>postRotate()</code>和<code>postScale()</code>方法给封装了下。<br>关于Matrix的知识大家可以参考这篇博客：<a href="https://www.gcssloop.com/customview/Matrix_Basic">安卓自定义View进阶-Matrix原理</a></p>
<h3 id="3-3-2-CropImageView"><a href="#3-3-2-CropImageView" class="headerlink" title="3.3.2 CropImageView"></a>3.3.2 CropImageView</h3><p>这一层是最复杂的一层，作者的操作大致可以分为3步：图片裁剪框偏移计算、图片归为动画处理、裁剪图片</p>
<ul>
<li>第一步：图片裁剪框偏移计算<br>当用户手指移开时，要确保图片处于裁剪区域中，如果不处于，需要通过平移把它移过来：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setImageToWrapCropBounds</span><span class="params">(<span class="type">boolean</span> animate)</span> &#123;</span><br><span class="line">    <span class="comment">//如果图片加载完毕并且图片不处于剪裁区域</span></span><br><span class="line">    <span class="keyword">if</span> (mBitmapLaidOut &amp;&amp; !isImageWrapCropBounds()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取中心点X,Y坐标</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">currentX</span> <span class="operator">=</span> mCurrentImageCenter[<span class="number">0</span>];</span><br><span class="line">        <span class="type">float</span> <span class="variable">currentY</span> <span class="operator">=</span> mCurrentImageCenter[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//获取缩放比例</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">currentScale</span> <span class="operator">=</span> getCurrentScale();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取偏移距离</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">deltaX</span> <span class="operator">=</span> mCropRect.centerX() - currentX;</span><br><span class="line">        <span class="type">float</span> <span class="variable">deltaY</span> <span class="operator">=</span> mCropRect.centerY() - currentY;</span><br><span class="line">        <span class="type">float</span> <span class="variable">deltaScale</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        mTempMatrix.reset();</span><br><span class="line">        mTempMatrix.setTranslate(deltaX, deltaY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span>[] tempCurrentImageCorners = Arrays.copyOf(mCurrentImageCorners, mCurrentImageCorners.length);</span><br><span class="line">        mTempMatrix.mapPoints(tempCurrentImageCorners);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断图片是否包含在剪裁区域</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">willImageWrapCropBoundsAfterTranslate</span> <span class="operator">=</span> isImageWrapCropBounds(tempCurrentImageCorners);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果包含在剪裁区域</span></span><br><span class="line">        <span class="keyword">if</span> (willImageWrapCropBoundsAfterTranslate) &#123;</span><br><span class="line">            <span class="comment">//获取偏移的距离</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">float</span>[] imageIndents = calculateImageIndents();</span><br><span class="line">            <span class="comment">//偏移的距离，横坐标加横坐标 纵坐标加纵坐标</span></span><br><span class="line">            deltaX = -(imageIndents[<span class="number">0</span>] + imageIndents[<span class="number">2</span>]);</span><br><span class="line">            deltaY = -(imageIndents[<span class="number">1</span>] + imageIndents[<span class="number">3</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果不包含在剪裁区域，创建临时矩形</span></span><br><span class="line">            <span class="type">RectF</span> <span class="variable">tempCropRect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RectF</span>(mCropRect);</span><br><span class="line">            mTempMatrix.reset();</span><br><span class="line">            <span class="comment">//设置偏移角度</span></span><br><span class="line">            mTempMatrix.setRotate(getCurrentAngle());</span><br><span class="line">            mTempMatrix.mapRect(tempCropRect);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获得矩形的边长坐标</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">float</span>[] currentImageSides = RectUtils.getRectSidesFromCorners(mCurrentImageCorners);</span><br><span class="line">            <span class="comment">//获取放大比例</span></span><br><span class="line">            deltaScale = Math.max(tempCropRect.width() / currentImageSides[<span class="number">0</span>],</span><br><span class="line">                    tempCropRect.height() / currentImageSides[<span class="number">1</span>]);</span><br><span class="line">            deltaScale = deltaScale * currentScale - currentScale;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果需要动画</span></span><br><span class="line">        <span class="keyword">if</span> (animate) &#123;</span><br><span class="line">            post(mWrapCropBoundsRunnable = <span class="keyword">new</span> <span class="title class_">WrapCropBoundsRunnable</span>(</span><br><span class="line">                    CropImageView.<span class="built_in">this</span>, mImageToWrapCropBoundsAnimDuration, currentX, currentY, deltaX, deltaY,</span><br><span class="line">                    currentScale, deltaScale, willImageWrapCropBoundsAfterTranslate));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不需要动画，直接移动到目标位置</span></span><br><span class="line">            postTranslate(deltaX, deltaY);</span><br><span class="line">            <span class="keyword">if</span> (!willImageWrapCropBoundsAfterTranslate) &#123;</span><br><span class="line">                zoomInImage(currentScale + deltaScale, mCropRect.centerX(), mCropRect.centerY());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二步：处理平移<br>通过一个Runnable线程来处理平移，并且通过时间差值的计算来移动动画，使动画看起来更真实：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此可运行文件用于动画图像，使其完全填充裁剪边界。</span></span><br><span class="line"><span class="comment"> * 给定值在动画期间内插。</span></span><br><span class="line"><span class="comment"> * runnable可以终止于vie&#123;<span class="doctag">@link</span> #cancelAllAnimations()&#125;方法，</span></span><br><span class="line"><span class="comment"> * 也可以在触发&#123;<span class="doctag">@link</span> WrapCropBoundsRunnable#run()&#125;方法内的某些条件时终止。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WrapCropBoundsRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;CropImageView&gt; mCropImageView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> mDurationMs, mStartTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> mOldX, mOldY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> mCenterDiffX, mCenterDiffY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> mOldScale;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> mDeltaScale;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> mWillBeImageInBoundsAfterTranslate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WrapCropBoundsRunnable</span><span class="params">(CropImageView cropImageView,</span></span><br><span class="line"><span class="params">                                <span class="type">long</span> durationMs,</span></span><br><span class="line"><span class="params">                                <span class="type">float</span> oldX, <span class="type">float</span> oldY,</span></span><br><span class="line"><span class="params">                                <span class="type">float</span> centerDiffX, <span class="type">float</span> centerDiffY,</span></span><br><span class="line"><span class="params">                                <span class="type">float</span> oldScale, <span class="type">float</span> deltaScale,</span></span><br><span class="line"><span class="params">                                <span class="type">boolean</span> willBeImageInBoundsAfterTranslate)</span> &#123;</span><br><span class="line"></span><br><span class="line">        mCropImageView = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(cropImageView);</span><br><span class="line"></span><br><span class="line">        mDurationMs = durationMs;</span><br><span class="line">        mStartTime = System.currentTimeMillis();</span><br><span class="line">        mOldX = oldX;</span><br><span class="line">        mOldY = oldY;</span><br><span class="line">        mCenterDiffX = centerDiffX;</span><br><span class="line">        mCenterDiffY = centerDiffY;</span><br><span class="line">        mOldScale = oldScale;</span><br><span class="line">        mDeltaScale = deltaScale;</span><br><span class="line">        mWillBeImageInBoundsAfterTranslate = willBeImageInBoundsAfterTranslate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CropImageView</span> <span class="variable">cropImageView</span> <span class="operator">=</span> mCropImageView.get();</span><br><span class="line">        <span class="keyword">if</span> (cropImageView == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">float</span> <span class="variable">currentMs</span> <span class="operator">=</span> Math.min(mDurationMs, now - mStartTime);</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> <span class="variable">newX</span> <span class="operator">=</span> CubicEasing.easeOut(currentMs, <span class="number">0</span>, mCenterDiffX, mDurationMs);</span><br><span class="line">        <span class="type">float</span> <span class="variable">newY</span> <span class="operator">=</span> CubicEasing.easeOut(currentMs, <span class="number">0</span>, mCenterDiffY, mDurationMs);</span><br><span class="line">        <span class="type">float</span> <span class="variable">newScale</span> <span class="operator">=</span> CubicEasing.easeInOut(currentMs, <span class="number">0</span>, mDeltaScale, mDurationMs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentMs &lt; mDurationMs) &#123;</span><br><span class="line">            cropImageView.postTranslate(newX - (cropImageView.mCurrentImageCenter[<span class="number">0</span>] - mOldX), newY - (cropImageView.mCurrentImageCenter[<span class="number">1</span>] - mOldY));</span><br><span class="line">            <span class="keyword">if</span> (!mWillBeImageInBoundsAfterTranslate) &#123;</span><br><span class="line">                cropImageView.zoomInImage(mOldScale + newScale, cropImageView.mCropRect.centerX(), cropImageView.mCropRect.centerY());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!cropImageView.isImageWrapCropBounds()) &#123;</span><br><span class="line">                cropImageView.post(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面还有另一个线程，用于双击放大:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此可运行项用于设置图像缩放的动画。</span></span><br><span class="line"><span class="comment"> * 给定值在动画期间内插。</span></span><br><span class="line"><span class="comment"> * runnable可以终止vie &#123;<span class="doctag">@link</span> #cancelAllAnimations()&#125;方法，</span></span><br><span class="line"><span class="comment"> * 也可以在触发&#123;<span class="doctag">@link</span> ZoomImageToPosition#run()&#125;方法内的某些条件时终止。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ZoomImageToPosition</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;CropImageView&gt; mCropImageView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> mDurationMs, mStartTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> mOldScale;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> mDeltaScale;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> mDestX;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> mDestY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZoomImageToPosition</span><span class="params">(CropImageView cropImageView,</span></span><br><span class="line"><span class="params">                                <span class="type">long</span> durationMs,</span></span><br><span class="line"><span class="params">                                <span class="type">float</span> oldScale, <span class="type">float</span> deltaScale,</span></span><br><span class="line"><span class="params">                                <span class="type">float</span> destX, <span class="type">float</span> destY)</span> &#123;</span><br><span class="line"></span><br><span class="line">        mCropImageView = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(cropImageView);</span><br><span class="line"></span><br><span class="line">        mStartTime = System.currentTimeMillis();</span><br><span class="line">        mDurationMs = durationMs;</span><br><span class="line">        mOldScale = oldScale;</span><br><span class="line">        mDeltaScale = deltaScale;</span><br><span class="line">        mDestX = destX;</span><br><span class="line">        mDestY = destY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CropImageView</span> <span class="variable">cropImageView</span> <span class="operator">=</span> mCropImageView.get();</span><br><span class="line">        <span class="keyword">if</span> (cropImageView == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">float</span> <span class="variable">currentMs</span> <span class="operator">=</span> Math.min(mDurationMs, now - mStartTime);</span><br><span class="line">        <span class="type">float</span> <span class="variable">newScale</span> <span class="operator">=</span> CubicEasing.easeInOut(currentMs, <span class="number">0</span>, mDeltaScale, mDurationMs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentMs &lt; mDurationMs) &#123;</span><br><span class="line">            cropImageView.zoomInImage(mOldScale + newScale, mDestX, mDestY);</span><br><span class="line">            cropImageView.post(<span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cropImageView.setImageToWrapCropBounds();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第三步：裁剪图片</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消所有当前动画并设置图像以填充裁剪区域（不带动画）。</span></span><br><span class="line"><span class="comment"> * 然后用适当的参数创建并执行&#123;<span class="doctag">@link</span> BitmapCropTask&#125;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cropAndSaveImage</span><span class="params">(<span class="meta">@NonNull</span> Bitmap.CompressFormat compressFormat, <span class="type">int</span> compressQuality,</span></span><br><span class="line"><span class="params">                            <span class="meta">@Nullable</span> BitmapCropCallback cropCallback)</span> &#123;</span><br><span class="line">    <span class="comment">//结束子线程</span></span><br><span class="line">    cancelAllAnimations();</span><br><span class="line">    <span class="comment">//设置要剪裁的图片，不需要位移动画</span></span><br><span class="line">    setImageToWrapCropBounds(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储图片信息，四个参数分别为：mCropRect要剪裁的图片矩阵，当前图片要剪裁的矩阵，当前放大的值，当前旋转的角度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ImageState</span> <span class="variable">imageState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageState</span>(</span><br><span class="line">            mCropRect, RectUtils.trapToRect(mCurrentImageCorners),</span><br><span class="line">            getCurrentScale(), getCurrentAngle());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//剪裁参数，mMaxResultImageSizeX，mMaxResultImageSizeY：剪裁图片的最大宽度、高度。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">CropParameters</span> <span class="variable">cropParameters</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CropParameters</span>(</span><br><span class="line">            mMaxResultImageSizeX, mMaxResultImageSizeY,</span><br><span class="line">            compressFormat, compressQuality,</span><br><span class="line">            getImageInputPath(), getImageOutputPath(), getExifInfo());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//剪裁操作放到AsyncTask中执行</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BitmapCropTask</span>(getViewBitmap(), imageState, cropParameters, cropCallback).execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这块核心方法还是在<code>BitmapCropTask</code>中：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调整剪裁大小，如果有设置最大剪裁大小也会在这里做调整到设置范围</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">float</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> BitmapFactory.<span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitmapFactory</span>.Options();</span><br><span class="line">    options.inJustDecodeBounds = <span class="literal">true</span>;</span><br><span class="line">    BitmapFactory.decodeFile(mImageInputPath, options);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">swapSides</span> <span class="operator">=</span> mExifInfo.getExifDegrees() == <span class="number">90</span> || mExifInfo.getExifDegrees() == <span class="number">270</span>;</span><br><span class="line">    <span class="type">float</span> <span class="variable">scaleX</span> <span class="operator">=</span> (swapSides ? options.outHeight : options.outWidth) / (<span class="type">float</span>) mViewBitmap.getWidth();</span><br><span class="line">    <span class="type">float</span> <span class="variable">scaleY</span> <span class="operator">=</span> (swapSides ? options.outWidth : options.outHeight) / (<span class="type">float</span>) mViewBitmap.getHeight();</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="variable">resizeScale</span> <span class="operator">=</span> Math.min(scaleX, scaleY);</span><br><span class="line"></span><br><span class="line">    mCurrentScale /= resizeScale;</span><br><span class="line"></span><br><span class="line">    resizeScale = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mMaxResultImageSizeX &gt; <span class="number">0</span> &amp;&amp; mMaxResultImageSizeY &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">cropWidth</span> <span class="operator">=</span> mCropRect.width() / mCurrentScale;</span><br><span class="line">        <span class="type">float</span> <span class="variable">cropHeight</span> <span class="operator">=</span> mCropRect.height() / mCurrentScale;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cropWidth &gt; mMaxResultImageSizeX || cropHeight &gt; mMaxResultImageSizeY) &#123;</span><br><span class="line"></span><br><span class="line">            scaleX = mMaxResultImageSizeX / cropWidth;</span><br><span class="line">            scaleY = mMaxResultImageSizeY / cropHeight;</span><br><span class="line">            resizeScale = Math.min(scaleX, scaleY);</span><br><span class="line"></span><br><span class="line">            mCurrentScale /= resizeScale;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resizeScale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剪裁图片</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">crop</span><span class="params">(<span class="type">float</span> resizeScale)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ExifInterface</span> <span class="variable">originalExif</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExifInterface</span>(mImageInputPath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//四舍五入取整</span></span><br><span class="line">    cropOffsetX = Math.round((mCropRect.left - mCurrentImageRect.left) / mCurrentScale);</span><br><span class="line">    cropOffsetY = Math.round((mCropRect.top - mCurrentImageRect.top) / mCurrentScale);</span><br><span class="line">    mCroppedImageWidth = Math.round(mCropRect.width() / mCurrentScale);</span><br><span class="line">    mCroppedImageHeight = Math.round(mCropRect.height() / mCurrentScale);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算出图片是否需要被剪裁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">shouldCrop</span> <span class="operator">=</span> shouldCrop(mCroppedImageWidth, mCroppedImageHeight);</span><br><span class="line">    Log.i(TAG, <span class="string">&quot;Should crop: &quot;</span> + shouldCrop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldCrop) &#123;</span><br><span class="line">        <span class="comment">//调用C++方法剪裁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">cropped</span> <span class="operator">=</span> cropCImg(mImageInputPath, mImageOutputPath,</span><br><span class="line">                cropOffsetX, cropOffsetY, mCroppedImageWidth, mCroppedImageHeight,</span><br><span class="line">                mCurrentAngle, resizeScale, mCompressFormat.ordinal(), mCompressQuality,</span><br><span class="line">                mExifInfo.getExifDegrees(), mExifInfo.getExifTranslation());</span><br><span class="line">        <span class="comment">//剪裁成功复制图片EXIF信息</span></span><br><span class="line">        <span class="keyword">if</span> (cropped &amp;&amp; mCompressFormat.equals(Bitmap.CompressFormat.JPEG)) &#123;</span><br><span class="line">            ImageHeaderParser.copyExif(originalExif, mCroppedImageWidth, mCroppedImageHeight, mImageOutputPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cropped;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//直接复制图片到目标文件夹</span></span><br><span class="line">        FileUtils.copyFile(mImageInputPath, mImageOutputPath);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-3-3-GestureCropImageView"><a href="#3-3-3-GestureCropImageView" class="headerlink" title="3.3.3 GestureCropImageView"></a>3.3.3 GestureCropImageView</h3><p>这个类主要就是对手势的监听，所以我们简单粗暴，直接找他的onTouchEvent方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果是ACTION_DOWN event，用户触摸屏幕，必须取消所有当前动画。</span></span><br><span class="line"><span class="comment"> * 如果是ACTION_UP event，用户从屏幕上取下所有手指，必须纠正当前图像位置。</span></span><br><span class="line"><span class="comment"> * 如果有两个以上的手指-更新焦点坐标。</span></span><br><span class="line"><span class="comment"> * 如果已启用，则将事件传递给手势检测器。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((event.getAction() &amp; MotionEvent.ACTION_MASK) == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        cancelAllAnimations();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event.getPointerCount() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        mMidPntX = (event.getX(<span class="number">0</span>) + event.getX(<span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">        mMidPntY = (event.getY(<span class="number">0</span>) + event.getY(<span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双击监听和拖动监听</span></span><br><span class="line">    mGestureDetector.onTouchEvent(event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两指缩放监听</span></span><br><span class="line">    <span class="keyword">if</span> (mIsScaleEnabled) &#123;</span><br><span class="line">        mScaleDetector.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//旋转监听</span></span><br><span class="line">    <span class="keyword">if</span> (mIsRotateEnabled) &#123;</span><br><span class="line">        mRotateDetector.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((event.getAction() &amp; MotionEvent.ACTION_MASK) == MotionEvent.ACTION_UP) &#123;</span><br><span class="line">        <span class="comment">//最后一指抬起时判断图片是否填充剪裁框</span></span><br><span class="line">        setImageToWrapCropBounds();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码</tag>
        <tag>uCrop</tag>
        <tag>图片处理</tag>
      </tags>
  </entry>
  <entry>
    <title>招商永隆办卡攻略</title>
    <url>/posts/5a1fdd14.html</url>
    <content><![CDATA[<h1 id="去香港准备工作"><a href="#去香港准备工作" class="headerlink" title="去香港准备工作"></a>去香港准备工作</h1><ul>
<li>📱开通漫游包，运营商APP 或者支付宝上购买即可；</li>
<li>🚇地铁：支付宝（切换到香港）、微信（搭车码 小程序）均可，但是得找紫色的闸机（每个入口都会有 2-3 台），不是紫色的不能刷二维码；</li>
<li>💳八达通：可根据情况在 711 或者地铁站买一张，不仅可以刷地铁、巴士，很多店都支持八达通刷卡支付；</li>
<li>📱APP：<ul>
<li>地图软件：高德和 GoogleMap。记得提前下载离线地图，节省流量；</li>
<li>ZA Bank：香港的一家虚拟银行，可以到香港后，直接通过 APP 开户，门槛低，基本上都能成功。开户后可以申请实体卡，免费邮寄到大陆你的通信地址。（23 年 6 月 1 号后非香港地址需要收 25HKD 邮寄费）</li>
</ul>
</li>
</ul>
<h1 id="准备材料"><a href="#准备材料" class="headerlink" title="准备材料"></a>准备材料</h1><ul>
<li>🪪身份证</li>
<li>🪪港澳通行证</li>
<li>🧾过关小白条</li>
<li>🧾地址证明（银行卡是快递寄过来的，如果邮寄地址和身份证地址不一致，则需要地址证明）<ul>
<li>地址不能是公司地址，不能包含 xx 店等特殊字样。我有朋友因为租的公寓，地址包含了（二店）这样的字样，当场被拒；</li>
<li>可以使用印有你名字和地址的水电燃气缴费单；</li>
<li>或者使用印有名字和地址的近 3 个月任意一月的信用卡账单，比如招行。去银行柜台申请即可，或者 APP 申请了自己打印（APP 上申请的盖章会包含「电子」两个字，有个柜员可能会介意这个然后拒绝）；</li>
</ul>
</li>
<li>💰建议准备 1w HKD 现金，永隆需要保持账户里面有 1w HKD，这样可以不收账户管理费。可以在去 HK 前提前预约银行网点兑换成港币，银行柜台会按实时汇率帮你兑；</li>
<li>📱招商永隆一点通 APP</li>
</ul>
<h1 id="APP-上申请"><a href="#APP-上申请" class="headerlink" title="APP 上申请"></a>APP 上申请</h1><p>打开 APP，首页左上角更多按钮 - 账户 - 我要开户。</p>
<p>开户页面选择「全新用户网点开户」，根据实际情况填写就行。</p>
<p><img src="https://cos.littlecorgi.top/picgo/2023-05-26-APP%E9%A6%96%E9%A1%B5.png" alt=""><br><img src="https://cos.littlecorgi.top/picgo/2023-05-26-APP%E6%9B%B4%E5%A4%9A%E9%A1%B5.png" alt=""></p>
<h1 id="网点情况"><a href="#网点情况" class="headerlink" title="网点情况"></a>网点情况</h1><ul>
<li>营业时间：工作日 9:00-17:00，周六9:00-13:00，周日休息。</li>
<li>任意网点均可，不过去了后最好先问下还有开卡名额不，没有的话立马去下一个。</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>香港</tag>
        <tag>银行</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统2--进程的描述和控制</title>
    <url>/posts/2e847144.html</url>
    <content><![CDATA[<blockquote>
<p>大家可以看下我使用幕布软件画的<a href="https://mubu.com/doc/3Pf0zwzrgw">思维导图</a>，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员<a href="https://mubu.com/inv/477598">https://mubu.com/inv/477598</a></p>
</blockquote>
<span id="more"></span>
<p>[TOC]</p>
<h1 id="2-1-进程的描述"><a href="#2-1-进程的描述" class="headerlink" title="2.1 进程的描述"></a>2.1 进程的描述</h1><h2 id="2-1-1-进程的定义和特征"><a href="#2-1-1-进程的定义和特征" class="headerlink" title="2.1.1 进程的定义和特征"></a>2.1.1 进程的定义和特征</h2><h3 id="2-1-1-1-进程的定义"><a href="#2-1-1-1-进程的定义" class="headerlink" title="2.1.1.1 进程的定义"></a>2.1.1.1 进程的定义</h3><p>为了能够使程序并发执行，并且可以对并发执行的程序加以描述和控制，人们引入了“进程”的概念。<br>为了使参与并发执行的每个程序都能独立地运行，操作系统必须为之配置一个专门的数据结构，称为<strong>进程数据块（PCB）</strong>。他用来纪录进程的各种属性，描述进程的动态变化过程。主要包含有进程的描述信息（进程标识符，进程名，用户标识符，进程组关系等）、进程控制信息（当前状态，优先级，代码执行入口地址，保存的磁盘地址等等）、所拥有的资源和使用情况（虚拟地址空间的状态，文件打开列表等）和CPU现场信息等内容。PCB是系统感知进程存在的唯一标志。<br>所以一般情况下，我们把进程实体就简称为进程，创建进程，实质上是创建进程实体中的PCB；撤销进程，实质上是撤销进程的PCB。<br>对于进程的定义，比较典型的有：</p>
<ol>
<li>进程是程序的一次执行</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li>
<li>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li>
</ol>
<h3 id="2-1-1-2-进程的特征"><a href="#2-1-1-2-进程的特征" class="headerlink" title="2.1.1.2 进程的特征"></a>2.1.1.2 进程的特征</h3><ol>
<li>结构性<br>进程实体是由程序段、数据段及进程控制快三部分组成。</li>
<li>动态性<br>进程的实质是进程实体的执行过程，而且进程“由创建而产生，由调度而执行，由撤销而消亡”。</li>
<li>并发性<br>多个进程实体同存于内存中，且能在一段时间内同时运行。</li>
<li>独立性<br>进程实体是一个能独立运行、独立获得资源和独立接收调度的基本单位。</li>
<li>异步性<br>进程是按异步方式运行的。</li>
</ol>
<h2 id="2-1-2-进程的基本状态及转换"><a href="#2-1-2-进程的基本状态及转换" class="headerlink" title="2.1.2 进程的基本状态及转换"></a>2.1.2 进程的基本状态及转换</h2><h3 id="2-1-2-1-进程的三种基本状态"><a href="#2-1-2-1-进程的三种基本状态" class="headerlink" title="2.1.2.1 进程的三种基本状态"></a>2.1.2.1 进程的三种基本状态</h3><p>进程主要分为三种基本状态：</p>
<ol>
<li>运行态<br>指进程已经获得了CPU，他正在CPU上执行。</li>
<li>就绪态<br>指进程已经准备就绪，准备好了被CPU执行的状态。如果系统中有很多处于就绪态的进程，通常把他们按一定的策略排成一个队列，这个队列称为就绪队列。</li>
<li>等待态<br>指正在运行的进程由于发生某事件（如I/O请求、申请缓冲区失败等问题）暂时无法继续执行时的状态。此时引起进程调度，OS把处理机分配给就绪中的进程，让受阻的进程处于阻塞状态。</li>
</ol>
<h3 id="2-1-2-2-三种状态的转换"><a href="#2-1-2-2-三种状态的转换" class="headerlink" title="2.1.2.2 三种状态的转换"></a>2.1.2.2 三种状态的转换</h3><p><img src="https://cdn.littlecorgi.top/mweb/2019-07-20/UntitledDiagram.jpg" alt="三种状态的转换"></p>
<h3 id="2-1-2-3-创建状态和终止状态"><a href="#2-1-2-3-创建状态和终止状态" class="headerlink" title="2.1.2.3 创建状态和终止状态"></a>2.1.2.3 创建状态和终止状态</h3><p>为了满足进程控制块对数据及操作的完整性要求以及增强管理的灵活性，通常在系统中又为进程引入了两种常见的状态：创建状态和终止状态。<br><img src="https://cdn.littlecorgi.top/mweb/2019-07-20/wuzhongzhuangtaizhuanhuan.png" alt="五种状态转换"></p>
<h2 id="2-1-3-进程管理中的数据结构"><a href="#2-1-3-进程管理中的数据结构" class="headerlink" title="2.1.3 进程管理中的数据结构"></a>2.1.3 进程管理中的数据结构</h2><p>在最开始我已经经提到了进程控制块PCB这个东西，现在我们就进一步来了解他。</p>
<h3 id="2-1-3-1-进程控制块中的作用"><a href="#2-1-3-1-进程控制块中的作用" class="headerlink" title="2.1.3.1 进程控制块中的作用"></a>2.1.3.1 进程控制块中的作用</h3><p>PCB的作用主要就是使一个在多道程序环境下不能独立运行的程序称为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。</p>
<ol>
<li>作为独立运行基本单位的标志。<br> 当一个程序配置了PCB之后，就表示他已是一个能在多道程序环境下独立运行的、合法的基本单位，也就具有取得OS服务的权利。当系统创建一个新的进程的时候，就为他创建了一个PCB，进程结束后收回PCB。</li>
<li>能实现间断性运行方式。<br> 在多道程序运行环境下，由于存在时间片或者有等待I/O请求的情况，所以进程一般都是出于走走停停的状态，当一个进程被阻塞的时候，他应该有一种能保存当前运行状态的能力也就是保护现场机制，方便在此被调度执行时恢复阻塞前的状态。所以就需要在PCB里面提供一个数据结构来保存该进程被中断时的一些信息。</li>
<li>提供进程管理所需要的信息。<br> 这个就不用多说吧。</li>
<li>提供进程调度所需要的信息。<br> 只有处于就绪状态的进程才能被调度执行，而在PCB中就提供了进程处于何种状态的信息。</li>
<li>实现与其它进程的同步与通信。</li>
</ol>
<h3 id="2-1-3-2-进程控制块中的信息"><a href="#2-1-3-2-进程控制块中的信息" class="headerlink" title="2.1.3.2 进程控制块中的信息"></a>2.1.3.2 进程控制块中的信息</h3><p>根据上面进程控制块作用的描述，对应的进程控制块中就需要包含以下信息。</p>
<ol>
<li>进程标识符<br> 进程标识符用于唯一地标识一个进程。一个进程通常具有两种标识符：<ol>
<li>外部标识符<br> 为了方便用户（进程）对进程的访问，进程需要提供一个用于用户（进程）访问的标识符。</li>
<li>内部标识符<br> 为了方便系统对进程的使用，在OS中又为进程设置了内部标识符。通常是一个进程的序号。</li>
</ol>
</li>
<li>处理机状态<br> 处理机状态信息也称为处理机的上下文，主要是由处理机的各种寄存器中的内容组成的。这些寄存器信息包括通用寄存器、指令寄存器、程序状态字PSW和用户栈指针。</li>
<li>进程调度信息<br> 在OS进行调度的时候，必须了解进程的状态及有关进程调度的信息，这些信息包括：进程状态、进程优先级、进程调度所需其他信息（与所采用的的调度算法有关）和事件（阻塞原因）。</li>
<li>进程控制信息<br> 用于进程控制所必须的信息，包括：程序和数据的地址、进程同步和通信机制、资源清单和链接指针。</li>
</ol>
<h3 id="2-1-3-3-进程控制块的组织方式"><a href="#2-1-3-3-进程控制块的组织方式" class="headerlink" title="2.1.3.3 进程控制块的组织方式"></a>2.1.3.3 进程控制块的组织方式</h3><p>一个系统中有很多个PCB，为了对他们进行有效的管理，应该用适当的方式将这些PCB组织起来，常用的组织方式有三种</p>
<ol>
<li><p>线性方式<br>直接将所有PCB放在一张线性表中，优点是简单，开销小，但是每次查找起来很麻烦。<br><img src="https://cdn.littlecorgi.top/mweb/2019-07-21/linedPCB.jpg" alt="linedPCB"></p>
</li>
<li><p>链接方式<br>把具有相同状态的PCB分别通过PCB中的链接字链接成一个队列。<br><img src="https://cdn.littlecorgi.top/mweb/2019-07-21/linkedPCB.png" alt="linkedPCB"></p>
</li>
<li><p>索引方式<br>根据所有进程状态的不同建立几张索引表，并把个索引表在内存的首地址纪录在内存的一些专用单元中。<br><img src="https://cdn.littlecorgi.top/mweb/2019-07-21/indexPCB.png" alt="indexPCB"></p>
</li>
</ol>
<h1 id="2-2-进程控制"><a href="#2-2-进程控制" class="headerlink" title="2.2 进程控制"></a>2.2 进程控制</h1><h2 id="2-2-1-进程的层次结构"><a href="#2-2-1-进程的层次结构" class="headerlink" title="2.2.1 进程的层次结构"></a>2.2.1 进程的层次结构</h2><p>在OS中，允许一个进程创建另一个进程，通常把创建进程的进程称为父进程，被创建的进程称为子进程。然后子进程可以作为父进程继续去创建子进程，进而形成一个进程家族。</p>
<h2 id="2-2-2-进程的创建"><a href="#2-2-2-进程的创建" class="headerlink" title="2.2.2 进程的创建"></a>2.2.2 进程的创建</h2><p>每当出现了创建新进程的请求后，OS便调用进程创建原语Creat按下述步骤创建新进程：</p>
<ol>
<li>申请空白PCB，为新进程申请获得唯一的数字标识符，并从PCB集合中索取一个空白PCB。</li>
<li>为新进程分配其运行所需的资源，包括各种物理和逻辑资源。</li>
<li>初始化进程控制块PCB。</li>
<li>如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。</li>
</ol>
<h2 id="2-2-3-进程的终止"><a href="#2-2-3-进程的终止" class="headerlink" title="2.2.3 进程的终止"></a>2.2.3 进程的终止</h2><ol>
<li>根据被终止进程的标识符，从PCB集合中检索出进程的PCB，从中读出该进程的状态。</li>
<li>若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志位真，用于指示该进程被终止后应重新进行调度。</li>
<li>若该进程还有子孙进程，还应将其所有子孙进程也都予以终止，以防它们称为不可控的进程。</li>
<li>将被终止进程所拥有的的全部资源或者归还给其父进程，或者归还给系统。</li>
<li>将被终止进程（PCB）从所在队列（或链表）中移出，等待其他程序来搜集信息。</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统3--进程的同步</title>
    <url>/posts/362e394f.html</url>
    <content><![CDATA[<blockquote>
<p>大家可以看下我使用幕布软件画的<a href="https://mubu.com/doc/3Pf0zwzrgw">思维导图</a>，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员<a href="https://mubu.com/inv/477598">https://mubu.com/inv/477598</a><br><span id="more"></span></p>
<h1 id="3-1-进程同步"><a href="#3-1-进程同步" class="headerlink" title="3.1 进程同步"></a>3.1 进程同步</h1><h2 id="3-1-1-同步概念"><a href="#3-1-1-同步概念" class="headerlink" title="3.1.1 同步概念"></a>3.1.1 同步概念</h2><h3 id="3-1-1-1-进程同步的概念"><a href="#3-1-1-1-进程同步的概念" class="headerlink" title="3.1.1.1 进程同步的概念"></a>3.1.1.1 进程同步的概念</h3><p>进程同步机制的主要任务就是对多个相关进程在执行次序上进行协调，使并发执行的进程之间能按照一定的规则共享系统资源，并能很好的配合工作，从而使程序的执行具有可再现性。</p>
</blockquote>
<h3 id="3-1-1-2-制约关系"><a href="#3-1-1-2-制约关系" class="headerlink" title="3.1.1.2 制约关系"></a>3.1.1.2 制约关系</h3><p>对于处于同一个系统中的多个进程，由于他们共享着系统的资源，或者为了完成同一个任务而相互合作，所以他们之间可能存在下面两种制约关系：</p>
<ol>
<li>间接相互制约关系<br> 系统中的进程难免会调用像打印机、CPU等这样的临界资源。如果想这些资源正常调用，必须保证多个进程之间互斥地访问这些资源，进而就在这些进程间形成了间接相互制约关系。<br> 为了保证这些进程能有序的进行，对于系统中的这类资源，必须由系统实施统一分配，即用户在使用之前必须先提出申请，绝不允许用户直接使用。</li>
<li>直接相互制约关系<br> 在系统中也会存在一些进程，他们为了完成同一个目标而相互配合合作工作，这种就是直接互相制约关系。<br> 进程间的直接制约关系就是源于他们之间的相互合作。</li>
</ol>
<h3 id="3-1-1-3-临界资源"><a href="#3-1-1-3-临界资源" class="headerlink" title="3.1.1.3 临界资源"></a>3.1.1.3 临界资源</h3><p>虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，如果变量、数据等都可以被若干进程共享，也属于临界资源。</p>
<h3 id="3-1-1-4-临界区"><a href="#3-1-1-4-临界区" class="headerlink" title="3.1.1.4 临界区"></a>3.1.1.4 临界区</h3><p>人们把在每个进程中访问临界资源的那段代码称为临界区。若能保证诸进程互斥地进入自己的临界区，便可实现诸进程对临界资源的互斥访问。<br>为此，每个进程在进入临界区之前，应先对要访问的临界区进程检查：如果临界区正在被访问，则进程不能进入临界区；如果临界区没有被访问，那进程就可进入临界区，并将临界区正在被访问的标志置为正被访问。<br>所以，我们可以将访问临界资源的线程的循环代码分为如下部分：</p>
<ul>
<li>访问临界区之前用于上述判断的代码区称为<strong>进入区</strong></li>
<li>在访问完临界区之后用于将临界区正被访问的标志恢复为未被访问的标志的代码区称为<strong>退出区</strong></li>
<li>除了进入去、临界区、退出区代码之外的其它代码称为<strong>剩余区</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    进入区</span><br><span class="line">    临界区</span><br><span class="line">    退出区</span><br><span class="line">    剩余区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-1-5-同步机制应遵循的规则"><a href="#3-1-1-5-同步机制应遵循的规则" class="headerlink" title="3.1.1.5 同步机制应遵循的规则"></a>3.1.1.5 同步机制应遵循的规则</h3><ol>
<li>空闲让进：当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效的利用临界资源</li>
<li>忙则等待：当已有进程进入临界区，表明临界资源正在被访问，因而其它视图进入临界区的进程必须等待，以保证对临界资源的互斥访问</li>
<li>有限等待：对要求访问临界资源的进程，应保证在有限的时间内能进入自己的临界区，以免陷入“死等”状态</li>
<li>让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态</li>
</ol>
<h2 id="3-1-2-同步机制"><a href="#3-1-2-同步机制" class="headerlink" title="3.1.2 同步机制"></a>3.1.2 同步机制</h2><h3 id="3-2-2-1-信号量机制"><a href="#3-2-2-1-信号量机制" class="headerlink" title="3.2.2.1 信号量机制"></a>3.2.2.1 信号量机制</h3><h4 id="1-什么是信号量"><a href="#1-什么是信号量" class="headerlink" title="1. 什么是信号量"></a>1. 什么是信号量</h4><p>信号量的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程，值则与相应的资源的使用情况有关：</p>
<ul>
<li>当他的值大于0时，表示当前可用资源的数量</li>
<li>当他的值小于0时，其绝对值表示等待使用该资源的进程个数</li>
</ul>
<h4 id="2-什么是信号量机制"><a href="#2-什么是信号量机制" class="headerlink" title="2. 什么是信号量机制"></a>2. 什么是信号量机制</h4><p>信号量机制即利用pv操作对信号量进行处理。而且信号量只能由pv操作进程处理。<br>当S&gt;0时，S表示可用资源的数量。执行一次P操作意味着分配一个单位资源，因此S值减1；当S<0时，表示已经没有可用资源，请求者必须等待别的进程释放该类资源，他才能运行下去。而执行一个V操作以为着释放一个单位资源，因此S的值加1；当S>0，表示有某些资源正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。</p>
<h3 id="3-2-2-2-PV操作"><a href="#3-2-2-2-PV操作" class="headerlink" title="3.2.2.2 PV操作"></a>3.2.2.2 PV操作</h3><h4 id="1-P操作"><a href="#1-P操作" class="headerlink" title="1. P操作"></a>1. P操作</h4><p>申请一个单位资源，进程进入临界区<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wait (S) &#123;</span><br><span class="line">    <span class="keyword">while</span> (s &lt;= <span class="number">0</span>) ;<span class="comment">// 如果没有资源则循环等待</span></span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>将信号量S的值减1，即S=S-1；</li>
<li>如果S&lt;=0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。</li>
</ol>
<h4 id="2-V操作"><a href="#2-V操作" class="headerlink" title="2. V操作"></a>2. V操作</h4><p>释放一个单位资源，进程从临界区出来<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">signal (S) &#123;</span><br><span class="line">    S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>将信号量S的值加1，即S=S+1；</li>
<li>如果S&gt;0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。</li>
</ol>
<h4 id="3-PV操作的意义"><a href="#3-PV操作的意义" class="headerlink" title="3. PV操作的意义"></a>3. PV操作的意义</h4><p>用PV操作来实现进程的同步和互斥</p>
<h3 id="3-2-3-管程机制"><a href="#3-2-3-管程机制" class="headerlink" title="3.2.3 管程机制"></a>3.2.3 管程机制</h3><p>尽管信号量机制很方又高效，但是每个要访问临界资源的进程都必须必备同步操作，这就使得大量的同步操作分散在各个进程中。这不仅给系统的管理带来麻烦，还会因同步操作不当而产生死锁。为了解决上述问题，变产生了一种新的同步工具——管程。</p>
<h4 id="1-管程的定义"><a href="#1-管程的定义" class="headerlink" title="1. 管程的定义"></a>1. 管程的定义</h4><p>系统中各种硬件资源和软件资源均可用数据结构抽象地描述其资源特征，即用少量信息和对该资源所执行的操作来表征该资源。所以就出现了管程。<br>管程可以看成一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。<br>在管程入口处的等待队列称为入口等待队列，由于进程会执行唤醒操作，因此可能有多个等待使用管程的队列，这样的队列称为紧急队列，它的优先级高于等待队列。</p>
<h4 id="2-管程的特征"><a href="#2-管程的特征" class="headerlink" title="2. 管程的特征"></a>2. 管程的特征</h4><ol>
<li>模块化<br> 管程是一个基本的软件模块，可以单独编译</li>
<li>抽象数据类型<br> 管程中封装了数据及对于数据的操作</li>
<li>信息隐藏<br> 管程外的进程或其他软件模块只能通过管程对外的接口来访问管程提供的操作，管程内部的实现细节对外界是透明的</li>
<li>使用的互斥性<br> 任何一个时刻，管程只能由一个进程使用。进入管程时的互斥由编译器负责完成</li>
</ol>
<h4 id="3-条件变量"><a href="#3-条件变量" class="headerlink" title="3. 条件变量"></a>3. 条件变量</h4><p>一个进程被阻塞或挂起的条件（原因）有多个，因此在管程中设置了多个条件变量，对这些条件变量的访问只能在管程中进行。<br>管程中每个条件变量都需予以说明，形式为：<code>condition x</code>。对其的操作只有<code>wait</code>和<code>signal</code>，其含义是：</p>
<ol>
<li><code>x.wait</code>：正在调用管程的进程因x条件需要被阻塞或挂起，则调用<code>x.wait</code>将自己插入到x条件的等待队列上，并释放管程，知道x条件发生变化。此时其它进程可以使用该管程。</li>
<li><code>x.signal</code>： 正在调用管程的进程发现x条件发生了变化，则调用<code>x.signal</code>，重新启动一个因x条件而阻塞或挂起的进程，如果存在多个这样的进程，则选择其中的一个，如果没有，继续执行原进程，不产生任何结果。（与信号量的signal不同，没有s=s+1的操作）</li>
</ol>
<h1 id="3-2-进程同步的经典问题"><a href="#3-2-进程同步的经典问题" class="headerlink" title="3.2 进程同步的经典问题"></a>3.2 进程同步的经典问题</h1><h2 id="3-2-1-生产者-消费者问题"><a href="#3-2-1-生产者-消费者问题" class="headerlink" title="3.2.1 生产者-消费者问题"></a>3.2.1 生产者-消费者问题</h2><h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>有一群生产者进程在生产产品，并将这些产品提供给消费者进程去消费。为使生产者进程与消费者进程能并发执行，在两者之间设置了一个大小为n的缓冲区，生产者进程将其所产生的产品放入缓冲区中；消费者可从缓冲区中取走产品去消费。他们之间必须保持同步，也就是既不允许消费者进程到一个空缓冲区去取产品，也不允许生产者进程向一个已装满产品且尚未被取走的缓冲区中投放产品。<br><img src="https://cdn.littlecorgi.top/mweb/2019-07-31/ProducerConsumerProblem.jpg" alt="ProducerConsumerProble"></p>
<h3 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h3><p>需要注意的几点：</p>
<ul>
<li>在缓冲区为空时，消费者不能再进行消费</li>
<li>在缓冲区已满时，生产者不能再进行生产</li>
<li>当一个线程进行生产或消费时，其余线程不能再进行生产或消费</li>
</ul>
<h3 id="3-伪代码"><a href="#3-伪代码" class="headerlink" title="3. 伪代码"></a>3. 伪代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var items = <span class="number">0</span>, space = <span class="number">10</span>, mutex = <span class="number">1</span>;</span><br><span class="line">var in = <span class="number">0</span>, out = <span class="number">0</span>;</span><br><span class="line">item buf[<span class="number">10</span>] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">producer &#123;</span><br><span class="line">    <span class="keyword">while</span>( <span class="literal">true</span> ) &#123;</span><br><span class="line">        wait( space );  <span class="comment">// 等待缓冲区有空闲位置， 在使用PV操作时，条件变量需要在互斥锁之前</span></span><br><span class="line">        wait( mutex );  <span class="comment">// 保证在product时不会有其他线程访问缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// product</span></span><br><span class="line">        buf.push( item, in );  <span class="comment">// 将新资源放到buf[in]位置 </span></span><br><span class="line">        in = ( in + <span class="number">1</span> ) % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        signal( mutex );  <span class="comment">// 唤醒的顺序可以不同</span></span><br><span class="line">        signal( items );  <span class="comment">// 通知consumer缓冲区有资源可以取走</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer &#123;</span><br><span class="line">    <span class="keyword">while</span>( <span class="literal">true</span> ) &#123;</span><br><span class="line">        wait( items );  <span class="comment">// 等待缓冲区有资源可以使用</span></span><br><span class="line">        wait( mutex );  <span class="comment">// 保证在consume时不会有其他线程访问缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// consume</span></span><br><span class="line">        buf.pop( out );  <span class="comment">// 将buf[out]位置的的资源取走</span></span><br><span class="line">        out = ( out + <span class="number">1</span> ) % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        signal( mutex );  <span class="comment">// 唤醒的顺序可以不同</span></span><br><span class="line">        signal( space );  <span class="comment">// 通知缓冲区有空闲位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能将线程里两个<code>wait</code>的顺序调换否则会出现死锁。例如(调换后)，将<code>consumer</code>的两个<code>wait</code>调换，在<code>producer</code>发出<code>signal</code>信号后，如果<code>producer</code>线程此时再次获得运行机会，执行完了<code>wait(space)</code>，此时，另一个<code>consumer</code>线程获得运行机会，执行了<code>wait(mutex)</code>，如果此时缓冲区为空，那么<code>consumer</code>将会阻塞在<code>wait(items)</code>，而<code>producer</code>也会因为无法获得锁的所有权所以阻塞在<code>wait(mutex)</code>，这样两个线程都在阻塞，也就造成了死锁。</p>
<h2 id="3-2-2-哲学家进餐问题"><a href="#3-2-2-哲学家进餐问题" class="headerlink" title="3.2.2 哲学家进餐问题"></a>3.2.2 哲学家进餐问题</h2><h3 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>有五位哲学家共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五支筷子。他们的生活的方式是交替的进行思考和进餐：平时，一个哲学家进行思考，饥饿时便视图取其左右离他最近的筷子，只有在他拿到两只筷子时才能进餐，进餐完毕，放下筷子继续思考。</p>
<h3 id="2-问题分析-1"><a href="#2-问题分析-1" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h3><ul>
<li>只有拿到两只筷子时，哲学家才能吃饭。</li>
<li>如果筷子已被别人拿走，则必须等别人吃完之后才能拿到筷子。</li>
<li>任一哲学家在自己未拿到两只筷子吃完饭前，不会放下手中已经拿到的筷子</li>
</ul>
<h3 id="3-伪代码-1"><a href="#3-伪代码-1" class="headerlink" title="3. 伪代码"></a>3. 伪代码</h3><p>至多只允许四个哲学家同时进餐，以保证至少有一个哲学家能够进餐，最终总会释放出他所使用过的两支筷子，从而可使更多的哲学家进餐。定义信号量count，只允许4个哲学家同时进餐，这样就能保证至少有一个哲学家可以就餐。<br> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore count=<span class="number">4</span>; <span class="comment">// 设置一个count，最多有四个哲学家可以进来</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		think();</span><br><span class="line">		wait(count); <span class="comment">//请求进入房间进餐 当count为0时 不能允许哲学家再进来了</span></span><br><span class="line">		wait(chopstick[i]); <span class="comment">//请求左手边的筷子</span></span><br><span class="line">		wait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">//请求右手边的筷子</span></span><br><span class="line">		eat();</span><br><span class="line">		signal(chopstick[i]); <span class="comment">//释放左手边的筷子</span></span><br><span class="line">		signal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">//释放右手边的筷子</span></span><br><span class="line">		signal(count); <span class="comment">//离开饭桌释放信号量</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-2-3-读者-写者问题"><a href="#3-2-3-读者-写者问题" class="headerlink" title="3.2.3 读者-写者问题"></a>3.2.3 读者-写者问题</h2><h3 id="1-问题描述-2"><a href="#1-问题描述-2" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>一个数据文件或记录可被多个进程共享，我们把只要求读该文件的进程称为“Reader进程”，其它进程则称为“Writer进程”。允许多个进程同时读一个共享对象，因为读操作不会使数据文件混乱。但不允许一个Writer进程和其它Reader进程或Writer进程同时访问共享对象，这样很有可能造成共享数据混乱。</p>
<h3 id="2-问题分析-2"><a href="#2-问题分析-2" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h3><ul>
<li>允许多个Reader进程同时操作一个共享对象</li>
<li>不允许Writer进程和其它进程同时操作一个共享对象</li>
</ul>
<h3 id="3-伪代码-2"><a href="#3-伪代码-2" class="headerlink" title="3. 伪代码"></a>3. 伪代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore rmutex = <span class="number">1</span>,wmutex = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> readcount = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		wait(rmutex);</span><br><span class="line">		<span class="keyword">if</span>(readcount==<span class="number">0</span>) wait(wmutex);</span><br><span class="line">		readcount++;</span><br><span class="line">		signal(rmutex);</span><br><span class="line">		···</span><br><span class="line">		perform read operation;</span><br><span class="line">		···</span><br><span class="line">		wait（rmutex）；</span><br><span class="line">		<span class="keyword">if</span>(readcount==<span class="number">0</span>) signal(wmutex);</span><br><span class="line">		readcount--;</span><br><span class="line">		signal(rmutex);</span><br><span class="line">	&#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		wait(wmutex);</span><br><span class="line">		perfrom write operation;</span><br><span class="line">		signal(wmutex); </span><br><span class="line">	&#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统1--操作系统概述</title>
    <url>/posts/62248b34.html</url>
    <content><![CDATA[<blockquote>
<p>大家可以看下我使用幕布软件画的<a href="https://mubu.com/doc/3Pf0zwzrgw">思维导图</a>，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员<a href="https://mubu.com/inv/477598">https://mubu.com/inv/477598</a></p>
</blockquote>
<span id="more"></span>
<h1 id="现如今主流的操作系统"><a href="#现如今主流的操作系统" class="headerlink" title="现如今主流的操作系统"></a>现如今主流的操作系统</h1><h2 id="1-1-1-PC"><a href="#1-1-1-PC" class="headerlink" title="1.1.1 PC"></a>1.1.1 PC</h2><h3 id="1-1-1-1-Windows"><a href="#1-1-1-1-Windows" class="headerlink" title="1.1.1.1 Windows"></a>1.1.1.1 Windows</h3><p>Microsoft Windows是微软公司推出的一系列操作系统。其问世时间为1985年，起初为运行于MS-DOS之下的桌面环境，其后续版本逐渐发展成为主要为个人计算机和服务器用户设计的操作系统，并最终获得了世界个人计算机操作系统的垄断地位。此操作系统可以在几种不同类型的平台上运行，如个人计算机、移动设备、服务器和嵌入式系统等等，其中在个人计算机的领域应用内最为普遍。<br>Windows操作系统当前最新的稳定版是于2015年7月29日发布的 Windows 10。Windows Server当前最新的稳定版是2018年10月2日发布的Windows Server 2019。Windows Phone当前最新的稳定版是Windows10 Mobile，但是已停止开发新版本，仅对现有版本进行安全补丁和维护，直到2019年12月。</p>
<h3 id="1-1-1-2-macOS"><a href="#1-1-1-2-macOS" class="headerlink" title="1.1.1.2 macOS"></a>1.1.1.2 macOS</h3><p>macOS（2011年及之前称Mac OS X，2012年至2015年称OS X）是苹果公司推出的基于图形用户界面操作系统，为麦金塔（Macintosh）的主操作系统。StatCounter在2018年8月的数据表示，在桌面操作系统中，macOS的使用份额为12.65%，次于Windows的82.51%位居第二。<br>macOS当前最新的稳定版是2018年9月25日发布的macOS 10.14 Mojave，2019年6月4日推出macOS 10.15 Catalina的第一个测试版本。</p>
<h3 id="1-1-1-3-Linux"><a href="#1-1-1-3-Linux" class="headerlink" title="1.1.1.3 Linux"></a>1.1.1.3 Linux</h3><p>Linux是一种自由和开放源码的类UNIX 操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布，在加上用户空间的应用程序之后，成为 Linux 操作系统。Linux也是自由软件和开放源代码软件发展中最著名的例子。只要遵循 GNU 通用公共许可证（GPL），任何个人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布。大多数 Linux 系统还包括像提供 GUI 的 X Window 之类的程序。除了一部分专家之外，大多数人都是直接使用 Linux 发行版，而不是自己选择每一样组件或自行设置。</p>
<h3 id="1-1-1-4-Unix"><a href="#1-1-1-4-Unix" class="headerlink" title="1.1.1.4 Unix"></a>1.1.1.4 Unix</h3><p>UNIX操作系统（尤尼斯），是一个强大的多用户、多任务操作系统，支持多种处理器架构，按照操作系统的分类，属于分时操作系统，最早由KenThompson、Dennis Ritchie和Douglas McIlroy于1969年在AT&amp;T的贝尔实验室开发。它的商标权由国际开放标准组织所拥有，只有符合单一UNIX规范的UNIX系统才能使用UNIX这个名称，否则只能称为类UNIX（UNIX-like）。</p>
<h2 id="1-1-2-移动端"><a href="#1-1-2-移动端" class="headerlink" title="1.1.2 移动端"></a>1.1.2 移动端</h2><h3 id="1-1-2-1-Android"><a href="#1-1-2-1-Android" class="headerlink" title="1.1.2.1 Android"></a>1.1.2.1 Android</h3><p>Android，常见的非官方中文名称为安卓，是一个基于Linux内核的开放源代码移动操作系统，由Google成立的Open Handset Alliance持续领导与开发，主要设计用于触摸屏移动设备如智能手机和平板电脑与其他便携式设备。<br>Android Inc.于2003年10月由安迪·鲁宾、利奇·米纳尔、尼克·席尔斯、克里斯·怀特在加州帕罗奥图创建。Android最初由安迪·鲁宾等人开发制作，最初开发这个系统的早期方向是创建一个数字相机的先进操作系统，但是后来发现市场需求不够大，加上智能手机市场快速成长，于是Android成为一款面向智能手机的操作系统。于2005年7月11日Android Inc.被美国科技企业Google收购。<br>2017年3月，Android全球网络流量和设备超越Microsoft Windows，正式成为全球第一大操作系统。</p>
<h3 id="1-1-2-2-iOS"><a href="#1-1-2-2-iOS" class="headerlink" title="1.1.2.2 iOS"></a>1.1.2.2 iOS</h3><p>iOS（原名为iPhone OS）是苹果公司为其移动设备所开发的专有移动操作系统，为其公司的许多移动设备提供操作界面，支持设备包括iPhone、iPad和iPod touch。iPhone OS自iOS 4起便改名为iOS，它是继Android后全球第二大最受欢迎的移动操作系统，市占率已上升至约24.5% ，但仍远低于Google开发的Android系统的72.2%。</p>
<h1 id="1-2-操作系统的简介与作用"><a href="#1-2-操作系统的简介与作用" class="headerlink" title="1.2 操作系统的简介与作用"></a>1.2 操作系统的简介与作用</h1><h2 id="1-2-1-操作系统的简介"><a href="#1-2-1-操作系统的简介" class="headerlink" title="1.2.1 操作系统的简介"></a>1.2.1 操作系统的简介</h2><p>操作系统是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。主要作用是对管理好计算机硬件设备，提高他们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单接口，便于用户使用。</p>
<h2 id="1-2-2-操作系统的目的"><a href="#1-2-2-操作系统的目的" class="headerlink" title="1.2.2 操作系统的目的"></a>1.2.2 操作系统的目的</h2><ol>
<li>方便性<br> 如果一个计算机没有OS，那么他会非常难用。用户不管进行啥操作都得通过机器语言编写程序然后运行，而如果有OS的话，用户就可以使用各种各样的语言编写程序，然后通过编译将高级语言编译成机器代码，方便了用户。</li>
<li>有效性<br> 有效性分两层含义——提高系统资源的利用率和提高系统的吞吐量。早期没有OS的计算机中，处理机和I/O设备等经常处于空闲状态，各种资源不能得到合理利用，所以提高系统资源利用率是推动OS发展的主要动力。另一方面，OS可以通过合理组织计算机的工作流程，加速程序的运行，缩短程序的运行周期，从而提高系统的吞吐量。</li>
<li>可扩充性<br> 为了适应现在越来越多的计算机硬件以及体系结构，OS必修有良好的可扩充性。</li>
<li>开放性<br> OS需要遵循世界标准规范，凡遵循国际标准所开发的硬件和软件都能彼此兼容，方便地实现互联。</li>
</ol>
<h2 id="1-2-3-操作系统的作用"><a href="#1-2-3-操作系统的作用" class="headerlink" title="1.2.3 操作系统的作用"></a>1.2.3 操作系统的作用</h2><ol>
<li>OS作为用户与计算机硬件系统之间的接口<br> OS处于用户和硬件之间，方便用户通过OS使用硬件。或者说，用户在OS的帮助下能够方便、快捷、可靠地操纵计算机硬件和运行自己的程序。</li>
<li>OS作为计算机系统资源的管理者<br> 计算机系统资源主要可分为处理机、存储器、I/O设备以及文件。OS主要功能也就是对这四类资源进行有效的管理。处理机管理是用于分配和控制处理机；存储器管理主要负责内存的分配与回收；I/O设备管理是负责I/O设备的分配与操纵；文件管理是用于实现对文件的存取、共享和保护。</li>
<li>OS实现了对计算机资源的抽象<br> 在裸机中，用户如果想要对计算器进行操作，必须对物理接口的实现细节有充分的了解。但在操作系统中，用户并不需要关心具体的物理，而由操作系统来实现具体的操作细节，并向上讲操作设备抽象为一组数据结构以及一组操作命令。此时在用户眼里，看到的是一台比裸机功能更强，使用更方便的机器。</li>
</ol>
<h2 id="1-2-4-推动操作系统发展的主要动力"><a href="#1-2-4-推动操作系统发展的主要动力" class="headerlink" title="1.2.4 推动操作系统发展的主要动力"></a>1.2.4 推动操作系统发展的主要动力</h2><ol>
<li>不断提高计算机资源利用率</li>
<li>方便用户</li>
<li>器件的不断更新换代</li>
<li>计算机体系结构的不断发展</li>
<li>不断提出新的应用需求</li>
</ol>
<h1 id="1-3-操作系统的发展"><a href="#1-3-操作系统的发展" class="headerlink" title="1.3 操作系统的发展"></a>1.3 操作系统的发展</h1><h2 id="1-3-1-单道批处理系统"><a href="#1-3-1-单道批处理系统" class="headerlink" title="1.3.1 单道批处理系统"></a>1.3.1 单道批处理系统</h2><p>在说单道批处理之前现要引入一个概念——作业。作业包括用户程序、数据、作业说明书。这样每一个处理对象都是作业。</p>
<h3 id="1-处理过程"><a href="#1-处理过程" class="headerlink" title="1. 处理过程"></a>1. 处理过程</h3><p>每个单道批处理系统都有一个系统操作员。用户先将作业交给系统操作员，然后操作系统操作员就将一个个作业组成一批作业，输入到计算机中，在系统中形成一个自动转接的作业流，然后启动操作系统对作业自动、依次的处理，处理完成后再将处理结果返回给系统操作员，操作员在返回给用户。这样就形成了一个单道批处理过程。<br><img src="https://cdn.littlecorgi.top/mweb/2019-07-19/15635340778216.png" alt="单道批处理系统处理过程"></p>
<h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>系统资源得不到充分利用。这是因为在内存中仅有一道程序，每逢程序在运行中发出I/O请求后，CPU便处于等待状态，必须在I/O完成后才继续运行。</p>
<h2 id="1-3-2-多道批处理系统"><a href="#1-3-2-多道批处理系统" class="headerlink" title="1.3.2 多道批处理系统"></a>1.3.2 多道批处理系统</h2><h3 id="1-处理过程-1"><a href="#1-处理过程-1" class="headerlink" title="1. 处理过程"></a>1. 处理过程</h3><p>在该系统中，用户所提交的作业先放在外存中，并排成一个队列，称为“后备队列“。然后由作业调度程序按一定的算法，从后备队列中选择若干作业调入内存。由于同时在内存中装有若干道程序，这样便可以在运行程序A时，利用其I/O操作暂停执行时的CPU空档期，再调度另一道程序B运行。</p>
<h3 id="2-优缺点"><a href="#2-优缺点" class="headerlink" title="2. 优缺点"></a>2. 优缺点</h3><ol>
<li>优点<ol>
<li>资源利用率高</li>
<li>系统吞吐量大</li>
</ol>
</li>
<li>缺点<ol>
<li>平均周转时间长</li>
<li>无交互能力</li>
</ol>
</li>
</ol>
<h2 id="1-3-3-分时系统"><a href="#1-3-3-分时系统" class="headerlink" title="1.3.3 分时系统"></a>1.3.3 分时系统</h2><h3 id="1-运行方式"><a href="#1-运行方式" class="headerlink" title="1. 运行方式"></a>1. 运行方式</h3><ol>
<li>作业直接进入内存。因为作业在磁盘上不可运行，所以作业应直接进入内存</li>
<li>采用轮转运行方式。如果一个作业独占CPU连续运行，那么其他作业没法运行。为了避免这种情况，引入了时间片概念。一个时间片是一个很短的时间，系统规定了每个作业每次只能运行一个时间片，然后就暂停该作业的运行，并立即调度下一个作业运行。如果在不长的时间内能使所有的作业都执行一个时间片的时间，便可以使每个用户都能及时地与自己的作业进行交互，从而使用户的请求的到及时响应。</li>
</ol>
<h3 id="2-特征"><a href="#2-特征" class="headerlink" title="2. 特征"></a>2. 特征</h3><ol>
<li>多路性</li>
<li>独立性</li>
<li>及时性</li>
<li>交互性</li>
</ol>
<h2 id="1-3-4-实时系统"><a href="#1-3-4-实时系统" class="headerlink" title="1.3.4 实时系统"></a>1.3.4 实时系统</h2><p>实时系统是指系统能及时响应外部事件的请求，在规定时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。<br>实时系统主要应用于：</p>
<ol>
<li>工业（武器）控制系统</li>
<li>信息查询系统</li>
<li>多媒体系统</li>
<li>嵌入式系统</li>
</ol>
<h1 id="1-4-操作系统的基本特征"><a href="#1-4-操作系统的基本特征" class="headerlink" title="1.4 操作系统的基本特征"></a>1.4 操作系统的基本特征</h1><h2 id="1-4-1-并发"><a href="#1-4-1-并发" class="headerlink" title="1.4.1 并发"></a>1.4.1 并发</h2><p>正是系统中有这一特征，才使得OS能有效地提高系统中的资源利用率，增加系统的吞吐量。</p>
<h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>并行是指两个或多个事件在同一时刻发生，微观上是同一时刻多个线程在CPU上运行。<br>并发是指宏观上两个或多个事件在同一时间发生，微观上缺是某一时刻CPU上只有一个进程。</p>
<h2 id="1-4-2-共享"><a href="#1-4-2-共享" class="headerlink" title="1.4.2 共享"></a>1.4.2 共享</h2><p>资源共享，即操作系统中的资源可供多个并发执行的进程共同使用，由于资源属性不同，多个进程对资源的共享方式也不同。可分为：互斥共享方式和同时访问方式。</p>
<h3 id="1-互斥共享方式"><a href="#1-互斥共享方式" class="headerlink" title="1. 互斥共享方式"></a>1. 互斥共享方式</h3><p>一段时间内只允许一个进程访问该资源，如磁带机,打印机等。虽然可以供多个进程使用，但是为了打印或记录结果不造成混淆，应规定一段时间内只允许一个进程访问该资源。</p>
<h3 id="2-同时访问方式"><a href="#2-同时访问方式" class="headerlink" title="2. 同时访问方式"></a>2. 同时访问方式</h3><p>某些资源，一段时间内是可以允许多个进程“同时”同时对他们进行访问，这个同时是宏观上的，在微观上可能是分时共享。</p>
<h2 id="1-4-3-虚拟"><a href="#1-4-3-虚拟" class="headerlink" title="1.4.3 虚拟"></a>1.4.3 虚拟</h2><p>在OS中，把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为”虚拟“。</p>
<h2 id="1-4-4-异步"><a href="#1-4-4-异步" class="headerlink" title="1.4.4 异步"></a>1.4.4 异步</h2><p>在多道环境下，允许多个程序并发执行。但由于资源有限，进程的执行不是一贯到底。而是走走停停，以不可预知的速度向前推进，这就是进程的异步。</p>
<h1 id="1-5-操作系统的主要功能"><a href="#1-5-操作系统的主要功能" class="headerlink" title="1.5 操作系统的主要功能"></a>1.5 操作系统的主要功能</h1><p>操作系统的主要功能应分为处理机管理、存储器管理、设备管理和文件管理。此外，还应向用户提供方便的用户接口。</p>
<h2 id="1-5-1-处理机管理功能"><a href="#1-5-1-处理机管理功能" class="headerlink" title="1.5.1 处理机管理功能"></a>1.5.1 处理机管理功能</h2><h3 id="1-进程控制"><a href="#1-进程控制" class="headerlink" title="1. 进程控制"></a>1. 进程控制</h3><p>在多道程序环境中，为了使作业能并发执行，必须为每道作业创建一个或几个进程，并为之分配必要的资源。当进程运行结束时，应立即撤销该进程，以便能及时回收该进程所占用的各种资源，供其它进程使用。</p>
<h3 id="2-进程同步"><a href="#2-进程同步" class="headerlink" title="2. 进程同步"></a>2. 进程同步</h3><p>为了使多个进程能有条不紊的运行，系统中必须设置相应的进程同步机制。该机制的主要任务是为多个进程的运行进行协调。</p>
<h3 id="3-进程通信"><a href="#3-进程通信" class="headerlink" title="3. 进程通信"></a>3. 进程通信</h3><p>如果一组相互合作的进程去完成一个共同的任务时，在他们之间往往需要交换信息。</p>
<h3 id="4-调度"><a href="#4-调度" class="headerlink" title="4. 调度"></a>4. 调度</h3><p>在传统OS中，调度包括作业调度和进程调度。</p>
<ol>
<li>作业调度<br> 作业调度的基本任务就是从后备队列中按照一定的算法选择出若干个作业，为他们分配所需资源，在这些作业调入内存后，分别为他们创建进程，是他们都称为可能获得处理机的就绪进程，并将他们插入就绪队列中。</li>
<li>进程调度<br> 进程调度的任务是从进程的就绪队列中按照一定的算法选出一个进程，将处理机分配给他，并为他设置运行线程，使其投入执行。</li>
</ol>
<h2 id="1-5-2-存储器管理功能"><a href="#1-5-2-存储器管理功能" class="headerlink" title="1.5.2 存储器管理功能"></a>1.5.2 存储器管理功能</h2><p>存储器管理视为多道程序的运行提供良好的环境，提高存储器利用率，并能从逻辑上扩充内存。为此，存储器管理应具有内存分配和回收、内存保护、地址映射和内存扩充等功能。</p>
<h3 id="1-内存分配"><a href="#1-内存分配" class="headerlink" title="1. 内存分配"></a>1. 内存分配</h3><p>内存分配主要任务是：</p>
<ol>
<li>为每道程序分配内存空间</li>
<li>提高存储器的利用率，尽量减少不可用的内存空间</li>
<li>允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要。</li>
</ol>
<p>OS在实现内存分配时，可采取静态和动态两种方式：</p>
<ol>
<li>静态分配内存。每个作业的内存空间在作业装入时确定，确定后不再改变。</li>
<li>动态分配内存。每个作业所要求的的基本内存空间虽然也是在装入时确定的，但允许作业在运行过程中继续申请新的附加内存空间，以适应程序和数据的动态增长。</li>
</ol>
<h3 id="2-内存保护"><a href="#2-内存保护" class="headerlink" title="2. 内存保护"></a>2. 内存保护</h3><p>确保每道用户程序都在自己的内存空间内运行，彼此互不干扰。决不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其他用户程序中去执行。</p>
<h3 id="3-地址映射"><a href="#3-地址映射" class="headerlink" title="3. 地址映射"></a>3. 地址映射</h3><p>每道程序经编译连接后所形成的的可装入程序其地址都是从0开始的，但是不可能将他们从“0”地址开始装入内存，所以物理地址和逻辑地址并不一致，这时候就需要地址映射来让程序能正常运行。</p>
<h3 id="4-内存扩充"><a href="#4-内存扩充" class="headerlink" title="4. 内存扩充"></a>4. 内存扩充</h3><p>借助虚拟存储技术来实现内存扩充，主要解决：</p>
<ol>
<li>内存和I/O之间速度不匹配的问题</li>
<li>如果内存空间不足的问题</li>
</ol>
<h2 id="1-5-3-设备管理功能"><a href="#1-5-3-设备管理功能" class="headerlink" title="1.5.3 设备管理功能"></a>1.5.3 设备管理功能</h2><p>主要任务：</p>
<ol>
<li>完成用户进程提出的I/O请求，为用户进程分配所需的I/O设备，并完成指定的I/O操作</li>
<li>提高CPU与I/O设备的利用率，提高I/O速度，方便用户使用I/O</li>
</ol>
<p>为了实现以上功能，应具有缓冲管理、设备分配和设备处理以及虚拟设备等功能。</p>
<h3 id="1-缓冲管理"><a href="#1-缓冲管理" class="headerlink" title="1. 缓冲管理"></a>1. 缓冲管理</h3><p>为了有效的缓和CPU与I/O设备间速度不匹配的问题，提高CPU利用率，于是引入了缓冲管理。</p>
<h3 id="2-设备分配"><a href="#2-设备分配" class="headerlink" title="2. 设备分配"></a>2. 设备分配</h3><p>设备分配的基本任务是根据用户进程的I/O请求、系统现有资源情况以及按照某种设备分配策略，为之分配其所需的设备。</p>
<h3 id="3-设备处理"><a href="#3-设备处理" class="headerlink" title="3. 设备处理"></a>3. 设备处理</h3><p>实现CPU和设备控制器之间的通信，即由CPU向设备控制器发出I/O命令，要求他完成指定的I/O操作；反之，由CPU控制从接收器发来的中断请求，并给予迅速的响应和相应的处理。</p>
<h2 id="1-5-4-文件管理功能"><a href="#1-5-4-文件管理功能" class="headerlink" title="1.5.4 文件管理功能"></a>1.5.4 文件管理功能</h2><p>主要是对用户文件和系统文件进行管理以方便用户使用，并保证文件的安全性。为此，文件管理应具有对文件存储空间管理、目录管理、文件的读/写管理以及文件的共享与保护等功能。</p>
<h3 id="1-文件存储空间的管理"><a href="#1-文件存储空间的管理" class="headerlink" title="1. 文件存储空间的管理"></a>1. 文件存储空间的管理</h3><p>为每个文件分配必要的外存空间，提高我村利用率，进而提高文件系统的存、取速度。</p>
<h3 id="2-目录管理"><a href="#2-目录管理" class="headerlink" title="2. 目录管理"></a>2. 目录管理</h3><p>为每个文件建立一个目录项，目录项包括文件名、文件属性、文件在磁盘上的物理位置等，并对众多的目录项加以有效的组织，以实现方便的按名字存取。</p>
<h3 id="3-文件的读-写管理和保护"><a href="#3-文件的读-写管理和保护" class="headerlink" title="3. 文件的读/写管理和保护"></a>3. 文件的读/写管理和保护</h3><p>根据用户的请求，从外存中读取数据或将数据写入外存。并且保护文件防止其被非法盗取和破坏。</p>
<h2 id="1-5-5-操作系统与用户间的接口"><a href="#1-5-5-操作系统与用户间的接口" class="headerlink" title="1.5.5 操作系统与用户间的接口"></a>1.5.5 操作系统与用户间的接口</h2><p>接口主要分为两大类：用户接口和程序接口。用户接口是供用户调用，方便用户直接或间接控制自己的作业。程序接口是为用户程序在执行中访问系统资源而设定的，是用户取得操作系统服务的唯一途径。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统4--进程的通信和线程</title>
    <url>/posts/30b7e738.html</url>
    <content><![CDATA[<blockquote>
<p>大家可以看下我使用幕布软件画的<a href="https://mubu.com/doc/3Pf0zwzrgw">思维导图</a>，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员<a href="https://mubu.com/inv/477598">https://mubu.com/inv/477598</a><br><span id="more"></span></p>
<h1 id="4-1-进程通信"><a href="#4-1-进程通信" class="headerlink" title="4.1 进程通信"></a>4.1 进程通信</h1><p>进程通信就是指进程之间的信息交换。</p>
</blockquote>
<p>早期的时候，由于技术不发达，以及由于进程的同步和互斥需要在进程间交换一定的数据，所以不少人也将他们称为进程通信，但是实质上他们只能被成为低级的进程通信。<br>以信号量为例，他</p>
<ol>
<li>效率低<br> 生产者或消费者每次只能向缓冲区投放一个产品或者取出一个产品。</li>
<li>通信对用户不透明</li>
</ol>
<p>而关于进程间通信所需的数据结构的设置和数据的传送、进程的同步和互斥，都需要程序员去完成，显然是非常不方便的。</p>
<p>所以高级进程通信必须满足如下特点：</p>
<ol>
<li>使用方便。<br> OS隐藏了实现进程通信的具体细节，向用户提供了一组用于实现高级通信的命令，用户可以方便地直接利用它实现进程之间的通信。</li>
<li>高效的传送数据。<br> 用户可以直接利用高级通信命令高效的传送大量的数据。</li>
</ol>
<p>进程通信主要有共享存储器系统、管道通信系统、消息传递系统以及客户机-服务器系统。</p>
<h2 id="4-1-1-共享存储器系统"><a href="#4-1-1-共享存储器系统" class="headerlink" title="4.1.1 共享存储器系统"></a>4.1.1 共享存储器系统</h2><p>共享存储器系统又分为了两种：</p>
<ol>
<li>基于共享数据结构的通信方式<br> 在这种通信方式下，要求进程公用某些数据结构，借以实现诸进程间的信息交换。这种方式仅适用于传递相对少量的数据，通信效率低下，属于低级通信。</li>
<li>基于共享存储区的通信方式<br> 为了传输大量数据，就在内存中划出了一块共享存储区域，诸进程可通过对该共享区的读或写交换数据，实现通信，数据的形式和位置甚至访问控制都是由进程负责，而不是OS。</li>
</ol>
<h2 id="4-1-2-管道通信系统"><a href="#4-1-2-管道通信系统" class="headerlink" title="4.1.2 管道通信系统"></a>4.1.2 管道通信系统</h2><p>所谓管道，是指用于连接一个读进程和一个写进程以实现他们之间通信的一块共享存储文件，又叫pipe文件。<br>向管道提供输入的发送进程以字符流形式将达量的数据送入管道，而接收管道输出的接收进程则从管道中接收数据。<br>这种方式是UNIX系统IPC最古老的形式。</p>
<p>为了协调双方的通信，他必须提供一下三个功能的协调能力：</p>
<ol>
<li>互斥</li>
<li>同步</li>
<li>确定对方是否存在</li>
</ol>
<h2 id="4-1-3-消息传递系统"><a href="#4-1-3-消息传递系统" class="headerlink" title="4.1.3 消息传递系统"></a>4.1.3 消息传递系统</h2><p>在这种方式下，集成不再借助任何共享存储区或数据结构，而是以格式化的消息(Message)为单位，将通信的数据封装在消息中，并利用操作系统提供的一组通信命令，在进程间进行消息传递，完成进程间的数据交换。</p>
<p>该方式隐藏了通信实现细节，使通信过程对用户透明化，降低了通信程序设计的复杂性和错误率，成为当前应用最为广泛的一类进程间的通信机制.</p>
<h2 id="4-1-4-客户机-服务器系统"><a href="#4-1-4-客户机-服务器系统" class="headerlink" title="4.1.4 客户机-服务器系统"></a>4.1.4 客户机-服务器系统</h2><p>前面的几种通信系统，虽然也可以用于实现不同计算机间进程的双向通信，但是客户机-服务器系统的通信机制，在网络环境的各种应用领域已成为当前主流的通信实现机制，主要分为三类：套接字、远程过程调用和远程方法调用。在这就不多赘述了。</p>
<h1 id="4-2-线程"><a href="#4-2-线程" class="headerlink" title="4.2 线程"></a>4.2 线程</h1><h2 id="4-2-1-为什么要引入线程"><a href="#4-2-1-为什么要引入线程" class="headerlink" title="4.2.1 为什么要引入线程"></a>4.2.1 为什么要引入线程</h2><p>我们都知道，进程有两个基本属性：①进程是一个可拥有资源的独立单位，一个进程要能独立运行，他必须拥有一定的数据结构。②进程同时又是一个可独立调度和分派的基本单位。</p>
<p>为了程序能并发执行，系统必须能进行创建进程、撤销进程和切换进程操作。但是由于进程是资源的拥有者，所以在上述这些操作中，系统必须为之付出较大的时空开销。这就限制了系统中所设置进程的数目，而且进程切换也不宜过于频繁，从而限制了并发程度的进一步提高。</p>
<h2 id="4-2-2-线程的概念"><a href="#4-2-2-线程的概念" class="headerlink" title="4.2.2 线程的概念"></a>4.2.2 线程的概念</h2><p>在上述原因下，引入了线程的概念。学者们将进程的两个属性分开，让作为调度和分派的基本单位不拥有资源，让拥有资源的基本单倍不被频繁的调度。这样的话，就形成了线程的概念。</p>
<p>下面我们从6个方面来比较下进和线程：</p>
<ol>
<li>调度的基本单位<br> 传统OS中，进程是作为独立调度的基本单位，每次调度时，都需要上下文切换，开销大。在引入了线程的OS中，线程是作为独立调度的基本单位，线程切换时只需要保存和设置少量的寄存器内容，切换代价远小于进程。</li>
<li>并发性<br> 在引入线程的OS中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可以并发执行，甚至还允许在一个进程中的所有线程都能并发执行。</li>
<li>拥有资源<br> 进程可以拥有资源，而且还是系统中拥有资源的一个基本单位。但是线程本身并不拥有资源，而是仅有一点必不可少的、能保证独立运行的资源。</li>
<li>独立性<br> 同一进程中的线程之间的独立性比不同进程间的独立性低得多。</li>
<li>系统开销<br> 进程切换需要大量的系统开销，而线程间则需要的很少</li>
<li>支持多处理机系统<br> 在多处理机系统中，对于传统进程，不管有多少处理机，该进程只能运行在一个处理机上。但是对于多线程进程，可以将一个进程中的多个线程分配到多个处理机上。</li>
</ol>
<h2 id="4-2-3-线程的状态和线程控制块"><a href="#4-2-3-线程的状态和线程控制块" class="headerlink" title="4.2.3 线程的状态和线程控制块"></a>4.2.3 线程的状态和线程控制块</h2><p>与进程一样，线程也拥有三个状态和线程控制块。</p>
<h3 id="4-2-3-1-线程运行的三个状态"><a href="#4-2-3-1-线程运行的三个状态" class="headerlink" title="4.2.3.1 线程运行的三个状态"></a>4.2.3.1 线程运行的三个状态</h3><p>线程的三个状态和进程类似。</p>
<ol>
<li>运行状态，表示线程已获得处理机而正在运行。</li>
<li>就绪状态，表示线程已具备各种执行条件，只须再获得CPU便可立即执行。</li>
<li>阻塞状态，只线程在执行中因某事件受阻而处于暂停状态。</li>
</ol>
<h3 id="4-2-3-2-线程控制块TCB"><a href="#4-2-3-2-线程控制块TCB" class="headerlink" title="4.2.3.2 线程控制块TCB"></a>4.2.3.2 线程控制块TCB</h3><p>线程控制块用来纪录用于控制和管理线程的信息。<br>线程控制块中通常由这几项：</p>
<ol>
<li>线程标识符，为每个线程设置唯一地标识符。</li>
<li>一组寄存器，包括程序计数器PC、状态寄存器和通用寄存器的内容。</li>
<li>线程运行状态，用于描述线程正处于何种运行状态。</li>
<li>优先级，描述线程执行的优先程度。</li>
<li>线程专有存储区，用于线程切换时存放现场保护信息，和与该线程相关的统计信息等。</li>
<li>信号屏蔽，即对某些信号加以屏蔽。</li>
<li>堆栈指针。</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统5--处理机调度</title>
    <url>/posts/8b4e2673.html</url>
    <content><![CDATA[<blockquote>
<p>大家可以看下我使用幕布软件画的<a href="https://mubu.com/doc/3Pf0zwzrgw">思维导图</a>，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员<a href="https://mubu.com/inv/477598">https://mubu.com/inv/477598</a><br><span id="more"></span></p>
</blockquote>
<p>在多道程序中，调度的实质是一种资源分配，处理机调度是对处理机资源进行分配。</p>
<h1 id="5-1-处理机调度的层次和调度算法的目标"><a href="#5-1-处理机调度的层次和调度算法的目标" class="headerlink" title="5.1 处理机调度的层次和调度算法的目标"></a>5.1 处理机调度的层次和调度算法的目标</h1><p>在多道批处理系统中，一个作业从提交到获得处理机执行，直至作业运行完成，可能需要经历多次处理机调度。</p>
<h2 id="5-1-1-处理机调度的层次"><a href="#5-1-1-处理机调度的层次" class="headerlink" title="5.1.1 处理机调度的层次"></a>5.1.1 处理机调度的层次</h2><ol>
<li><p>高级调度<br> 高级调度又称为长程调度或作业调度，他的调度对象是作业。主要功能是根据某种算法，决定将外存上处于后备队列中的哪几个作业调入内存、为他们创建进程，分配必要的资源，并将他们放入就绪队列。</p>
</li>
<li><p>低级调度<br> 低级调度又称为短程调度或作业调度，他的调度对象是进程。主要功能是根据某种算法，决定就绪队列中哪个进程应获得处理机，并由分派程序将处理机分配给被选中的进程。</p>
</li>
<li><p>中级调度<br> 中级调度又称为内存调度。主要功能是将那些暂时不能运行的进程，调至外存等待，当他们具备运行条件且内存又稍有空闲时再调入内存。</p>
</li>
</ol>
<h2 id="5-1-2-处理机调度算法的目标"><a href="#5-1-2-处理机调度算法的目标" class="headerlink" title="5.1.2 处理机调度算法的目标"></a>5.1.2 处理机调度算法的目标</h2><h3 id="5-1-2-1-处理机调度算法的共同目标"><a href="#5-1-2-1-处理机调度算法的共同目标" class="headerlink" title="5.1.2.1 处理机调度算法的共同目标"></a>5.1.2.1 处理机调度算法的共同目标</h3><ol>
<li>资源利用率<br> 系统中的处理机和其它所有资源应尽可能保持忙碌状态，其中最重要的处理机利用率可用以下方式计算：<script type="math/tex; mode=display">CPU的利用率=\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}</script></li>
<li>公平性<br> 系统中的所有的进程都应该获得合理的CPU时间，不会发生进程饥饿现象。，对同类型的进程获得相同的服务；不同类型的进程，由于紧急程度不同或者重要性不同，应提供不同的服务。</li>
<li><p>平衡性<br> 系统中可能具有多种类型的进程，有的是计算型作业，有的是I/O型作业。为了使CPU和资源尽可能的处于忙碌状态，调度算法应尽可能的保持系统资源使用的平衡性。</p>
</li>
<li><p>策略强制执行<br> 对所定制的策略，只要需要，就必须准确的执行。</p>
</li>
</ol>
<h3 id="5-1-2-2-批处理系统的目标"><a href="#5-1-2-2-批处理系统的目标" class="headerlink" title="5.1.2.2 批处理系统的目标"></a>5.1.2.2 批处理系统的目标</h3><ol>
<li>平均周转时间段<br> 周转时间，是指从作业被提交给系统，直到作业执行完毕所花费的时间。<br> 对于每个用户来言，都希望自己的周转时间最短；但是对于系统来言，他要求的是平均周转时间最短，这不仅可以提高系统资源的利用率，而且还可使大多数用户都感到满意。<br> 可把周转时间描述为：<script type="math/tex; mode=display">T=\frac{1}{n}[\sum_{i=1}^{n}{T_i}]</script> 为了进一步反应调度的性能，更清楚的描述各进程在其周转时间中，等待和执行时间的具体分配情况，往往使用带权周转时间，即作业周转时间T与系统为他提供的时间Ts之比，即$ W=\frac{T}{T_s} $，平均带权周转时间可表示为：<script type="math/tex; mode=display">W = \frac{1}{n}\sum_{i=1}^{n}\frac{T_i}{T_s}</script></li>
<li><p>系统吞吐量高</p>
</li>
<li><p>处理机利用率高</p>
</li>
</ol>
<h3 id="5-1-2-3-分时系统的目标"><a href="#5-1-2-3-分时系统的目标" class="headerlink" title="5.1.2.3 分时系统的目标"></a>5.1.2.3 分时系统的目标</h3><ol>
<li><p>相应事时间快<br> 响应时间是指从用户通过键盘提交一个请求开始，直到屏幕上显示出处理结果为之的一段时间间隔，它包括三部分时间：一是请求信息从键盘输入开始，直至将其传送到处理机的时间；二是处理机对请求信息进行处理的时间；三是将所形成的的响应信息回送到终端显示器的时间。</p>
</li>
<li><p>均衡性<br> 用户对响应时间的要求并非完全相同。通常，用户对于复杂的的作业，响应时间允许较长；对于简单的作业，响应时间则要短。</p>
</li>
</ol>
<h3 id="5-1-2-4-实时系统的目标"><a href="#5-1-2-4-实时系统的目标" class="headerlink" title="5.1.2.4 实时系统的目标"></a>5.1.2.4 实时系统的目标</h3><ol>
<li>截止时间的保证<br> 截止时间是指某任务必须开始执行的最迟时间，或者必须完成的最迟时间。</li>
<li>可预测性</li>
</ol>
<h1 id="5-2-作业与作业调度"><a href="#5-2-作业与作业调度" class="headerlink" title="5.2 作业与作业调度"></a>5.2 作业与作业调度</h1><p>我们前面讲到过，在多道批处理系统中，作业由用户提交给系统操作员，再由系统操作员把作业输入给相应的输入设备，并保存在一个后备队列中，然后就由作业调度程序将其从外存调入内存再来进行处理。</p>
<h2 id="5-2-1-作业"><a href="#5-2-1-作业" class="headerlink" title="5.2.1 作业"></a>5.2.1 作业</h2><h3 id="5-2-1-1-作业和作业步"><a href="#5-2-1-1-作业和作业步" class="headerlink" title="5.2.1.1 作业和作业步"></a>5.2.1.1 作业和作业步</h3><ol>
<li><p>作业<br> 作业一般包括程序还数据，还应配有一份作业说明书，系统根据该说明书来对程序的运行进行控制。</p>
</li>
<li><p>作业步<br> 在作业运行期间，每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤才能得到结果。我们把其中的每一个加工步骤称为一个作业步。</p>
</li>
</ol>
<h3 id="5-2-1-2-作业控制块JCB"><a href="#5-2-1-2-作业控制块JCB" class="headerlink" title="5.2.1.2 作业控制块JCB"></a>5.2.1.2 作业控制块JCB</h3><p>为了管理和调度作业，在多道批处理系统中，为每个作业设置了一个作业控制块JCB，她是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。<br>通常内容有作业标识、用户名称、用户账号、作业类型、作业状态、调度信息、资源需求、资源使用情况等。</p>
<h3 id="5-2-1-3-作业运行的三个阶段和三种状态"><a href="#5-2-1-3-作业运行的三个阶段和三种状态" class="headerlink" title="5.2.1.3 作业运行的三个阶段和三种状态"></a>5.2.1.3 作业运行的三个阶段和三种状态</h3><ol>
<li>收容阶段<br> 操作员把用户提交的作业通过某种输入方式或SPOOLing系统输入到硬盘上，再为改作业建立PCB，并把它放入作业后备队列中。作业此时的状态为<strong>后备状态</strong></li>
<li>运行阶段<br> 当作业被作业调度选中后，变为它分配必要的资源和建立进程，并将它放入就绪队列。一个作业从第一次进入就绪状态开始，知道他运行结束前，都处于<strong>运行状态</strong></li>
<li>完成阶段<br> 当作业运行完成，或者发生异常情况提前结束时，作业便进入完成阶段，相应的作业状态为“完成状态”。</li>
</ol>
<h2 id="5-2-2-作业调度的主要任务"><a href="#5-2-2-作业调度的主要任务" class="headerlink" title="5.2.2 作业调度的主要任务"></a>5.2.2 作业调度的主要任务</h2><p>作业调度的主要任务就是根据JCB中的内容，检查系统中的资源能否满足作业对资源的需求，以及按照一定的调度算法，从外存的后备队列中选取某些作业调入内存。并为它们创建进程、分配必要的资源。然后再将新创建的进程排在就绪队列上等待调度。因此，也把作业调度称为接纳调度。在每次执行作业调度时，都需要做出以下两个决定：</p>
<ol>
<li>接纳多少个作业<br> 在每一次作业调度时，应当从后备队列中选取多少作业调入内存，取决于多道程序度，即允许多少个作业同时在内存中运行。</li>
<li>接纳哪些作业<br> 选择哪些作业取决于，作业调度采用哪种算法。</li>
</ol>
<h1 id="5-3-作业调度算法"><a href="#5-3-作业调度算法" class="headerlink" title="5.3 作业调度算法"></a>5.3 作业调度算法</h1><h2 id="5-3-1-先来先服务（FCFS）算法算法"><a href="#5-3-1-先来先服务（FCFS）算法算法" class="headerlink" title="5.3.1 先来先服务（FCFS）算法算法"></a>5.3.1 先来先服务（FCFS）算法算法</h2><p>对于这个算法，八个字——简单粗暴，没啥可讲。你来的早我就先服务你，其他人不管再牛逼你来晚了你就是弟弟，你得等我先把前面这位服务好了再来服务你。</p>
<h2 id="5-3-2-短作业优先（SJF）调度算法"><a href="#5-3-2-短作业优先（SJF）调度算法" class="headerlink" title="5.3.2 短作业优先（SJF）调度算法"></a>5.3.2 短作业优先（SJF）调度算法</h2><p>对于这个算法，他也是基于先来先服务，只是多了个考虑范围，就是原则上还是先到先服务，但是当服务完一个之后并且还有很多个再等着被服务时，就从中找一个需要服务时间最短的先来服务，服务完他了，在从剩下的找一个最短的来服务。<br>这个算法有几个缺点：</p>
<ol>
<li>必须预知作业的运行时间</li>
<li>对长作业很不利</li>
<li>人机无法交互</li>
<li>没有考虑作业执行的紧迫感，对急需服务的作业不管</li>
</ol>
<h2 id="5-3-3-优先级调度算法（PSA）"><a href="#5-3-3-优先级调度算法（PSA）" class="headerlink" title="5.3.3 优先级调度算法（PSA）"></a>5.3.3 优先级调度算法（PSA）</h2><p>在优先级算法中，基于作业的紧迫程度，外部会赋予进程的优先级，然后优先级算法就根据算法的优先级，进行调度。算法实质上类似于短作业优先，你甚至可以把短作业优先级算法也看做是优先级算法，只不过他的优先级是作业长短，而优先级调度算法的优先级是进程的紧迫程度。</p>
<h2 id="5-3-4-高响应比优先调度算法（HRRN）"><a href="#5-3-4-高响应比优先调度算法（HRRN）" class="headerlink" title="5.3.4 高响应比优先调度算法（HRRN）"></a>5.3.4 高响应比优先调度算法（HRRN）</h2><p>FCFS算法是考虑了作业的等待时间，却忽略的作业的运行时间；而SJF算法是只考虑了作业的运行时间，却忽略了作业的等待时间。高响应比算法是又考虑运行时间又考虑等待时间，因此既能照顾短作业，又不致使长作业的等待时间过长。</p>
<p>他为每个作业引入了一个动态优先级，即优先级是可以改变的，它随着等待时间的延长而增加，这使得长作业的优先级在等待期间不断地增加，等到足够的时间后，必然有机会获得处理机。这个变化规律可描述为：</p>
<script type="math/tex; mode=display">优先级=\frac{等待时间+要求服务时间}{要求服务时间}</script><p>由于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先级又相当于响应比$R_p$。所以，优先级又可表示为：<script type="math/tex">R_p=\frac{等待时间+要求服务时间}{要求服务时间}=\frac{响应时间}{要求服务时间}</script></p>
<p>从上面可以看出</p>
<ol>
<li>如果作业的等待时间相同，则要求服务的时间越短，优先级越高</li>
<li>当要求服务时间相同时，作业的优先级决定于其等待时间</li>
<li>对于长作业的优先级，可以随等待时间的增加而提高</li>
</ol>
<h1 id="5-4-进程调度"><a href="#5-4-进程调度" class="headerlink" title="5.4 进程调度"></a>5.4 进程调度</h1><h2 id="5-4-1-进程调度的任务、机制和方式"><a href="#5-4-1-进程调度的任务、机制和方式" class="headerlink" title="5.4.1 进程调度的任务、机制和方式"></a>5.4.1 进程调度的任务、机制和方式</h2><h3 id="5-4-1-1-进程调度的任务"><a href="#5-4-1-1-进程调度的任务" class="headerlink" title="5.4.1.1 进程调度的任务"></a>5.4.1.1 进程调度的任务</h3><ol>
<li>保存处理机的现场信息<br> 在进行调度时首先需要保存当前进程处理机的现场信息。</li>
<li>按某种算法选取进程<br> 调度程序按某种算法从就绪队列中选取一个进程，将其状态改为运行状态，并准备把处理机分配给他。</li>
<li>把处理机分配给进程<br> 由分派程序把处理器分配给该进程，此时需要将选中进程的进程控制块内有关处理机现场的信息装入处理器相应的各个寄存器中，把处理器的控制权交予该进程，让它从上次的断点处恢复运行。</li>
</ol>
<h3 id="5-4-1-2-进程调度机制"><a href="#5-4-1-2-进程调度机制" class="headerlink" title="5.4.1.2 进程调度机制"></a>5.4.1.2 进程调度机制</h3><p>为了实现进程调度，在进程调度机制中，应具有如下三个基本部分：<br><img src="https://cdn.littlecorgi.top/mweb/进程调度机制.jpg" alt="进程调度机制"></p>
<ol>
<li>排队器<br>为了提高进程调度的效率，应事先将系统中的所有就绪进程按照一定的策略排成一个或多个队列，以便调度程序能最快的找到它。</li>
<li>分派器<br>分派器依据进程调度程序所选定的进程，将其从就绪队列中取出，然后进行从分派器到新选出进程间的上下文切换，将处理机分配给新选出的进程。</li>
<li>上下文切换器<br>在对处理机进行切换时，会发生两对上下文的切换操作<ol>
<li>对上下文切换时，OS将保存当前进程的上下文，即把当前进程的处理机寄存器的内容保存到该进程的进程控制块中的相应单元，再装入分派程序的上下文，以便分派程序运行</li>
<li>对上下文切换是移除分派程序的上下文，而把新选进程的CPU现场信息装入到处理机的各个相应寄存器中，以便新选进程运行</li>
</ol>
</li>
</ol>
<h3 id="5-4-1-3-进程调度方式"><a href="#5-4-1-3-进程调度方式" class="headerlink" title="5.4.1.3 进程调度方式"></a>5.4.1.3 进程调度方式</h3><ol>
<li>非抢占方式<br> 在这种方式下，一旦处理机分派给一个进程后，就一次性一直处理下去，直到该进程被处理完。</li>
<li>抢占方式<br> 这种调度方式允许调度程序根据某种原则，去暂停某个正在执行的程序，将已分配给该进程的处理机重新分配给另一进程。<br> 它遵循的主要原则有：<ol>
<li>优先权原则，优先级高的新到进程抢占正在运行的优先级低的进程</li>
<li>短进程优先原则，需要运行时间更短的新到进程抢占正在运行的需要运行时间更长的进程</li>
<li>时间片原则，各进程按时间片轮转运行，当正在执行的进程的一个时间片用完后，便停止该进程的执行而重新进行调度</li>
</ol>
</li>
</ol>
<h2 id="5-4-2-轮转调度算法"><a href="#5-4-2-轮转调度算法" class="headerlink" title="5.4.2 轮转调度算法"></a>5.4.2 轮转调度算法</h2><p>在分时系统中，最常用也是最简单的就是基于时间片的轮转调度算法。该算法采取了非常公平的处理机分配方式，即让就绪队列上每个进程每次仅运行一个时间片。n个进程每个都运行$\frac{1}{n}$的处理机时间。</p>
<h3 id="5-4-2-1-基本原理"><a href="#5-4-2-1-基本原理" class="headerlink" title="5.4.2.1 基本原理"></a>5.4.2.1 基本原理</h3><p>在RR算法中，系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并可设置每隔一定时间间隔即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其执行。</p>
<h3 id="5-4-2-2-进程切换时机"><a href="#5-4-2-2-进程切换时机" class="headerlink" title="5.4.2.2 进程切换时机"></a>5.4.2.2 进程切换时机</h3><ol>
<li>如果一个时间片尚未用完但是正在运行的进程已经完成，此时可以切换</li>
<li>在一个时间片用完，正在执行的进程还未执行完成，这时也可以切换</li>
</ol>
<h3 id="5-4-2-3-时间片大小的确定"><a href="#5-4-2-3-时间片大小的确定" class="headerlink" title="5.4.2.3 时间片大小的确定"></a>5.4.2.3 时间片大小的确定</h3><p>在RR算法中，时间片的大小对系统性能有很大的影响。<br>如果选择很小的时间片，有利于短作业，因为他能在该时间片内完成，但时间片小，意味着会频繁调度，这无疑会增加系统开销。<br><img src="https://cdn.littlecorgi.top/mweb/时间片小于交互时间.jpg" alt="时间片小于交互时间"></p>
<p>如果时间片选择太长，这样的话RR可能会退化成FCFS，无法满足短作业和交互式用户的需求。<br><img src="https://cdn.littlecorgi.top/mweb/时间片大于交互时间.jpg" alt="时间片大于交互时间"></p>
<h2 id="5-4-3-优先级调度算法"><a href="#5-4-3-优先级调度算法" class="headerlink" title="5.4.3 优先级调度算法"></a>5.4.3 优先级调度算法</h2><p>在RR算法中，我们假设了所有进程的紧迫性是相同的，但是实际情况并非如此。我们为了满足实际情况，在进程调度算法中引入了优先级，而形成的优先级调度算法。</p>
<h3 id="5-4-3-1-优先级调度算法的类型"><a href="#5-4-3-1-优先级调度算法的类型" class="headerlink" title="5.4.3.1 优先级调度算法的类型"></a>5.4.3.1 优先级调度算法的类型</h3><ol>
<li>非抢占式优先级调度算法</li>
<li>抢占式优先级调度算法</li>
</ol>
<p>这块和前面调度算法方式一样，在此就不多说。</p>
<h3 id="5-4-3-2-优先级类型"><a href="#5-4-3-2-优先级类型" class="headerlink" title="5.4.3.2 优先级类型"></a>5.4.3.2 优先级类型</h3><h4 id="5-4-3-2-1-静态优先级"><a href="#5-4-3-2-1-静态优先级" class="headerlink" title="5.4.3.2.1 静态优先级"></a>5.4.3.2.1 静态优先级</h4><p>静态优先级是在创建进程时确定的，在进程的整个运行期间保持不变。优先级是利用某一范围内的一个整数来表示的。确定进程优先级大小的依据有如下三个：</p>
<ol>
<li>进程类型，通常系统进程的优先级一般高于用户进程。</li>
<li>进程对资源的需求，对资源要求较少的进程应赋予较高的优先级。</li>
<li>用户要求，根据进程的紧迫程度及用户所付费用的多少确定优先级。</li>
</ol>
<p>静态优先级法简单易行，系统开销小，但是不够精确，可能会出现优先级低的进程长期没有被调度的情况。</p>
<h4 id="5-4-3-2-2-动态优先级"><a href="#5-4-3-2-2-动态优先级" class="headerlink" title="5.4.3.2.2 动态优先级"></a>5.4.3.2.2 动态优先级</h4><p>动态优先级是指进程创建之初，先赋予一个优先级，然后根据进程的推进或等待时间的增加而改变，以便获得更好的调度性能。</p>
<h2 id="5-4-4-多队列调度算法"><a href="#5-4-4-多队列调度算法" class="headerlink" title="5.4.4 多队列调度算法"></a>5.4.4 多队列调度算法</h2><p>之前所述的各种调度算法，在应用于进程调度时，由于系统中仅设置一个进程的就绪队列，即低级调度的算法是单一的，固定的，无法满足系统中不同用户对进程调度策略的不同要求，在多处理机系统中，这种单一调度策略实现机制缺点更加明显。因此多级队列算法能够在一定程度上弥补这一缺点。</p>
<p>多级队列算法将进程就绪队列拆分成若干个，不同的就绪队列采用不同的调度算算法，所以可以很好的满足不同用户对进程调度策略的不同需求，同时也可以满足多处理机系统的需求。</p>
<h2 id="5-4-5-多级反馈队列调度算法"><a href="#5-4-5-多级反馈队列调度算法" class="headerlink" title="5.4.5 多级反馈队列调度算法"></a>5.4.5 多级反馈队列调度算法</h2><p>前面的算法都有一定的局限性，如果未指明进程长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而下述的多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，还可以很好地满足各种类型进程的需要，因而他是目前公认的一种较好的进程调度算法。</p>
<h3 id="5-4-5-1-调度机制"><a href="#5-4-5-1-调度机制" class="headerlink" title="5.4.5.1 调度机制"></a>5.4.5.1 调度机制</h3><ol>
<li><p>设置多个就绪队列。在系统中设置多个就绪队列，并未每个队列赋予不同的优先级。第一个队列的优先级最高，第二次之，其余队列的优先级逐个降低。该算法为不同队列中的进程所赋予的执行时间片的大小也不同，在优先级越高的队列中时间片越小。<br><img src="https://cdn.littlecorgi.top/mweb/多级反馈队列调度算法.jpg" alt="多级反馈队列调度算法"></p>
</li>
<li><p>每个队列都采用FCFS算法。当新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则等待调度。当轮到该进程时，如他能在时间片内完成，便可撤离系统，否则，他在一个时间片结束还未完成时，转入第二队列末尾等待，依次类推。</p>
</li>
<li>按队列优先级调度，首先调度最高优先级队列中的诸进程运行，仅当第一队列空闲时才调度第二队列。</li>
</ol>
<h3 id="5-4-5-2-调度算法的性能"><a href="#5-4-5-2-调度算法的性能" class="headerlink" title="5.4.5.2 调度算法的性能"></a>5.4.5.2 调度算法的性能</h3><p>在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互系统所需处理时间时，便能较好的满足各种类型用户的需要。 </p>
<h2 id="5-4-6-基于公平原则的调度算法"><a href="#5-4-6-基于公平原则的调度算法" class="headerlink" title="5.4.6 基于公平原则的调度算法"></a>5.4.6 基于公平原则的调度算法</h2><h3 id="5-4-6-1-保证调度算法"><a href="#5-4-6-1-保证调度算法" class="headerlink" title="5.4.6.1 保证调度算法"></a>5.4.6.1 保证调度算法</h3><p>保证调度算法是另一种类型的调度算法，它想用户所作出的保证并不是优先运行，而是明确的性能保证，该算法可以做到调度的公平性。一种比较容易的性能保证是处理机的公平性，如果在系统中有n个类型相同的进程同时运行，为了公平期间，每个进程都获得相同的处理机时间$\frac{1}{n}$。</p>
<p>在实施保证调度算法时，系统必须具备这样一些功能：</p>
<ol>
<li>跟踪计算每个进程自创建以来已经执行的处理时间。</li>
<li>计算每个进程应获得的处理机时间，即自创建以来的时间除以n。</li>
<li>计算进程获得处理机时间的比率，即进程实际执行的处理时间和应获得的处理机时间之比。</li>
<li>比较各进程获得处理机时间的比率。如进程A的比率最低，为0.5，而进程B的比率为0.8，进程C的比率为1.2等。</li>
<li>调度程序应选择比率最小的进程将处理机分配给它，并让该进程一直运行，直到超过最接近它的进程比率为止。</li>
</ol>
<h3 id="5-4-6-2-公平分享调度算法"><a href="#5-4-6-2-公平分享调度算法" class="headerlink" title="5.4.6.2 公平分享调度算法"></a>5.4.6.2 公平分享调度算法</h3><p>分配给每个进程相同的处理机时间，显然，这对诸进程而言，是体现了一定程度的公平，但如果各个用户所拥有的进程数不同，就会发生对用户的不公平问题。 在该算法中，调度的公平性是体针对于用户而言。使所有的用户获得相同的处理机时间，或要求的时间比例。</p>
<h1 id="5-5-实时调度"><a href="#5-5-实时调度" class="headerlink" title="5.5 实时调度"></a>5.5 实时调度</h1><h2 id="5-5-1-实现实时调度的基本条件"><a href="#5-5-1-实现实时调度的基本条件" class="headerlink" title="5.5.1 实现实时调度的基本条件"></a>5.5.1 实现实时调度的基本条件</h2><ol>
<li>提供必要的信息<ol>
<li>就绪时间，是指某任务称为就绪状态的时间，在周期任务的情况下，她是实现预知的一串时间序列。</li>
<li>开始截止时间和完成截止时间，对于典型的实时应用，只需知道开始截止时间或者完成截止时间</li>
<li>处理时间，一个任务从开始执行，直至完成时所需的时间</li>
<li>资源要求，任务执行时所需要的一组资源</li>
<li>优先级，如果某任务的开始截止时间错过，势必引起故障，则应为该任务赋予“绝对”优先级；如果其开始截止时间的错过，对任务的继续运行无重大影响，则可为其赋予“相对优先级”，供调度程序参考</li>
</ol>
</li>
<li>系统处理能力强<br> 在实时系统中，若处理机的处理能力不够强，则有可能因处理机忙不过，而致使某些实时任务不能得到及时处理，从而导致发生难以预料的后果。<br> 假定系统中有m个周期性的硬实时任务HRT，他们的处理时间可表示为$C<em>i$，周期时间表示为$P_i$，则在单处理机情况下，必须满足下面的限制条件系统才是可调度的：$$ \sum</em>{i=1}^{m}\frac{C<em>i}{P_i}\le1 <script type="math/tex">提高系统处理能力的途径有二：一是采用单处理机系统，但须增强其处理能力，以显著地减少对每一个任务的处理时间；二是采用多处理机系统。假定系统中的处理机数为N，则应将上述的限制条件改为：</script> \sum</em>{i=1}^{m}\frac{C_i}{P_i}\le N $$</li>
<li>采用抢占式调度机制<br> 在含有HRT任务的实时系统中，广泛采用抢占机制。这样便可满足HRT任务对截止时间的要求。但这种调度机制比较复杂。 对于一些小的实时系统，如果能够预知任务法开始截止时间，则对于实时任务的调度可以采用非抢占式调度。</li>
<li>具有快速切换机制<br> 为保证硬实时任务能及时运行，在系统中还应具有快速切换机制，使之能进行任务的快速切换。该机制应具有如下两方面的能力：<ol>
<li>对中断的快速响应能力。对紧迫的外部事件请求中断能及时响应，要求系统具有快速硬件中断机构，还应使禁止中断的时间间隔尽量短，以免耽误时机(其它紧迫任务)。</li>
<li>快速的任务分派能力。为了提高分派程序进行任务切换时的速度，应使系统中的每个运行功能单位适当的小，以减少任务切换的时间开销。</li>
</ol>
</li>
</ol>
<h2 id="5-5-2-实时调度算法的分类"><a href="#5-5-2-实时调度算法的分类" class="headerlink" title="5.5.2 实时调度算法的分类"></a>5.5.2 实时调度算法的分类</h2><h3 id="5-5-2-1-非抢占式调度算法"><a href="#5-5-2-1-非抢占式调度算法" class="headerlink" title="5.5.2.1 非抢占式调度算法"></a>5.5.2.1 非抢占式调度算法</h3><ol>
<li><p>非抢占式轮转调度算法<br> 由一台计算机控制若干个相同的对象，为每个被控对象建立一个实时任务。并将他们排成一个轮转队列。调度程序每次选择队列中的第一个任务投入运行，当该任务完成后，便把它挂在轮转队列的末尾等待，调度程序再选择下一个队首任务运行。</p>
</li>
<li><p>非抢占式优先调度算法<br> 如果在系统中还含有少数具有一定要求的实时任务，则可采用非抢占式优先调度算法，系统为这些任务赋予了较高的优先级。当这些实时任务到达时，把它们安排在就绪队列的队首，等待当前任务自我终止或运行完成后，便可去调度执行队首的高优先级进程。</p>
</li>
</ol>
<h3 id="5-5-2-2-抢占式调度算法"><a href="#5-5-2-2-抢占式调度算法" class="headerlink" title="5.5.2.2 抢占式调度算法"></a>5.5.2.2 抢占式调度算法</h3><ol>
<li><p>基于时钟中断的抢占式优先级调度算法。<br> 在某实时任务到达后，如果他的优先级高于当前任务的优先级，这是并不立即抢占当前任务的处理机，而是等到时钟中断发生时，调度程序才剥夺大年任务的执行，把处理机分配给新到的高优先级的任务。</p>
</li>
<li><p>立即抢占的优先级调度算法。<br> 在这种调度策略中，要求操作系统具有快速响应外部事件中断的能力，一旦出现外部中断，只要当前任务未处于临界区，便能立即剥夺当前任务的执行，把处理机分配给请求中断的紧迫任务。<br> <img src="https://cdn.littlecorgi.top/mweb/实时进程调度.png" alt="实时进程调度"></p>
</li>
</ol>
<h2 id="5-5-3-最早截止时间优先"><a href="#5-5-3-最早截止时间优先" class="headerlink" title="5.5.3 最早截止时间优先"></a>5.5.3 最早截止时间优先</h2><p>该算法是根据任务截止时间确定任务的优先级，任务的截止时间越早，其优先级越高，具有最早截止时间的任务排在队首。</p>
<h3 id="5-5-3-1-非抢占式调度方式用于非周期实时任务"><a href="#5-5-3-1-非抢占式调度方式用于非周期实时任务" class="headerlink" title="5.5.3.1 非抢占式调度方式用于非周期实时任务"></a>5.5.3.1 非抢占式调度方式用于非周期实时任务</h3><p><img src="https://cdn.littlecorgi.top/mweb/EDF算法用于非抢占式调度方法.jpg" alt="EDF算法用于非抢占式调度方法"></p>
<h3 id="5-5-3-2-抢占式调度方式用于非周期实时任务"><a href="#5-5-3-2-抢占式调度方式用于非周期实时任务" class="headerlink" title="5.5.3.2 抢占式调度方式用于非周期实时任务"></a>5.5.3.2 抢占式调度方式用于非周期实时任务</h3><p><img src="https://cdn.littlecorgi.top/mweb/最早截止时间优先算法用于抢占调度方式之例.png" alt="最早截止时间优先算法用于抢占调度方式之例"></p>
<h2 id="5-5-4-最低松弛度优先LLF算法"><a href="#5-5-4-最低松弛度优先LLF算法" class="headerlink" title="5.5.4 最低松弛度优先LLF算法"></a>5.5.4 最低松弛度优先LLF算法</h2><p>该算法在确定任务的优先级时，根据的是任务的紧急(或松弛)程度。任务紧急程度愈高，赋予该任务的优先级就愈高，以使之优先执行。 该方式主要用可抢占式调度。</p>
<p>假如在一个实时系统中有两个周期性实时任务A和B，任务A要求每20 ms执行一次，执行时间为10 ms，任务B要求每50 ms执行一次，执行时间为25 ms。由此可知，任务A和B每次必须完成的时间分别为：A1、A2、A3、…和B1、B2、B3、…，如下图<br><img src="https://cdn.littlecorgi.top/mweb/A任务和B任务每次必须完成的时间.png" alt="A任务和B任务每次必须完成的时间"></p>
<p>利用ELLF算法进行调度的情况：<br><img src="https://cdn.littlecorgi.top/mweb/利用ELLF算法进行调度的情况.png" alt="利用ELLF算法进行调度的情况"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统6--死锁</title>
    <url>/posts/68dc89d4.html</url>
    <content><![CDATA[<h1 id="6-1-死锁的引入"><a href="#6-1-死锁的引入" class="headerlink" title="6.1 死锁的引入"></a>6.1 死锁的引入</h1><p>在之前我们或多或少都涉及到了死锁，最直接的例子就是哲学家就餐筷子，如果每一个哲学家都拿起了他的右手的筷子，现在都在等左边的筷子。这样一直绕下去，从而产生了死锁。</p>
<span id="more"></span>
<h2 id="6-1-1-资源问题"><a href="#6-1-1-资源问题" class="headerlink" title="6.1.1 资源问题"></a>6.1.1 资源问题</h2><p>在系统中存在着很多不同类型的资源，其中可以引起的死锁的主要是需要采用互斥访问方法的、不可以被抢占的资源、</p>
<h3 id="6-1-1-1-可重用性资源和消耗性资源"><a href="#6-1-1-1-可重用性资源和消耗性资源" class="headerlink" title="6.1.1.1 可重用性资源和消耗性资源"></a>6.1.1.1 可重用性资源和消耗性资源</h3><h4 id="可重用性资源"><a href="#可重用性资源" class="headerlink" title="可重用性资源"></a>可重用性资源</h4><p>可重用性资源是一种可供用户重复使用多次的资源，它具有以下性质：</p>
<ol>
<li>每一个可重用性资源中的单位只能分配给一个进程使用，不允许多个进程共享</li>
<li>进程在使用可重用性资源时，须按照这样的顺序：请求资源 -&gt; 使用资源 -&gt; 释放资源</li>
<li>系统中每一类可重用性资源中的单元数目是相对固定的，进程在运行期间既不能创建也不能删除它</li>
</ol>
<h4 id="可消耗性资源"><a href="#可消耗性资源" class="headerlink" title="可消耗性资源"></a>可消耗性资源</h4><p>可消耗性资源又称为临时性资源，它是在进程运行期间，由进程动态的创建和消耗的，它具有以下性质：</p>
<ol>
<li>每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的，有时它可以有很多，有时可能为0</li>
<li>进程在运行过程中，可以不断地创造可消耗性资源的单元，将它们放入该资源类的缓冲区中，以增加该资源类的单元数目</li>
<li>进程在运行过程中，可以请求若干个可消耗性资源单元，用于进程自己的消耗，不再将它们返回给该资源类中</li>
</ol>
<h3 id="6-1-1-2-可抢占性资源和不可抢占性资源"><a href="#6-1-1-2-可抢占性资源和不可抢占性资源" class="headerlink" title="6.1.1.2 可抢占性资源和不可抢占性资源"></a>6.1.1.2 可抢占性资源和不可抢占性资源</h3><h4 id="可抢占性资源"><a href="#可抢占性资源" class="headerlink" title="可抢占性资源"></a>可抢占性资源</h4><p>可把系统中的资源分为两类，一类是可抢占性资源，是指某进程在获得这类资源后，该资源可以再被其它进程或系统抢占</p>
<h4 id="不可抢占性资源"><a href="#不可抢占性资源" class="headerlink" title="不可抢占性资源"></a>不可抢占性资源</h4><p>另一类资源是不可抢占资源，一旦系统把某资源分配给该进程之后，就不能将它强行回收，只能在进程用完后自行释放</p>
<h2 id="6-1-2-死锁的起因"><a href="#6-1-2-死锁的起因" class="headerlink" title="6.1.2 死锁的起因"></a>6.1.2 死锁的起因</h2><h3 id="6-1-2-1-竞争不可抢占性资源引起的死锁"><a href="#6-1-2-1-竞争不可抢占性资源引起的死锁" class="headerlink" title="6.1.2.1 竞争不可抢占性资源引起的死锁"></a>6.1.2.1 竞争不可抢占性资源引起的死锁</h3><p>通常系统中所拥有的不可抢占性资源其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局。</p>
<p>一个很简单的例子，进程$P_1$和$P_2$在并发执行，他们都要写两个文件$F_1$和$F_2$。其中$P_1$和$P_2$的代码分别为：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   P1</span><br><span class="line">  ....</span><br><span class="line">Open(f1, w);</span><br><span class="line">Open(f2, w);</span><br><span class="line"></span><br><span class="line">   P2</span><br><span class="line">  ....</span><br><span class="line">Open(f2, w);</span><br><span class="line">Open(f1, w);</span><br></pre></td></tr></table></figure></p>
<p>如果这两个进程在并发执行的时候，如果$P_1$先打开$F_1$和$F_2$，然后$P_2$才去打开$F_1$(或$F_2$)，由于文件$F_1$(或$F_2$)已经被打开，因此$P_2$会被阻塞。当$P_1$使用完$F_1$(或$F_2$)，这时$P_2$才可以去打开$F_1$(或$F_2$)，这样程序继续运行下去。</p>
<p>但是如果在$P_1$打开$F_1$的同时，$P_2$去打开$F_2$，每个进程都占有一个打开的文件，此时就可能出现问题。因为当$P_1$试图去打开$F_2$,而$F_2$试图去打开$F_1$时，这两个进程都会因文件已被打开而阻塞，因此这两个进程将会无限期地等待下去，从而形成死锁。<br><img src="https://cdn.littlecorgi.top/mweb/2019-09-19/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E6%97%B6%E7%9A%84%E6%AD%BB%E9%94%81%E6%83%85%E5%86%B5.png" alt="共享文件时的死锁情况"></p>
<h3 id="6-1-2-2-竞争可消耗资源引起的死锁"><a href="#6-1-2-2-竞争可消耗资源引起的死锁" class="headerlink" title="6.1.2.2 竞争可消耗资源引起的死锁"></a>6.1.2.2 竞争可消耗资源引起的死锁</h3><p><img src="https://cdn.littlecorgi.top/mweb/2019-09-19/%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%97%B6%E7%9A%84%E6%AD%BB%E9%94%81.png" alt="进程之间通信时的死锁"><br>如图所示，$m_1$、$m_3$、$m_3$是可消耗资源。进程$P_1$一方面产生消息$m_1$，利用<code>send(p2,m1)</code>将它发送给$P_2$，另一方面，有要求从$P_3$接受消息$m_2$；而$P_2$、$P_3$依次类推。</p>
<p>如果三个进程按以下顺序进行：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1:   ...send(p2, m1);    receive(p3, m3);...</span><br><span class="line">P2:   ...send(p3, m2);    receive(p1, m1);...</span><br><span class="line">P3:   ...send(p1, m3);    receive(p2, m2);...</span><br></pre></td></tr></table></figure><br>这三个进程都可以先将消息发送给下一个进程，相应地他们也都能都接收到从上一个进程发来的消息，因此三个进程都可以顺利的进行下去，不会发生死锁。</p>
<p>但是如果三个进程都先执行receive，在执行send，按下面的顺序运行：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1:   ...receive(p3, m3);    send(p2, m1);...</span><br><span class="line">P2:   ...receive(p1, m1);    send(p3, m2);...</span><br><span class="line">P3:   ...receive(p2, m2);    send(p1, m3);...</span><br></pre></td></tr></table></figure><br>那么这三个进程就会永远阻塞在它们的receive操作上，就会产生死锁。</p>
<h1 id="6-2-死锁的定义、必要条件和处理方法"><a href="#6-2-死锁的定义、必要条件和处理方法" class="headerlink" title="6.2 死锁的定义、必要条件和处理方法"></a>6.2 死锁的定义、必要条件和处理方法</h1><h2 id="6-2-1-死锁的定义"><a href="#6-2-1-死锁的定义" class="headerlink" title="6.2.1 死锁的定义"></a>6.2.1 死锁的定义</h2><p>如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的。</p>
<h2 id="6-2-2-产生死锁的必要条件"><a href="#6-2-2-产生死锁的必要条件" class="headerlink" title="6.2.2 产生死锁的必要条件"></a>6.2.2 产生死锁的必要条件</h2><p>产生死锁必须同时具备下面四个必要条件，只要其中任一个条件不成立，死锁就不会发生：</p>
<ol>
<li>互斥条件。进程对所分配的资源进行排他性使用。即该资源只允许一个进程使用，其他进程如果请求该资源只能等待。</li>
<li>请求和保持条件。进程已经保持一至少一个资源，但又提出了新的资源请求，而新资源已被其他进程占有，导致进程被阻塞。</li>
<li>不可抢占条件。 进程已获得的资源在为使用完之前不能被抢占，只有进程在使用完之后才能释放。</li>
<li>循环等待条件。发生死锁时，必然存在一个进程资源循环链，即进程集合$[P_0, P_1, P_2, ···, P_n]$中$P_0$正在等待一个$P_1$占用的资源，$P_1$正在等待一个$P_2$占用的资源，……，$P_n$正在等待一个$P_0$占用的资源</li>
</ol>
<h2 id="6-2-3-处理死锁的办法"><a href="#6-2-3-处理死锁的办法" class="headerlink" title="6.2.3 处理死锁的办法"></a>6.2.3 处理死锁的办法</h2><p>目前处理死锁的方法可归结为四种：</p>
<ol>
<li>预防死锁。通过设置某些限制，去破坏产生死锁四个必要条件中的一个或几个来预防死锁。</li>
<li>避免死锁。在资源的动态分配过程中，用某种方法阻止系统进入不安全状态，从而避免发生死锁。</li>
<li>检测死锁。该方法允许进程在运行过程中发生死锁，但可通过检测机构及时地检测出死锁的发生，然后采取适当措施，把进城从死锁中解脱出来。</li>
<li>解除死锁。当检测到系统中已发生死锁时，就采取相应措施，将进程从死锁状态中解脱出来。</li>
</ol>
<h1 id="6-3-预防死锁"><a href="#6-3-预防死锁" class="headerlink" title="6.3 预防死锁"></a>6.3 预防死锁</h1><p>预防死锁时通过破坏产生死锁四个必要条件中的一个或几个，以避免发生死锁。</p>
<h2 id="6-3-1-破坏“请求和保持”条件"><a href="#6-3-1-破坏“请求和保持”条件" class="headerlink" title="6.3.1 破坏“请求和保持”条件"></a>6.3.1 破坏“请求和保持”条件</h2><p>当一个进程在请求资源时，他不能持有不可抢占资源。可通过一下两种不同的协议实现：</p>
<h3 id="6-3-1-1-第一种协议"><a href="#6-3-1-1-第一种协议" class="headerlink" title="6.3.1.1 第一种协议"></a>6.3.1.1 第一种协议</h3><p>所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源。此时若系统中有足够的资源分配给某进程，便可把其需要的所有资源分配给它。这样，该进程在整个运行期间，便不会再提出资源要求，从而破坏了“请求”条件。系统在分配资源时，只要有一种资源不能满足进程的要求，即使其所需的其他资源都空闲也不分配给它，而让该进程等待。由于该进程在等待期间未占有任何资源，于是破坏了“保持”条件，从而可以预防死锁的发生。</p>
<p>这种协议的优点是简单、易行且安全。但是缺点也极其明显：</p>
<ol>
<li>资源被严重浪费，严重的恶化了资源的利用率。</li>
<li>使进程经常的发生饥饿现象。</li>
</ol>
<h3 id="6-3-1-2-第二种协议"><a href="#6-3-1-2-第二种协议" class="headerlink" title="6.3.1.2 第二种协议"></a>6.3.1.2 第二种协议</h3><p>该协议是对第一种协议的改进，它允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行的过程中再逐步释放已分配给自己的、且已用毕的全部资源，然后再请求新的所需资源。</p>
<h2 id="6-3-2-破坏“不可抢占”条件"><a href="#6-3-2-破坏“不可抢占”条件" class="headerlink" title="6.3.2 破坏“不可抢占”条件"></a>6.3.2 破坏“不可抢占”条件</h2><p>为了能破坏“不可抢占”条件，协议中规定，当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，他必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着进程已占有的资源会被暂时地释放，或者说是被抢占了，从而破坏了“不可抢占”条件。</p>
<h2 id="6-3-3-破坏“循环等待”条件"><a href="#6-3-3-破坏“循环等待”条件" class="headerlink" title="6.3.3 破坏“循环等待”条件"></a>6.3.3 破坏“循环等待”条件</h2><p>一个能保证“循环等待”条件不成立的方法是，对系统所有资源类型进行线性排序，并赋予不同的序号。排序后，便可以采用这样的预防协议：规定每个进程必须按照序号的地址顺序来请求资源。一个进程在开始时，可以请求资源$R_i$的单元，以后，当且仅当$F(R_j)&gt;F(R_i)$，进程才可以请求资源$R_j$。如果需要多个同类资源单元，则必须一起请求。</p>
<ul>
<li>优点：资源利用率和系统吞吐量都有比较明显的改善。</li>
<li>缺点：<ol>
<li>系统中各类资源所规定的序号必须稳定，这就限制了新类型设备的增加</li>
<li>可能会发生作业使用各类资源的顺序与系统规定的不同，造成资源的浪费。</li>
<li>这种按照规定次序申请资源的方法会限制用户简单，自主的编程。</li>
</ol>
</li>
</ul>
<h1 id="6-4-避免死锁"><a href="#6-4-避免死锁" class="headerlink" title="6.4 避免死锁"></a>6.4 避免死锁</h1><h2 id="6-4-1-系统安全状态"><a href="#6-4-1-系统安全状态" class="headerlink" title="6.4.1 系统安全状态"></a>6.4.1 系统安全状态</h2><p>在死锁避免方法中，把系统的状态分为安全状态和不安全状态。当系统处于安全状态时，可避免发生死锁。反之，当系统处于不安全状态时，则可能进入到死锁状态。</p>
<p>在该方法中，允许进程动态的申请资源吗，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，才可将资源分配给进程，否则，另进程等待。</p>
<p>安全状态是指系统能按某种进程推进顺序为每个进程分配其所需资源，直至满足每个进程对资源的最大需求。如果无法找到这样一个序列，则称系统处于不安全状态。</p>
<h2 id="6-4-2-利用银行家算法避免死锁"><a href="#6-4-2-利用银行家算法避免死锁" class="headerlink" title="6.4.2 利用银行家算法避免死锁"></a>6.4.2 利用银行家算法避免死锁</h2><p>为实现银行家算法，每一个新进程在进入系统时，他必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才分配资源。</p>
<h3 id="6-4-2-1-银行家算法中的数据结构"><a href="#6-4-2-1-银行家算法中的数据结构" class="headerlink" title="6.4.2.1 银行家算法中的数据结构"></a>6.4.2.1 银行家算法中的数据结构</h3><ol>
<li>可利用资源向量Available。代表系统中目前已有的可分配的该种资源的最大数。</li>
<li>最大需求矩阵Max。代表该进程对该资源的最大需求数。</li>
<li>分配矩阵Allocation。代表目前已经分配给该进程的该资源的数目。</li>
<li>需求矩阵Need。代表该进程还需要该资源的数目。</li>
</ol>
<h3 id="6-4-2-2-银行家算法"><a href="#6-4-2-2-银行家算法" class="headerlink" title="6.4.2.2 银行家算法"></a>6.4.2.2 银行家算法</h3><p>设$Request_i$是进程$P_i$的请求向量，如果$Request_i[j]=K$，表示进程$P_i$需要$K$个$R_j$类型的资源。当$P_i$发出资源请求后，系统按下述步骤进行检查：</p>
<ol>
<li>如果$Request_i[j] \le Need[i, j]$，便转向步骤2；否则任务出错，因为它所需要的资源数已超过它所宣布的最大值。</li>
<li>如果$Request_i[j] \le Available[j]$，便转向步骤3；否则，表示尚无足够资源，$P_i$需等待。</li>
<li>系统试探着把资源分配给进程$P_i$，并修改下面数据结构中的数值：$Available[j] = Available[j] - Request_i[j]$<br> $Allocation[i,j] = Allocation[i,j] + Request_i[j]$<br> $Need[i,j] = Need[i,j] - Request_i[j]$</li>
<li>系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程$P_i$，已完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程$P_i$等待。</li>
</ol>
<h3 id="6-4-2-3-安全性算法"><a href="#6-4-2-3-安全性算法" class="headerlink" title="6.4.2.3 安全性算法"></a>6.4.2.3 安全性算法</h3><ol>
<li>设置两个向量：①工作向量Work，他表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，$Word = Available$；②FInish：他表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做$Finish[i] = false$；当有足够资源分配给进程时，再令$Finish[i] = true$。</li>
<li>从进程集合中找到一个能满足下述条件的进程：①$Finish[i]=false$；②$Need[i,j] \le Work[j]$；若找到则执行步骤3，否则执行步骤4.</li>
<li>若进程$P_i$获得资源后，可顺利执行，直至完成，并释放出分配给他的资源，故应执行：<br> $Word[j] = Work[j] + Allocation[i,j];$<br> $Finish[i]=true;$<br> go to step 2;</li>
<li>如果所有进程的$Finish[i]=true$都满足，则表示系统处于安全状态；否则，系统处于不安全状态。</li>
</ol>
<h3 id="6-4-2-4-银行家算法例子"><a href="#6-4-2-4-银行家算法例子" class="headerlink" title="6.4.2.4 银行家算法例子"></a>6.4.2.4 银行家算法例子</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>假定系统中有五个进程${P_0, P_1, P_2, P_3, P_4}$和三类资源${A, B, C}$，各种资源的数量分别为10、5、7，在$T_0$时刻的资源分配情况如图所示：<br><img src="https://cdn.littlecorgi.top/mweb/2019-09-20/T0%E6%97%B6%E5%88%BB%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E8%A1%A8.png" alt="T0时刻的资源分配表"></p>
<h4 id="在-T-0-时刻的安全性"><a href="#在-T-0-时刻的安全性" class="headerlink" title="在$T_0$时刻的安全性"></a>在$T_0$时刻的安全性</h4><p>利用安全性算法对$T_0$时刻的资源分配情况进行分析可知，在$T_0$时刻存在着一个安全序列${P_1,P_3,P_4,P_2,P_0}$，故系统是安全的。<br><img src="https://cdn.littlecorgi.top/mweb/2019-09-20/T0%E6%97%B6%E5%88%BB%E7%9A%84%E5%AE%89%E5%85%A8%E5%BA%8F%E5%88%97.png" alt="T0时刻的安全序列"></p>
<h4 id="P-1-请求资源"><a href="#P-1-请求资源" class="headerlink" title="$P_1$请求资源"></a>$P_1$请求资源</h4><p>$P_1$发出请求向量$Request_1(1,0,2)$，系统按银行家算法进行检查：<br>①$Request_1(1,0,2) \le Need_1(1,2,2)$；<br>②$Request_1(1,0,2) \le Available_1(3,3,2)$；<br>③系统先假定可为$P_1$分配资源，并修改$Avaliable$，$Allocation_1$和$Need_1$向量，由此形成的资源变化情况如1图中的圆括号所示；<br>④再利用安全性算法检查此时系统是否安全，如图所示<br><img src="https://cdn.littlecorgi.top/mweb/2019-09-20/P1%E7%94%B3%E8%AF%B7%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%A3%80%E6%9F%A5.png" alt="P1申请资源时的安全性检查"></p>
<p>有所进行的安全性检查得知，可以找到一个安全序列${P_1,P_3,P_4,P_2,P_0}$。因此，系统是安全的，可以立即将$P_1$所申请的资源分配给它。</p>
<h4 id="P-4-请求资源"><a href="#P-4-请求资源" class="headerlink" title="$P_4$请求资源"></a>$P_4$请求资源</h4><p>$P_4$发出请求向量$Request_4(3,3,0)$，系统按银行家算法进行检查：<br>①$Request_4(3,3,0) \le Need_4(4,3,1)$；<br>②$Request_4(3,3,0) \ge Available(2,3,0)$，让$P_4$等待。</p>
<h4 id="P-0-请求资源"><a href="#P-0-请求资源" class="headerlink" title="$P_0$请求资源"></a>$P_0$请求资源</h4><p>$P_0$发出请求向量$Request_0(0,2,0)$，系统按银行家算法进行检查：<br>①$Request_0(0,2,0) \le Need_0(7,4,3)$；<br>②$Request_0(0,2,0) \le Available(2,3,0)$；<br>③系统暂时先假定可为$P_0$分配资源，并修改有关数据，如图所示。<br><img src="https://cdn.littlecorgi.top/mweb/2019-09-20/%E4%B8%BAP0%E5%88%86%E9%85%8D%E8%B5%84%E6%BA%90%E5%90%8E%E7%9A%84%E6%9C%89%E5%85%B3%E8%B5%84%E6%BA%90%E6%95%B0%E6%8D%AE.png" alt="为P0分配资源后的有关资源数据"></p>
<h4 id="进入安全性检查"><a href="#进入安全性检查" class="headerlink" title="进入安全性检查"></a>进入安全性检查</h4><p>可用资源$Available(2,1,0)$已不能满足任何进程的需要，故系统进入不安全状态，此时系统不分配资源。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>杂项</title>
    <url>/posts/bc8ba982.html</url>
    <content><![CDATA[<p>这篇博客主要讲解一下几个问题</p>
<ul>
<li>粗略地介绍一下View的事件分发机制</li>
<li>解决事件滑动冲突的思路及方法</li>
<li>ScrollView 里面嵌套ViewPager导致的滑动冲突</li>
<li>ViewPager里面嵌套ViewPager 导致的滑动冲突</li>
<li>轮播图的几种实现方式</li>
</ul>
<h2 id="先看一下效果图"><a href="#先看一下效果图" class="headerlink" title="先看一下效果图"></a>先看一下效果图</h2><h3 id="ScrollView里面嵌套ViewPager"><a href="#ScrollView里面嵌套ViewPager" class="headerlink" title="ScrollView里面嵌套ViewPager"></a>ScrollView里面嵌套ViewPager</h3><p><img src="https://user-gold-cdn.xitu.io/2019/10/21/16dee435507efb1f?imageslim" alt=""></p>
<h3 id="ViewPager里面嵌套ViewPager"><a href="#ViewPager里面嵌套ViewPager" class="headerlink" title="ViewPager里面嵌套ViewPager"></a>ViewPager里面嵌套ViewPager</h3><p><img src="https://user-gold-cdn.xitu.io/2019/10/21/16dee43550cd196c?imageslim" alt=""></p>
<hr>
<h2 id="View的-事件分发机制"><a href="#View的-事件分发机制" class="headerlink" title="View的 事件分发机制"></a>View的 事件分发机制</h2><p>这篇博客大打算详细讲解View的事件分发机制，因为网上已经出现了一系列的好 文章，我自己的水平也有限，目前肯定写得不咋的。</p>
<p>先啰嗦一下，View 的事件分发机制主要涉及到一下三个 方法</p>
<ul>
<li>dispatchTouchEvent ，这个方法主要是用来分发事件的</li>
<li>onInterceptTouchEvent，这个方法主要是用来拦截事件的（需要注意的是ViewGroup才有这个方法，View没有onInterceptTouchEvent这个方法</li>
<li>onTouchEvent这个方法主要是用来处理事件的</li>
<li>requestDisallowInterceptTouchEvent(true)，这个方法能够影响父View是否拦截事件，true表示 不拦截事件，false表示拦截事件</li>
</ul>
<h3 id="下面引用图解-Android-事件分发机制这一篇博客的内容"><a href="#下面引用图解-Android-事件分发机制这一篇博客的内容" class="headerlink" title="下面引用图解 Android 事件分发机制这一篇博客的内容"></a>下面引用<a href="https://www.jianshu.com/p/e99b5e8bd67b">图解 Android 事件分发机制</a>这一篇博客的内容</h3><p><img src="https://user-gold-cdn.xitu.io/2019/10/21/16dee4355a83aa4e?imageslim" alt=""></p>
<blockquote>
<ul>
<li>仔细看的话，图分为3层，从上往下依次是Activity、ViewGroup、View</li>
<li>事件从左上角那个白色箭头开始，由Activity的dispatchTouchEvent做分发</li>
<li>箭头的上面字代表方法返回值，（return true、return false、return super.xxxxx(),super 的意思是调用父类实现。</li>
<li>dispatchTouchEvent和 onTouchEvent的框里有个【true——&gt;消费】的字，表示的意思是如果方法返回true，那么代表事件就此消费，不会继续往别的地方传了，事件终止。</li>
<li>目前所有的图的事件是针对ACTION_DOWN的，对于ACTION_MOVE和ACTION_UP我们最后做分析。</li>
<li>之前图中的Activity 的dispatchTouchEvent 有误（图已修复），只有return super.dispatchTouchEvent(ev) 才是往下走，返回true 或者 false 事件就被消费了（终止传递）。</li>
</ul>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当TouchEvent发生时，首先Activity将TouchEvent传递给最顶层的View，TouchEvent最先到达最顶层 view 的 dispatchTouchEvent ，然后由 dispatchTouchEvent 方法进行分发，</p>
<ul>
<li><p>如果dispatchTouchEvent返回true 消费事件，事件终结。</p>
</li>
<li><p>如果dispatchTouchEvent返回 false ，则回传给父View的onTouchEvent事件处理；</p>
<blockquote>
<p>onTouchEvent事件返回true，事件终结，返回false，交给父View的OnTouchEvent方法处理</p>
</blockquote>
</li>
<li><p>如果dispatchTouchEvent返回super的话，默认会调用自己的onInterceptTouchEvent方法</p>
<blockquote>
<p>默认的情况下interceptTouchEvent回调用super方法，super方法默认返回false，所以会交给子View的onDispatchTouchEvent方法处理</p>
<p>如果 interceptTouchEvent 返回 true ，也就是拦截掉了，则交给它的 onTouchEvent 来处理，</p>
<p>如果 interceptTouchEvent 返回 false ，那么就传递给子 view ，由子 view 的 dispatchTouchEvent 再来开始这个事件的分发。</p>
</blockquote>
</li>
</ul>
<p>关于更多详细分析，请查看原博客<a href="https://www.jianshu.com/p/e99b5e8bd67b">图解 Android 事件分发机制</a>，真心推荐，写得很好。</p>
<hr>
<h2 id="解决事件滑动冲突的思路及方法"><a href="#解决事件滑动冲突的思路及方法" class="headerlink" title="解决事件滑动冲突的思路及方法"></a>解决事件滑动冲突的思路及方法</h2><h3 id="常见的三种情况"><a href="#常见的三种情况" class="headerlink" title="常见的三种情况"></a>常见的三种情况</h3><p>第一种情况，滑动方向不同</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/21/16dee4355c4af671?imageslim" alt=""></p>
<p>第二种情况，滑动方向相同</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/21/16dee4355c396312?imageslim" alt=""></p>
<p>第三种情况，上述两种情况的嵌套</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/21/16dee43589ee1059?imageslim" alt=""></p>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>看了上面三种情况，我们知道他们的共同特点是父View 和子View都想争着响应我们的触摸事件，但遗憾的是我们的触摸事件 同一时刻只能被某一个View或者ViewGroup拦截消费，所以就产生了滑动冲突？那既然同一时刻只能由某一个View或者ViewGroup消费拦截，那我们就只需要 决定在某个时刻由这个View或者ViewGroup拦截事件，另外的 某个时刻 有另外一个View或者ViewGroup拦截事件不就OK了吗？综上，正如 在 <em><strong>《Android开发艺术》</strong></em> 一书提出的，总共 有两种接觉方案</p>
<p>以下解决思路来自于 <em><strong>《Android开发艺术》</strong></em> 书籍</p>
<p><strong>下面的两种方法针对第一种情况（滑动方向不同），父View是上下滑动，子View是左右滑动的情况。</strong></p>
<h3 id="外部解决法"><a href="#外部解决法" class="headerlink" title="外部解决法"></a>外部解决法</h3><p>从父View着手，重写onInterceptTouchEvent方法，在父View需要拦截的时候拦截，不要的时候返回false，为代码大概 如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> <span class="variable">x</span> <span class="operator">=</span> ev.getX();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> <span class="variable">y</span> <span class="operator">=</span> ev.getY();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> ev.getAction();</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            mDownPosX = x;</span><br><span class="line">            mDownPosY = y;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">final</span> <span class="type">float</span> <span class="variable">deltaX</span> <span class="operator">=</span> Math.abs(x - mDownPosX);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">float</span> <span class="variable">deltaY</span> <span class="operator">=</span> Math.abs(y - mDownPosY);</span><br><span class="line">            <span class="comment">// 这里是够拦截的判断依据是左右滑动，读者可根据自己的逻辑进行是否拦截</span></span><br><span class="line">            <span class="keyword">if</span> (deltaX &gt; deltaY) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="内部解决法"><a href="#内部解决法" class="headerlink" title="内部解决法"></a>内部解决法</h3><p>从子View左右，父View先不要拦截任何事件，所有的 事件传递给 子View，如果子View需要此事件就消费掉，不需要此事件的话就交给 父View处理。</p>
<p>实现思路 如下，重写子 View的dispatchTouchEvent方法，在Action_down 动作中通过方法 requestDisallowInterceptTouchEvent（true） 先请求 父 View不要拦截事件，这样保证 子View能够 接受到Action_move事件，再在Action_move动作中根据 自己的逻辑是否要拦截事件，不要的 话交给 父View处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) ev.getRawX();</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) ev.getRawY();</span><br><span class="line">    <span class="type">int</span> <span class="variable">dealtX</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dealtY</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            dealtX = <span class="number">0</span>;</span><br><span class="line">            dealtY = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            getParent().requestDisallowInterceptTouchEvent(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            dealtX += Math.abs(x - lastX);</span><br><span class="line">            dealtY += Math.abs(y - lastY);</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;dealtX:=&quot;</span> + dealtX);</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;dealtY:=&quot;</span> + dealtY);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (dealtX &gt;= dealtY) &#123;</span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            lastX = x;</span><br><span class="line">            lastY = y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="ScrollView-里面嵌套ViewPager导致的滑动冲突"><a href="#ScrollView-里面嵌套ViewPager导致的滑动冲突" class="headerlink" title="ScrollView 里面嵌套ViewPager导致的滑动冲突"></a>ScrollView 里面嵌套ViewPager导致的滑动冲突</h2><h3 id="外部解决法-1"><a href="#外部解决法-1" class="headerlink" title="外部解决法"></a>外部解决法</h3><p>如上面所述，从 父ViewScrollView着手，重写 OnInterceptTouchEvent方法，在上下滑动的时候拦截事件，在左右滑动的时候不拦截事件，返回 false，这样确保子View 的dispatchTouchEvent方法会被调用，代码 如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ explain:这个ScrlloView不拦截水平滑动事件，</span></span><br><span class="line"><span class="comment"> * 是用来解决 ScrollView里面嵌套ViewPager使用的</span></span><br><span class="line"><span class="comment"> * @ author：xujun on 2016/10/25 15:28</span></span><br><span class="line"><span class="comment"> * @ email：gdutxiaoxu@163.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VerticalScrollView</span> <span class="keyword">extends</span> <span class="title class_">ScrollView</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VerticalScrollView</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VerticalScrollView</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VerticalScrollView</span><span class="params">(Context context, AttributeSet attrs, <span class="type">int</span> defStyleAttr)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TargetApi(21)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VerticalScrollView</span><span class="params">(Context context, AttributeSet attrs, <span class="type">int</span> defStyleAttr, <span class="type">int</span></span></span><br><span class="line"><span class="params">            defStyleRes)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="variable">mDownPosX</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="variable">mDownPosY</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">x</span> <span class="operator">=</span> ev.getX();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">y</span> <span class="operator">=</span> ev.getY();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> ev.getAction();</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                mDownPosX = x;</span><br><span class="line">                mDownPosY = y;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="keyword">final</span> <span class="type">float</span> <span class="variable">deltaX</span> <span class="operator">=</span> Math.abs(x - mDownPosX);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">float</span> <span class="variable">deltaY</span> <span class="operator">=</span> Math.abs(y - mDownPosY);</span><br><span class="line">                <span class="comment">// 这里是够拦截的判断依据是左右滑动，读者可根据自己的逻辑进行是否拦截</span></span><br><span class="line">                <span class="keyword">if</span> (deltaX &gt; deltaY) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内部解决法-1"><a href="#内部解决法-1" class="headerlink" title="内部解决法"></a>内部解决法</h3><p>如上面上述，通过requestDisallowInterceptTouchEvent(true)方法来影响父View是否拦截事件，我们通过重写ViewPager的 dispatchTouchEvent（）方法，在左右滑动的时候请求父View ScrollView不要拦截事件，其他的时候拦截事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyViewPager</span> <span class="keyword">extends</span> <span class="title class_">ViewPager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;xujun&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastX</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastY</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyViewPager</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyViewPager</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) ev.getRawX();</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) ev.getRawY();</span><br><span class="line">        <span class="type">int</span> <span class="variable">dealtX</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dealtY</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                dealtX = <span class="number">0</span>;</span><br><span class="line">                dealtY = <span class="number">0</span>;</span><br><span class="line">                </span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                dealtX += Math.abs(x - lastX);</span><br><span class="line">                dealtY += Math.abs(y - lastY);</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;dealtX:=&quot;</span> + dealtX);</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;dealtY:=&quot;</span> + dealtY);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (dealtX &gt;= dealtY) &#123;</span><br><span class="line">                    getParent().requestDisallowInterceptTouchEvent(<span class="literal">true</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    getParent().requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                lastX = x;</span><br><span class="line">                lastY = y;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意事项（坑）"><a href="#注意事项（坑）" class="headerlink" title="注意事项（坑）"></a><strong>注意事项（坑）</strong></h2><p>当我们ScrollView的最上层的Layout里面多多个孩子的时候，当下面一个孩子是RecyclerView或者ListView的时候，往往会活动滑动到ListView或者RecyclerView 的第一个item，导致进入界面的时候会导致RecyclerView 上面的 View被滑动到界面意外，看不见，这时候的用户体验是比较差的</p>
<p>即结构如下面的时候</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/21/16dee4359404fd20?imageslim" alt=""></p>
<h3 id="在Activity中的相关解决方法"><a href="#在Activity中的相关解决方法" class="headerlink" title="在Activity中的相关解决方法"></a>在Activity中的相关解决方法</h3><p>于是我查找了相关的资料，在Activity中完美解决，主要要一下两种方法</p>
<p>第一种方法，重写Activity的onWindowFocusChanged（）方法，在里面调用mNoHorizontalScrollView.scrollTo(0,0);方法，滑动到顶部，因为onWindowFocusChanged是在所有View绘制完毕的时候才会回调的，不熟悉的话建议先回去看一下Activity的生命周期的相关介绍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scroll</span><span class="params">()</span> &#123;</span><br><span class="line">    mNoHorizontalScrollView.scrollTo(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onWindowFocusChanged</span><span class="params">(<span class="type">boolean</span> hasFocus)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onWindowFocusChanged(hasFocus);</span><br><span class="line">    <span class="keyword">if</span>(hasFocus  &amp;&amp; first)&#123;</span><br><span class="line">        first=<span class="literal">false</span>;</span><br><span class="line">        scroll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种解决方法，调用RecyclerView上面的View的一下方法，让其获取焦点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">view.setFocusable(<span class="literal">true</span>);  </span><br><span class="line">view.setFocusableInTouchMode(<span class="literal">true</span>);  </span><br><span class="line">view.requestFocus();</span><br></pre></td></tr></table></figure>
<p>这段代码在初始化的时候就让该界面的顶部的某一个控件获得焦点，滚动条自然就显示到顶部了。</p>
<h3 id="在Fragment中的相关解决方法"><a href="#在Fragment中的相关解决方法" class="headerlink" title="在Fragment中的相关解决方法"></a>在Fragment中的相关解决方法</h3><p>同样是调用第二种方法，调用RecyclerView上面的View的一下方法，让其获取焦点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">view.setFocusable(<span class="literal">true</span>);  </span><br><span class="line">view.setFocusableInTouchMode(<span class="literal">true</span>);  </span><br><span class="line">view.requestFocus();</span><br></pre></td></tr></table></figure>
<p>这段代码在初始化的时候就让该界面的顶部的某一个控件获得焦点，滚动条自然就显示到顶部了。但是给方法存在缺点，就是当我们上面的view如果滑动到一半的时候，切换到下一个Fragment，在切换回来的时候，RecyclerView的第一个item会自动滑动到顶部。目前我还没有找到相对比较好的解决这个问题的方法，大家知道相关解决方法的话也欢迎联系我，可以加我 微信或者在留言区评论，谢谢</p>
<h4 id="个人疑点"><a href="#个人疑点" class="headerlink" title="个人疑点"></a><strong>个人疑点</strong></h4><p>借鉴于解决Activity的方法，目前我还没有找到一个方法是在Fragemnt界面完全绘制完毕以后回调的方法，如果大家知道怎样处理的 话，欢迎大家提出来</p>
<hr>
<h2 id="ViewPager里面嵌套ViewPager导致的滑动冲突"><a href="#ViewPager里面嵌套ViewPager导致的滑动冲突" class="headerlink" title="ViewPager里面嵌套ViewPager导致的滑动冲突"></a>ViewPager里面嵌套ViewPager导致的滑动冲突</h2><h3 id="内部解决法-2"><a href="#内部解决法-2" class="headerlink" title="内部解决法"></a>内部解决法</h3><p>从子View ViewPager着手，重写 子View的 dispatchTouchEvent方法，在子 View需要拦截的时候进行拦截，否则交给父View处理，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildViewPager</span> <span class="keyword">extends</span> <span class="title class_">ViewPager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;xujun&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChildViewPager</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChildViewPager</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="type">int</span> curPosition;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                curPosition = <span class="built_in">this</span>.getCurrentItem();</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.getAdapter().getCount();</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;curPosition:=&quot;</span> +curPosition);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (curPosition == count - <span class="number">1</span>|| curPosition==<span class="number">0</span>) &#123;</span><br><span class="line">                    getParent().requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    getParent().requestDisallowInterceptTouchEvent(<span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="外部解决法-2"><a href="#外部解决法-2" class="headerlink" title="外部解决法"></a>外部解决法</h3><p>这个如果要采用内部解决法来解决的话想，相对很麻烦，我提一下自己的个人思路，我们可以先测量子View在哪个区域，然后我们在根据我们按下的点是否在区域以内，如果是的话，在根据子View时候需要拦截进行处理</p>
<hr>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/21/16dee43a1d305e5c?imageslim" alt=""></p>
<p>对于这种效果，上面是轮播图的，下面是RecyclerView或者ListView的，一般有一下几种实现方式</p>
<ul>
<li>使用我们上述提高的ScrollView里面嵌套ViewPager和RecyclerView，这种实现方式需要自己解决View滑动事件的冲突，同时还有我在上述提高的在Fragment中存在的问题</li>
<li>使用listView的addHeaderView来实现，或者是通过多种不同的item来实现</li>
<li>使用RecyclerView添加headerView来实现，或者复用多种不同的item来实现。关于RecyclerView如何添加headerView可以参考鸿洋大神的这一篇博客 <a href="https://blog.csdn.net/lmj623565791/article/details/51854533">Android 优雅的为RecyclerView添加HeaderView和FooterView</a></li>
<li>使用SupportLibrary中的CoordinatorLayout等控件</li>
</ul>
<p>其布局文件如下，Activity代码见项目中的SixActivity</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.CoordinatorLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@android:color/background_light&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.AppBarLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;300dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fitsSystemWindows</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">android.support.design.widget.CollapsingToolbarLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_scrollFlags</span>=<span class="string">&quot;scroll|snap&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">android.support.v4.view.ViewPager</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">&quot;@+id/viewPager&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            &gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">android.support.v4.view.ViewPager</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_page&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_gravity</span>=<span class="string">&quot;bottom&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:gravity</span>=<span class="string">&quot;right&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:text</span>=<span class="string">&quot;1/10&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:textColor</span>=<span class="string">&quot;#000&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">android.support.design.widget.CollapsingToolbarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.design.widget.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/recyclerView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_behavior</span>=<span class="string">&quot;@string/appbar_scrolling_view_behavior&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.v7.widget.RecyclerView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.design.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于CoordinatorLayout的更多用法，可以参考我的这一篇博客<a href="https://blog.csdn.net/gdutxiaoxu/article/details/52858598">使用CoordinatorLayout打造各种炫酷的效果</a></p>
<hr>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>当我们滑动方向不同的时候，采用外部解决法和内部解决法，复杂度差不多。</li>
<li>当我们滑动的方向相同的话，建议采用内部解决法来解决，因为采用外部解决法复杂度比较高。而且有时候我们是采用别人的开源控件，这时候去修改别人的源码可能会发生一些意想不到的bug。</li>
</ul>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><ul>
<li>在这篇博客的最后提高的实现轮播图+list列表的几种实现形式，刚开始是不想写的，后面因为ScrollView里面嵌套ViewPager和RecyclerView在fragment中RecyclerView抢占焦点，在某些情况下用户体验不好，才写出来的，跟这篇博客要讲解的View滑动事件冲突没有多大关系，只是给读者提供多种思路而已</li>
<li>至于CoordinatorLayout，是google IO 2015中提出来的，功能很强大，可以说是专门为了解决嵌套导滑动而产生的，极大地方便了开发者，对于初学者，可以暂时不必掌握它，先把其他的基础学好就好</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM-Reference源码</title>
    <url>/posts/79199b37.html</url>
    <content><![CDATA[<h1 id="Reference源码分析"><a href="#Reference源码分析" class="headerlink" title="Reference源码分析"></a>Reference源码分析</h1><blockquote>
<p>  本文基于JDK1.8.0_271分析，native源码下载自<a href="http://jdk.java.net/java-se-ri/8-MR3">openJDK官网(build 1.8.0_41-b04)</a></p>
</blockquote>
<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>JDK1.2开始，引入了一个新的包，<code>java.lang.ref</code>：</p>
<blockquote>
<ul>
<li>java.lang.ref<ul>
<li>Finalizer.class</li>
<li>FinalizerHistogram.class</li>
<li>FinalReference.class</li>
<li>PhantomReference.class</li>
<li>Reference.class</li>
<li>ReferenceQueue.class</li>
<li>SoftReference.classs</li>
<li>WeakReference.class</li>
</ul>
</li>
<li>额外的还有一个在sun.misc包下<ul>
<li>Cleaner.class</li>
</ul>
</li>
</ul>
</blockquote>
<p>随之带来了四个新的概念：</p>
<ul>
<li>强引用Storn References：随处可见，我们直接new出来的代码就是强引用。内存不足时，宁愿抛出<code>OutOfMemoryError</code>也不愿意回收这些对象。我们可以手动的设置为null让GC回收他。</li>
<li>软引用SoftReference：等级比强引用低，只有在内存不足的时候才回去回收。我们可以实现内存敏感的高速缓存。</li>
<li>弱引用WeakReference：等级比软引用低，不管内存足不足，发生GC时，就有可能被回收。如果这个对象是一个偶尔使用的对象，并且需要在使用的时候就能获取到，但又不想影响生命周期，就可以使用WeakReference，比如处理内部类内存泄漏的问题时。</li>
<li>虚引用PhantomReference：等级比弱引用低，形同虚设，任何时候都可能被回收。它可以和引用队列配合用于监控对象是否被回收</li>
</ul>
<span id="more"></span>
<p>并且，除了强引用之外，其他三个都可以和引用队列配合使用，就是在调用他们的构造方法时，除了传入Object外，还可以传入一个ReferenceQueue，他的作用就是当Object被回收时，JVM会自动帮我们把这个软/弱/虚引用添加到这个Queue中。通过这个功能可以监控对象是否被回收。</p>
<p>直到JDK8为止，只存在四种引用，这些引用是由JVM创建，因此直接继承<code>java.lang.ref.Reference</code>创建自定义的引用类型是无效的，但是可以直接继承已经存在的引用类型，如<code>sun.misc.Cleaner</code>就是继承自<code>java.lang.ref.PhantomReference</code>。</p>
<p>接下来我们就可以源码，但是在此之前，我们得带着问题看：</p>
<ul>
<li>软引用是内存不足才会回收，那么什么叫内存不足？</li>
<li>弱引用只要发生GC时就回收，但是他不是引用着对应的强引用，那么他为啥能被回收？</li>
<li>虚引用形同虚设，任何时候都会被回收，那么到底什么时候会被回收？</li>
<li>当引用对象被回收时，他们是怎么被添加到若引用队列的？</li>
</ul>
<h1 id="1-Reference-java"><a href="#1-Reference-java" class="headerlink" title="1. Reference.java"></a>1. Reference.java</h1><h2 id="1-1-源码"><a href="#1-1-源码" class="headerlink" title="1.1 源码"></a>1.1 源码</h2><p>首先来看下他的构造方法和成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Reference</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T referent;         <span class="comment">/* Treated specially by GC */</span></span><br><span class="line">		<span class="keyword">volatile</span> ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; queue;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    <span class="keyword">volatile</span> Reference next;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">private</span> Reference&lt;T&gt; discovered;  <span class="comment">/* used by VM */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Lock</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Reference&lt;Object&gt; pending = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    Reference(T referent) &#123;</span><br><span class="line">        <span class="built_in">this</span>(referent, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Reference(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; queue) &#123;</span><br><span class="line">        <span class="built_in">this</span>.referent = referent;</span><br><span class="line">        <span class="built_in">this</span>.queue = (queue == <span class="literal">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-1-构造方法"><a href="#1-1-1-构造方法" class="headerlink" title="1.1.1 构造方法"></a>1.1.1 构造方法</h3><p>构造方法有两种，一种只传入referent，另一种还要传入一个Queue，如果传入的queue为null的话，成员变量queue就等于<code>ReferenceQueue.NULL</code>。</p>
<h3 id="1-1-2-成员变量"><a href="#1-1-2-成员变量" class="headerlink" title="1.1.2 成员变量"></a>1.1.2 成员变量</h3><ul>
<li><p>reference：代表我们传入的对象。</p>
</li>
<li><p>queue: ReferenceQueue，就是引用队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; queue;</span><br></pre></td></tr></table></figure>
</li>
<li><p>next：下一个Reference实例的引用，主要是在ReferenceQueue中使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* When active:   NULL</span></span><br><span class="line"><span class="comment"> *     pending:   this</span></span><br><span class="line"><span class="comment"> *    Enqueued:   next reference in queue (or this if last)</span></span><br><span class="line"><span class="comment"> *    Inactive:   this</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line"><span class="keyword">volatile</span> Reference next;</span><br></pre></td></tr></table></figure>
</li>
<li><p>discovered：注意这个属性由transient修饰，基于状态表示不同链表中的下一个待处理的对象，主要是PendingList的下一个元素，通过JVM直接调用赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* When active:   next element in a discovered reference list maintained by GC (or this if last)</span></span><br><span class="line"><span class="comment"> *     pending:   next element in the pending list (or null if last)</span></span><br><span class="line"><span class="comment"> *   otherwise:   NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Reference&lt;T&gt; discovered;</span><br></pre></td></tr></table></figure>
</li>
<li><p>lock: 线程安全的锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Object used to synchronize with the garbage collector.  The collector</span></span><br><span class="line"><span class="comment"> * must acquire this lock at the beginning of each collection cycle.  It is</span></span><br><span class="line"><span class="comment"> * therefore critical that any code holding this lock complete as quickly</span></span><br><span class="line"><span class="comment"> * as possible, allocate no new objects, and avoid calling user code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Lock</span> &#123; &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>pending：等待加入queue的Reference对象，在GC时由JVM设置，会有一个java层的线程(ReferenceHandler)源源不断从PendingList中取出元素加入到queue中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* List of References waiting to be enqueued.  The collector adds</span></span><br><span class="line"><span class="comment"> * References to this list, while the Reference-handler thread removes</span></span><br><span class="line"><span class="comment"> * them.  This list is protected by the above lock object. The</span></span><br><span class="line"><span class="comment"> * list uses the discovered field to link its elements.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Reference&lt;Object&gt; pending = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-1-3-方法"><a href="#1-1-3-方法" class="headerlink" title="1.1.3 方法"></a>1.1.3 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns this reference object&#x27;s referent.  If this reference object has</span></span><br><span class="line"><span class="comment"> * been cleared, either by the program or by the garbage collector, then</span></span><br><span class="line"><span class="comment"> * this method returns &lt;code&gt;null&lt;/code&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>   The object to which this reference refers, or</span></span><br><span class="line"><span class="comment"> *           &lt;code&gt;null&lt;/code&gt; if this reference object has been cleared</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 获取referent实例</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.referent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Clears this reference object.  Invoking this method will not cause this</span></span><br><span class="line"><span class="comment"> * object to be enqueued.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This method is invoked only by Java code; when the garbage collector</span></span><br><span class="line"><span class="comment"> * clears references it does so directly, without invoking this method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 清除referent实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.referent = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Queue operations -- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tells whether or not this reference object has been enqueued, either by</span></span><br><span class="line"><span class="comment"> * the program or by the garbage collector.  If this reference object was</span></span><br><span class="line"><span class="comment"> * not registered with a queue when it was created, then this method will</span></span><br><span class="line"><span class="comment"> * always return &lt;code&gt;false&lt;/code&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>   &lt;code&gt;true&lt;/code&gt; if and only if this reference object has</span></span><br><span class="line"><span class="comment"> *           been enqueued</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 判断引用队列是否处于ENQUEUED状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnqueued</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>.queue == ReferenceQueue.ENQUEUED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds this reference object to the queue with which it is registered,</span></span><br><span class="line"><span class="comment"> * if any.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This method is invoked only by Java code; when the garbage collector</span></span><br><span class="line"><span class="comment"> * enqueues references it does so directly, without invoking this method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>   &lt;code&gt;true&lt;/code&gt; if this reference object was successfully</span></span><br><span class="line"><span class="comment"> *           enqueued; &lt;code&gt;false&lt;/code&gt; if it was already enqueued or if</span></span><br><span class="line"><span class="comment"> *           it was not registered with a queue when it was created</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">enqueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.queue.enqueue(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-ReferenceHandler线程"><a href="#1-2-ReferenceHandler线程" class="headerlink" title="1.2 ReferenceHandler线程"></a>1.2 ReferenceHandler线程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* High-priority thread to enqueue pending References</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReferenceHandler</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">// 确保该类已经加载完成，原理就是通过forName去提前加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ensureClassInitialized</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(clazz.getName(), <span class="literal">true</span>, clazz.getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Error) <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(e.getMessage()).initCause(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// pre-load and initialize InterruptedException and Cleaner classes</span></span><br><span class="line">        <span class="comment">// so that we don&#x27;t get into trouble later in the run loop if there&#x27;s</span></span><br><span class="line">        <span class="comment">// memory shortage while loading/initializing them lazily.</span></span><br><span class="line">      	<span class="comment">// 提前加载这两个类</span></span><br><span class="line">        ensureClassInitialized(InterruptedException.class);</span><br><span class="line">        ensureClassInitialized(Cleaner.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">        <span class="built_in">super</span>(g, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          	<span class="comment">// 死循环调用此方法</span></span><br><span class="line">            tryHandlePending(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码很简单，这个线程的主要作用就是不断的去调用<code>tryHandlePending()</code>方法</p>
<p>我们再看看他的启动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  	<span class="comment">// 大致意思就是获取当前线程组的上一层线程组，一层层获取上去，直到最高层的线程组，再去创建ReferenceHandler，以保证他被创建在JVM的system线程组中</span></span><br><span class="line">    <span class="type">ThreadGroup</span> <span class="variable">tg</span> <span class="operator">=</span> Thread.currentThread().getThreadGroup();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">ThreadGroup</span> <span class="variable">tgn</span> <span class="operator">=</span> tg;</span><br><span class="line">         tgn != <span class="literal">null</span>;</span><br><span class="line">         tg = tgn, tgn = tg.getParent());</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceHandler</span>(tg, <span class="string">&quot;Reference Handler&quot;</span>);</span><br><span class="line">    <span class="comment">/* If there were a special system-only priority greater than</span></span><br><span class="line"><span class="comment">     * MAX_PRIORITY, it would be used here</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  	<span class="comment">// 设置高优先级</span></span><br><span class="line">    handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">  	<span class="comment">// 设置为守护线程</span></span><br><span class="line">    handler.setDaemon(<span class="literal">true</span>);</span><br><span class="line">  	<span class="comment">// 启动</span></span><br><span class="line">    handler.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// provide access in SharedSecrets</span></span><br><span class="line">    SharedSecrets.setJavaLangRefAccess(<span class="keyword">new</span> <span class="title class_">JavaLangRefAccess</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryHandlePendingReference</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> tryHandlePending(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-核心方法：tryHandlePending"><a href="#1-3-核心方法：tryHandlePending" class="headerlink" title="1.3 核心方法：tryHandlePending"></a>1.3 核心方法：tryHandlePending</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Try handle pending &#123;<span class="doctag">@link</span> Reference&#125; if there is one.&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Return &#123;<span class="doctag">@code</span> true&#125; as a hint that there might be another</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Reference&#125; pending or &#123;<span class="doctag">@code</span> false&#125; when there are no more pending</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Reference&#125;s at the moment and the program can do some other</span></span><br><span class="line"><span class="comment"> * useful work instead of looping.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> waitForNotify if &#123;<span class="doctag">@code</span> true&#125; and there was no pending</span></span><br><span class="line"><span class="comment"> *                      &#123;<span class="doctag">@link</span> Reference&#125;, wait until notified from VM</span></span><br><span class="line"><span class="comment"> *                      or interrupted; if &#123;<span class="doctag">@code</span> false&#125;, return immediately</span></span><br><span class="line"><span class="comment"> *                      when there is no pending &#123;<span class="doctag">@link</span> Reference&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there was a &#123;<span class="doctag">@link</span> Reference&#125; pending and it</span></span><br><span class="line"><span class="comment"> *         was processed, or we waited for notification and either got it</span></span><br><span class="line"><span class="comment"> *         or thread was interrupted before being notified;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">tryHandlePending</span><span class="params">(<span class="type">boolean</span> waitForNotify)</span> &#123;</span><br><span class="line">    Reference&lt;Object&gt; r;</span><br><span class="line">    Cleaner c;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">// 加锁，保证线程安全</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pending != <span class="literal">null</span>) &#123;</span><br><span class="line">                r = pending;</span><br><span class="line">                <span class="comment">// &#x27;instanceof&#x27; might throw OutOfMemoryError sometimes</span></span><br><span class="line">                <span class="comment">// so do this before un-linking &#x27;r&#x27; from the &#x27;pending&#x27; chain...</span></span><br><span class="line">              	<span class="comment">// 判断是不是Cleaner，如果是，后续有特殊处理</span></span><br><span class="line">                c = r <span class="keyword">instanceof</span> Cleaner ? (Cleaner) r : <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// unlink &#x27;r&#x27; from &#x27;pending&#x27; chain</span></span><br><span class="line">              	<span class="comment">// 再指向下一个元素，并将当前元素置空，熟悉的链表的处理</span></span><br><span class="line">                pending = r.discovered;</span><br><span class="line">                r.discovered = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">// 如果pending不为null的话，则证明当前没有元素要被加入到queue了，则挂起当前线程，也就是ReferenceHandler</span></span><br><span class="line">                <span class="comment">// The waiting on the lock may cause an OutOfMemoryError</span></span><br><span class="line">                <span class="comment">// because it may try to allocate exception objects.</span></span><br><span class="line">                <span class="keyword">if</span> (waitForNotify) &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// retry if waited</span></span><br><span class="line">                <span class="keyword">return</span> waitForNotify;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        <span class="comment">// Give other threads CPU time so they hopefully drop some live references</span></span><br><span class="line">        <span class="comment">// and GC reclaims some space.</span></span><br><span class="line">        <span class="comment">// Also prevent CPU intensive spinning in case &#x27;r instanceof Cleaner&#x27; above</span></span><br><span class="line">        <span class="comment">// persistently throws OOME for some time...</span></span><br><span class="line">        Thread.<span class="keyword">yield</span>();</span><br><span class="line">        <span class="comment">// retry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">        <span class="comment">// retry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fast path for cleaners</span></span><br><span class="line">  	<span class="comment">// 如果是Cleaner，则调用clear进行回收</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="literal">null</span>) &#123;</span><br><span class="line">        c.clean();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 如果Reference有queue，则加入进去</span></span><br><span class="line">    ReferenceQueue&lt;? <span class="built_in">super</span> Object&gt; q = r.queue;</span><br><span class="line">    <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码很好理解，就是线程死循环源源不断的从PendingList中取出pending，然后将其加入到ReferenceQueue中去，而PendingList又是根据discovered来移动的。</p>
<p>并且对于Cleaner类型有特别处理，当其指向的对象被回收时，会调用clean进行资源回收。</p>
<p>那么，我们知道了对pending的处理，那么，那些对象什么时候会被加入到PendingList中去呢？根据注释可以得知，我们需要从native层去找到答案。</p>
<h1 id="2-referenceProcessor-cpp"><a href="#2-referenceProcessor-cpp" class="headerlink" title="2. referenceProcessor.cpp"></a>2. referenceProcessor.cpp</h1><p>Reference对应的native代码主要在referenceProcessor.cpp文件中，这个文件在<code>hotspot\src\share\vm\memory</code>路径下。</p>
<p>加入PendingList的核心方法是<code>process_discovered_references()</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ReferenceProcessorStats <span class="title">ReferenceProcessor::process_discovered_references</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  BoolObjectClosure*           is_alive,</span></span></span><br><span class="line"><span class="params"><span class="function">  OopClosure*                  keep_alive,</span></span></span><br><span class="line"><span class="params"><span class="function">  VoidClosure*                 complete_gc,</span></span></span><br><span class="line"><span class="params"><span class="function">  AbstractRefProcTaskExecutor* task_executor,</span></span></span><br><span class="line"><span class="params"><span class="function">  GCTimer*                     gc_timer,</span></span></span><br><span class="line"><span class="params"><span class="function">  GCId                         gc_id)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">NOT_PRODUCT</span>(<span class="built_in">verify_ok_to_handle_reflists</span>());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">enqueuing_is_done</span>(), <span class="string">&quot;If here enqueuing should not be complete&quot;</span>);</span><br><span class="line">  <span class="comment">// Stop treating discovered references specially.</span></span><br><span class="line">  <span class="built_in">disable_discovery</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If discovery was concurrent, someone could have modified</span></span><br><span class="line">  <span class="comment">// the value of the static field in the j.l.r.SoftReference</span></span><br><span class="line">  <span class="comment">// class that holds the soft reference timestamp clock using</span></span><br><span class="line">  <span class="comment">// reflection or Unsafe between when discovery was enabled and</span></span><br><span class="line">  <span class="comment">// now. Unconditionally update the static field in ReferenceProcessor</span></span><br><span class="line">  <span class="comment">// here so that we use the new value during processing of the</span></span><br><span class="line">  <span class="comment">// discovered soft refs.</span></span><br><span class="line"></span><br><span class="line">  _soft_ref_timestamp_clock = java_lang_ref_SoftReference::<span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> trace_time = PrintGCDetails &amp;&amp; PrintReferenceGC;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理软引用</span></span><br><span class="line">  <span class="comment">// Soft references</span></span><br><span class="line">  <span class="type">size_t</span> soft_count = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">GCTraceTime <span class="title">tt</span><span class="params">(<span class="string">&quot;SoftReference&quot;</span>, trace_time, <span class="literal">false</span>, gc_timer, gc_id)</span></span>;</span><br><span class="line">    soft_count =</span><br><span class="line">      <span class="built_in">process_discovered_reflist</span>(_discoveredSoftRefs, _current_soft_ref_policy, <span class="literal">true</span>,</span><br><span class="line">                                 is_alive, keep_alive, complete_gc, task_executor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">update_soft_ref_master_clock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理弱引用</span></span><br><span class="line">  <span class="comment">// Weak references</span></span><br><span class="line">  <span class="type">size_t</span> weak_count = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">GCTraceTime <span class="title">tt</span><span class="params">(<span class="string">&quot;WeakReference&quot;</span>, trace_time, <span class="literal">false</span>, gc_timer, gc_id)</span></span>;</span><br><span class="line">    weak_count =</span><br><span class="line">      <span class="built_in">process_discovered_reflist</span>(_discoveredWeakRefs, <span class="literal">NULL</span>, <span class="literal">true</span>,</span><br><span class="line">                                 is_alive, keep_alive, complete_gc, task_executor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Final references</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理虚引用</span></span><br><span class="line">  <span class="comment">// Phantom references</span></span><br><span class="line">  <span class="type">size_t</span> phantom_count = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">GCTraceTime <span class="title">tt</span><span class="params">(<span class="string">&quot;PhantomReference&quot;</span>, trace_time, <span class="literal">false</span>, gc_timer, gc_id)</span></span>;</span><br><span class="line">    phantom_count =</span><br><span class="line">      <span class="built_in">process_discovered_reflist</span>(_discoveredPhantomRefs, <span class="literal">NULL</span>, <span class="literal">false</span>,</span><br><span class="line">                                 is_alive, keep_alive, complete_gc, task_executor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process cleaners, but include them in phantom statistics.  We expect</span></span><br><span class="line">    <span class="comment">// Cleaner references to be temporary, and don&#x27;t want to deal with</span></span><br><span class="line">    <span class="comment">// possible incompatibilities arising from making it more visible.</span></span><br><span class="line">    phantom_count +=</span><br><span class="line">      <span class="built_in">process_discovered_reflist</span>(_discoveredCleanerRefs, <span class="literal">NULL</span>, <span class="literal">false</span>,</span><br><span class="line">                                 is_alive, keep_alive, complete_gc, task_executor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Weak global JNI references. It would make more sense (semantically) to</span></span><br><span class="line">  <span class="comment">// traverse these simultaneously with the regular weak references above, but</span></span><br><span class="line">  <span class="comment">// that is not how the JDK1.2 specification is. See #4126360. Native code can</span></span><br><span class="line">  <span class="comment">// thus use JNI weak references to circumvent the phantom references and</span></span><br><span class="line">  <span class="comment">// resurrect a &quot;post-mortem&quot; object.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">GCTraceTime <span class="title">tt</span><span class="params">(<span class="string">&quot;JNI Weak Reference&quot;</span>, trace_time, <span class="literal">false</span>, gc_timer, gc_id)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (task_executor != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      task_executor-&gt;<span class="built_in">set_single_threaded_mode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">process_phaseJNI</span>(is_alive, keep_alive, complete_gc);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ReferenceProcessorStats</span>(soft_count, weak_count, final_count, phantom_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面注释，我们可以看到大致的处理过程是：</p>
<ol>
<li>处理软引用</li>
<li>处理弱引用</li>
<li>处理需引用</li>
</ol>
<p>但是他们都调用了process_discovered_reflist这个方法，唯一的区别只是传入的refs_list不同。</p>
<h2 id="2-1-process-discovered-reflist"><a href="#2-1-process-discovered-reflist" class="headerlink" title="2.1 process_discovered_reflist()"></a>2.1 process_discovered_reflist()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span></span></span><br><span class="line"><span class="function"><span class="title">ReferenceProcessor::process_discovered_reflist</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  DiscoveredList               refs_lists[],</span></span></span><br><span class="line"><span class="params"><span class="function">  ReferencePolicy*             policy,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">bool</span>                         clear_referent,</span></span></span><br><span class="line"><span class="params"><span class="function">  BoolObjectClosure*           is_alive,</span></span></span><br><span class="line"><span class="params"><span class="function">  OopClosure*                  keep_alive,</span></span></span><br><span class="line"><span class="params"><span class="function">  VoidClosure*                 complete_gc,</span></span></span><br><span class="line"><span class="params"><span class="function">  AbstractRefProcTaskExecutor* task_executor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">bool</span> mt_processing = task_executor != <span class="literal">NULL</span> &amp;&amp; _processing_is_mt;</span><br><span class="line">  <span class="comment">// If discovery used MT and a dynamic number of GC threads, then</span></span><br><span class="line">  <span class="comment">// the queues must be balanced for correctness if fewer than the</span></span><br><span class="line">  <span class="comment">// maximum number of queues were used.  The number of queue used</span></span><br><span class="line">  <span class="comment">// during discovery may be different than the number to be used</span></span><br><span class="line">  <span class="comment">// for processing so don&#x27;t depend of _num_q &lt; _max_num_q as part</span></span><br><span class="line">  <span class="comment">// of the test.</span></span><br><span class="line">  <span class="type">bool</span> must_balance = _discovery_is_mt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((mt_processing &amp;&amp; ParallelRefProcBalancingEnabled) ||</span><br><span class="line">      must_balance) &#123;</span><br><span class="line">    <span class="built_in">balance_queues</span>(refs_lists);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> total_list_count = <span class="built_in">total_count</span>(refs_lists);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (PrintReferenceGC &amp;&amp; PrintGCDetails) &#123;</span><br><span class="line">    gclog_or_tty-&gt;<span class="built_in">print</span>(<span class="string">&quot;, %u refs&quot;</span>, total_list_count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Phase 1 (soft refs only):</span></span><br><span class="line">  <span class="comment">// . Traverse the list and remove any SoftReferences whose</span></span><br><span class="line">  <span class="comment">//   referents are not alive, but that should be kept alive for</span></span><br><span class="line">  <span class="comment">//   policy reasons. Keep alive the transitive closure of all</span></span><br><span class="line">  <span class="comment">//   such referents.</span></span><br><span class="line">  <span class="comment">// 只处理软引用</span></span><br><span class="line">  <span class="comment">// 将所有不存活但是还不能被回收的软引用从refs_lists中移除（只有refs_lists为软引用的时候，这里policy才不为null）</span></span><br><span class="line">  <span class="keyword">if</span> (policy != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mt_processing) &#123;</span><br><span class="line">      <span class="function">RefProcPhase1Task <span class="title">phase1</span><span class="params">(*<span class="keyword">this</span>, refs_lists, policy, <span class="literal">true</span> <span class="comment">/*marks_oops_alive*/</span>)</span></span>;</span><br><span class="line">      task_executor-&gt;<span class="built_in">execute</span>(phase1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; _max_num_q; i++) &#123;</span><br><span class="line">        <span class="built_in">process_phase1</span>(refs_lists[i], policy,</span><br><span class="line">                       is_alive, keep_alive, complete_gc);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// policy == NULL</span></span><br><span class="line">    <span class="built_in">assert</span>(refs_lists != _discoveredSoftRefs,</span><br><span class="line">           <span class="string">&quot;Policy must be specified for soft references.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Phase 2:</span></span><br><span class="line">  <span class="comment">// . Traverse the list and remove any refs whose referents are alive.</span></span><br><span class="line">  <span class="comment">// 移除所有指向对象还存活的引用</span></span><br><span class="line">  <span class="keyword">if</span> (mt_processing) &#123;</span><br><span class="line">    <span class="function">RefProcPhase2Task <span class="title">phase2</span><span class="params">(*<span class="keyword">this</span>, refs_lists, !discovery_is_atomic() <span class="comment">/*marks_oops_alive*/</span>)</span></span>;</span><br><span class="line">    task_executor-&gt;<span class="built_in">execute</span>(phase2);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; _max_num_q; i++) &#123;</span><br><span class="line">      <span class="built_in">process_phase2</span>(refs_lists[i], is_alive, keep_alive, complete_gc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Phase 3:</span></span><br><span class="line">  <span class="comment">// . Traverse the list and process referents as appropriate.</span></span><br><span class="line">  <span class="comment">// 根据clear_referent的值决定是否将不存活对象回收</span></span><br><span class="line">  <span class="keyword">if</span> (mt_processing) &#123;</span><br><span class="line">    <span class="function">RefProcPhase3Task <span class="title">phase3</span><span class="params">(*<span class="keyword">this</span>, refs_lists, clear_referent, <span class="literal">true</span> <span class="comment">/*marks_oops_alive*/</span>)</span></span>;</span><br><span class="line">    task_executor-&gt;<span class="built_in">execute</span>(phase3);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; _max_num_q; i++) &#123;</span><br><span class="line">      <span class="built_in">process_phase3</span>(refs_lists[i], clear_referent,</span><br><span class="line">                     is_alive, keep_alive, complete_gc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> total_list_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-process-phase1"><a href="#2-2-process-phase1" class="headerlink" title="2.2 process_phase1()"></a>2.2 process_phase1()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ReferenceProcessor::process_phase1</span><span class="params">(DiscoveredList&amp;    refs_list,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   ReferencePolicy*   policy,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   BoolObjectClosure* is_alive,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   OopClosure*        keep_alive,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   VoidClosure*       complete_gc)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(policy != <span class="literal">NULL</span>, <span class="string">&quot;Must have a non-NULL policy&quot;</span>);</span><br><span class="line">  <span class="function">DiscoveredListIterator <span class="title">iter</span><span class="params">(refs_list, keep_alive, is_alive)</span></span>;</span><br><span class="line">  <span class="comment">// Decide which softly reachable refs should be kept alive.</span></span><br><span class="line">  <span class="comment">// 遍历refs_list中的所有元素</span></span><br><span class="line">  <span class="keyword">while</span> (iter.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">    iter.<span class="built_in">load_ptrs</span>(<span class="built_in">DEBUG_ONLY</span>(!<span class="built_in">discovery_is_atomic</span>() <span class="comment">/* allow_null_referent */</span>));</span><br><span class="line">    <span class="comment">// 判断所引用的对象是否存活</span></span><br><span class="line">    <span class="type">bool</span> referent_is_dead = (iter.<span class="built_in">referent</span>() != <span class="literal">NULL</span>) &amp;&amp; !iter.<span class="built_in">is_referent_alive</span>();</span><br><span class="line">    <span class="comment">// 如果已经不存活，则根据ReferencePolicy去判断是否应该回收，should_clear_reference返回false，则从refs_list中移除，也就是不回收</span></span><br><span class="line">    <span class="keyword">if</span> (referent_is_dead &amp;&amp;</span><br><span class="line">        !policy-&gt;<span class="built_in">should_clear_reference</span>(iter.<span class="built_in">obj</span>(), _soft_ref_timestamp_clock)) &#123;</span><br><span class="line">      <span class="comment">// 回收对象</span></span><br><span class="line">      <span class="keyword">if</span> (TraceReferenceGC) &#123;</span><br><span class="line">        gclog_or_tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;Dropping reference (&quot;</span> INTPTR_FORMAT <span class="string">&quot;: %s&quot;</span>  <span class="string">&quot;) by policy&quot;</span>,</span><br><span class="line">                               (<span class="type">void</span> *)iter.<span class="built_in">obj</span>(), iter.<span class="built_in">obj</span>()-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">internal_name</span>());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Remove Reference object from list</span></span><br><span class="line">      iter.<span class="built_in">remove</span>();</span><br><span class="line">      <span class="comment">// Make the Reference object active again</span></span><br><span class="line">      iter.<span class="built_in">make_active</span>();</span><br><span class="line">      <span class="comment">// keep the referent around</span></span><br><span class="line">      iter.<span class="built_in">make_referent_alive</span>();</span><br><span class="line">      iter.<span class="built_in">move_to_next</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 跳过当前，继续遍历</span></span><br><span class="line">      iter.<span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Close the reachable set</span></span><br><span class="line">  complete_gc-&gt;<span class="built_in">do_void</span>();</span><br><span class="line">  <span class="built_in">NOT_PRODUCT</span>(</span><br><span class="line">    <span class="keyword">if</span> (PrintGCDetails &amp;&amp; TraceReferenceGC) &#123;</span><br><span class="line">      gclog_or_tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot; Dropped %d dead Refs out of %d &quot;</span></span><br><span class="line">        <span class="string">&quot;discovered Refs by policy, from list &quot;</span> INTPTR_FORMAT,</span><br><span class="line">        iter.<span class="built_in">removed</span>(), iter.<span class="built_in">processed</span>(), (address)refs_list.<span class="built_in">head</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码很好理解，遍历refs_list，取出里面的每一个元素，并判断是否应该移除，判断的依据包括这个元素所引用的对象是否存活以及ReferencePolicy。那么这个ReferencePolicy是啥？</p>
<h3 id="2-2-1-referencePolicy-hpp"><a href="#2-2-1-referencePolicy-hpp" class="headerlink" title="2.2.1 referencePolicy.hpp"></a>2.2.1 referencePolicy.hpp</h3><p>打开这个文件，我们可以看到ReferencePolicy的定义，除了这个类以外，还有4个他的子类：</p>
<ul>
<li>NeverClearPolicy</li>
<li>AlwaysClearPolicy</li>
<li>LRUCurrentHeapPolicy</li>
<li>LRUMaxHeapPolicy</li>
</ul>
<p>对于前两个类的should_clear_reference()方法很简单，一个永远返回false，一个永远返回true。那下面两个是啥？</p>
<h4 id="referencePolicy-cpp"><a href="#referencePolicy-cpp" class="headerlink" title="referencePolicy.cpp"></a>referencePolicy.cpp</h4><p>截取下主要代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// M = 1024 * 1024</span></span><br><span class="line"><span class="comment">// SoftRefLRUPolicyMSPerMB = 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Capture state (of-the-VM) information needed to evaluate the policy</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUCurrentHeapPolicy::setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  _max_interval = (Universe::<span class="built_in">get_heap_free_at_last_gc</span>() / M) * SoftRefLRUPolicyMSPerMB;</span><br><span class="line">  <span class="built_in">assert</span>(_max_interval &gt;= <span class="number">0</span>,<span class="string">&quot;Sanity check&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The oop passed in is the SoftReference object, and not</span></span><br><span class="line"><span class="comment">// the object the SoftReference points to.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LRUCurrentHeapPolicy::should_clear_reference</span><span class="params">(oop p,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  jlong timestamp_clock)</span> </span>&#123;</span><br><span class="line">  jlong interval = timestamp_clock - java_lang_ref_SoftReference::<span class="built_in">timestamp</span>(p);</span><br><span class="line">  <span class="built_in">assert</span>(interval &gt;= <span class="number">0</span>, <span class="string">&quot;Sanity check&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The interval will be zero if the ref was accessed since the last scavenge/gc.</span></span><br><span class="line">  <span class="keyword">if</span>(interval &lt;= _max_interval) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Capture state (of-the-VM) information needed to evaluate the policy</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUMaxHeapPolicy::setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> max_heap = MaxHeapSize;</span><br><span class="line">  max_heap -= Universe::<span class="built_in">get_heap_used_at_last_gc</span>();</span><br><span class="line">  max_heap /= M;</span><br><span class="line"></span><br><span class="line">  _max_interval = max_heap * SoftRefLRUPolicyMSPerMB;</span><br><span class="line">  <span class="built_in">assert</span>(_max_interval &gt;= <span class="number">0</span>,<span class="string">&quot;Sanity check&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The oop passed in is the SoftReference object, and not</span></span><br><span class="line"><span class="comment">// the object the SoftReference points to.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LRUMaxHeapPolicy::should_clear_reference</span><span class="params">(oop p,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             jlong timestamp_clock)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 此方法和上面的一模一样，所以不再单独拿出来</span></span><br></pre></td></tr></table></figure>
<p>单纯看他两的setup方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_max_interval = (Universe::<span class="built_in">get_heap_free_at_last_gc</span>() / M) * SoftRefLRUPolicyMSPerMB;</span><br><span class="line">_max_interval = (MaxHeapSize - Universe::<span class="built_in">get_heap_used_at_last_gc</span>()) / M * SoftRefLRUPolicyMSPerMB;</span><br></pre></td></tr></table></figure>
<p>前者计算的是上次GC后的可用堆大小，后者计算的是(堆大小-上次GC时使用的大小)</p>
<p>而should_clear_reference方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">jlong interval = timestamp_clock - java_lang_ref_SoftReference::<span class="built_in">timestamp</span>(p);</span><br><span class="line"><span class="built_in">assert</span>(interval &gt;= <span class="number">0</span>, <span class="string">&quot;Sanity check&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The interval will be zero if the ref was accessed since the last scavenge/gc.</span></span><br><span class="line"><span class="keyword">if</span>(interval &lt;= _max_interval) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>但是，<code>timestamp_clock</code>和<code>java_lang_ref_SoftReference::timestamp(p)</code>是什么呢？</p>
<p>第一个不说，第二个看这个形式，是不是很熟悉，这不就是jni嘛，我们再次回到java层。</p>
<h4 id="软引用、弱引用和虚引用"><a href="#软引用、弱引用和虚引用" class="headerlink" title="软引用、弱引用和虚引用"></a>软引用、弱引用和虚引用</h4><p>Reference主要的三个子类，弱引用和虚引用虽然继承自Reference，但是他们改动不大：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Reference</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeakReference</span><span class="params">(T referent)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeakReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Reference</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PhantomReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反倒是弱引用，改动了较多：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoftReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Reference</span>&lt;T&gt; &#123;</span><br><span class="line">  	<span class="comment">// 时间戳时钟，由GC更新。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="type">long</span> clock;</span><br><span class="line">  	<span class="comment">// 每次调用get方法所更新的时间戳。虚拟机在选择要清除的软引用时，可以使用此字段，但不要求这样做。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timestamp;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SoftReference</span><span class="params">(T referent)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent);</span><br><span class="line">        <span class="built_in">this</span>.timestamp = clock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SoftReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent, q);</span><br><span class="line">        <span class="built_in">this</span>.timestamp = clock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">o</span> <span class="operator">=</span> <span class="built_in">super</span>.get();</span><br><span class="line">        <span class="keyword">if</span> (o != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.timestamp != clock)</span><br><span class="line">            <span class="built_in">this</span>.timestamp = clock;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>clock</code>就是上面native代码的<code>timestamp_clock</code>，<code>timestamp</code>就是<code>java_lang_ref_SoftReference::timestamp(p)</code>。如果上次GC时有调用过<code>get()</code>那么interval为0，否则就是他们之间的差值。也就是说，如果GC间隔时间太长了，就回被回收。</p>
<p>所以我们更新下，判断软引用是否改被移除的依据包括这个元素所引用的对象是否存活、Policy策略以及存活时间。</p>
<h2 id="2-3-process-phase2"><a href="#2-3-process-phase2" class="headerlink" title="2.3 process_phase2()"></a>2.3 process_phase2()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Traverse the list and remove any Refs that are not active, or</span></span><br><span class="line"><span class="comment">// whose referents are either alive or NULL.</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ReferenceProcessor::pp2_work</span><span class="params">(DiscoveredList&amp;    refs_list,</span></span></span><br><span class="line"><span class="params"><span class="function">                             BoolObjectClosure* is_alive,</span></span></span><br><span class="line"><span class="params"><span class="function">                             OopClosure*        keep_alive)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">discovery_is_atomic</span>(), <span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  <span class="function">DiscoveredListIterator <span class="title">iter</span><span class="params">(refs_list, keep_alive, is_alive)</span></span>;</span><br><span class="line">  <span class="comment">// 遍历refs_list中的所有元素</span></span><br><span class="line">  <span class="keyword">while</span> (iter.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">    iter.<span class="built_in">load_ptrs</span>(<span class="built_in">DEBUG_ONLY</span>(<span class="literal">false</span> <span class="comment">/* allow_null_referent */</span>));</span><br><span class="line">    <span class="built_in">DEBUG_ONLY</span>(oop next = java_lang_ref_Reference::<span class="built_in">next</span>(iter.<span class="built_in">obj</span>());)</span><br><span class="line">    <span class="built_in">assert</span>(next == <span class="literal">NULL</span>, <span class="string">&quot;Should not discover inactive Reference&quot;</span>);</span><br><span class="line">    <span class="comment">// 判断引用是否存活，存活则从refs_list中移除，否则遍历下一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (iter.<span class="built_in">is_referent_alive</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (TraceReferenceGC) &#123;</span><br><span class="line">        gclog_or_tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;Dropping strongly reachable reference (&quot;</span> INTPTR_FORMAT <span class="string">&quot;: %s)&quot;</span>,</span><br><span class="line">                               (<span class="type">void</span> *)iter.<span class="built_in">obj</span>(), iter.<span class="built_in">obj</span>()-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">internal_name</span>());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// The referent is reachable after all.</span></span><br><span class="line">      <span class="comment">// Remove Reference object from list.</span></span><br><span class="line">      iter.<span class="built_in">remove</span>();</span><br><span class="line">      <span class="comment">// Update the referent pointer as necessary: Note that this</span></span><br><span class="line">      <span class="comment">// should not entail any recursive marking because the</span></span><br><span class="line">      <span class="comment">// referent must already have been traversed.</span></span><br><span class="line">      iter.<span class="built_in">make_referent_alive</span>();</span><br><span class="line">      iter.<span class="built_in">move_to_next</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      iter.<span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">NOT_PRODUCT</span>(</span><br><span class="line">    <span class="keyword">if</span> (PrintGCDetails &amp;&amp; TraceReferenceGC &amp;&amp; (iter.<span class="built_in">processed</span>() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">      gclog_or_tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot; Dropped %d active Refs out of %d &quot;</span></span><br><span class="line">        <span class="string">&quot;Refs in discovered list &quot;</span> INTPTR_FORMAT,</span><br><span class="line">        iter.<span class="built_in">removed</span>(), iter.<span class="built_in">processed</span>(), (address)refs_list.<span class="built_in">head</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码很简单，就是遍历refs_list，如果所指向的对象还存活，则从list中移除，否则保留着继续遍历。</p>
<h2 id="2-4-process-phase3"><a href="#2-4-process-phase3" class="headerlink" title="2.4 process_phase3()"></a>2.4 process_phase3()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Traverse the list and process the referents, by either</span></span><br><span class="line"><span class="comment">// clearing them or keeping them (and their reachable</span></span><br><span class="line"><span class="comment">// closure) alive.</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ReferenceProcessor::process_phase3</span><span class="params">(DiscoveredList&amp;    refs_list,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">bool</span>               clear_referent,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   BoolObjectClosure* is_alive,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   OopClosure*        keep_alive,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   VoidClosure*       complete_gc)</span> </span>&#123;</span><br><span class="line">  ResourceMark rm;</span><br><span class="line">  <span class="function">DiscoveredListIterator <span class="title">iter</span><span class="params">(refs_list, keep_alive, is_alive)</span></span>;</span><br><span class="line">  <span class="comment">// 遍历refs_list，此时这里已经是经过phase1和2过滤后的剩下的元素</span></span><br><span class="line">  <span class="keyword">while</span> (iter.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">    <span class="comment">// 更新discovered变量，discovered的值更新为上一个元素的discovered</span></span><br><span class="line">    iter.<span class="built_in">update_discovered</span>();</span><br><span class="line">    iter.<span class="built_in">load_ptrs</span>(<span class="built_in">DEBUG_ONLY</span>(<span class="literal">false</span> <span class="comment">/* allow_null_referent */</span>));</span><br><span class="line">    <span class="keyword">if</span> (clear_referent) &#123;</span><br><span class="line">      <span class="comment">// NULL out referent pointer</span></span><br><span class="line">      <span class="comment">// 清除引用，之后会被GC回收</span></span><br><span class="line">      iter.<span class="built_in">clear_referent</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// keep the referent around</span></span><br><span class="line">      <span class="comment">// 标记引用的对象为存活，该对象在这次GC不会被回收</span></span><br><span class="line">      iter.<span class="built_in">make_referent_alive</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (TraceReferenceGC) &#123;</span><br><span class="line">      gclog_or_tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;Adding %sreference (&quot;</span> INTPTR_FORMAT <span class="string">&quot;: %s) as pending&quot;</span>,</span><br><span class="line">                             clear_referent ? <span class="string">&quot;cleared &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                             (<span class="type">void</span> *)iter.<span class="built_in">obj</span>(), iter.<span class="built_in">obj</span>()-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">internal_name</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(iter.<span class="built_in">obj</span>()-&gt;<span class="built_in">is_oop</span>(UseConcMarkSweepGC), <span class="string">&quot;Adding a bad reference&quot;</span>);</span><br><span class="line">    iter.<span class="built_in">next</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Remember to update the next pointer of the last ref.</span></span><br><span class="line">  <span class="comment">// 更新discovered变量</span></span><br><span class="line">  iter.<span class="built_in">update_discovered</span>();</span><br><span class="line">  <span class="comment">// Close the reachable set</span></span><br><span class="line">  complete_gc-&gt;<span class="built_in">do_void</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>看完了代码，我们来回答下之前提出的问题：</p>
<ul>
<li><p>软引用是内存不足才会回收，那么什么叫内存不足？</p>
<p>根据<code>process_phase1()</code>中ReferencePolicy的四个子类，我们可以得知，内存不足的定义和该引用对象get的时间以及当前堆可用内存大小都有关系。具体可以看LRUCurrentHeapPolicy和LRUMaxHeapPolicy</p>
</li>
<li><p>弱引用只要发生GC时就回收，但是他不是引用着对应的强引用，那么他为啥能被回收？</p>
<p>这个问题可以回顾<code>process_phase3()</code>，它里面会有一个if判断，如果<code>clear_referent</code>为true，就回收，并把<code>reference</code>置为null，否则不回收。那么这个变量是在哪被赋值的呢？我们一个个调用看上去，就会神奇的发现，在<code>process_discovered_references()</code>方法中，软引用和弱引用的<code>clear_referent</code>直接为true，虚引用为false。所以只要发生了GC，弱引用就会被回收。(而软引用如果内存充足的情况下，在<code>process_phase1()</code>时就已经被从队列中移除了，并不会走到<code>process_phase2()</code>)</p>
</li>
<li><p>虚引用形同虚设，任何时候都会被回收，那么到底什么时候会被回收？</p>
<p>虚引用是会影响对象生命周期的，如果不做任何处理，只要虚引用不被回收，那其引用的对象永远不会被回收。所以一般来说，从ReferenceQueue中获得PhantomReference对象后，如果PhantomReference对象不会被回收的话（比如被其他GC ROOT可达的对象引用），需要调用<code>clear</code>方法解除PhantomReference和其引用对象的引用关系。</p>
</li>
<li><p>当引用对象被回收时，他们是怎么被添加到若引用队列的？</p>
<p>看<code>tryHandlePending()</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM-类加载器</title>
    <url>/posts/594da31f.html</url>
    <content><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><p>虚拟机设计团队把类加载阶段中的“<strong>通过一个类的全限定名来获取描述此类的二进制字节流(即字节码)</strong>”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“<strong>类加载器</strong>”。</p>
<p>一般来说，Java 虚拟机使用 Java 类的方式如下：</p>
<ul>
<li>Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成字节码（.class 文件）。</li>
<li>类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。</li>
</ul>
<p>实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。更详细的内容可以参考上一篇文章中讲类加载过程中的加载阶段时介绍的几个例子（JAR包、Applet、动态代理、JSP等）。</p>
<h1 id="2-类与类加载器"><a href="#2-类与类加载器" class="headerlink" title="2. 类与类加载器"></a>2. 类与类加载器</h1><p>类加载器虽然只用于实现类的加载动作，但他在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载他的类加载器和这个类本身异同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p>
<p>通俗一点就是：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等（这里指的相等，包括类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof()关键字对做对象所属关系判定等情况）。</p>
<h1 id="3-双亲委派模型"><a href="#3-双亲委派模型" class="headerlink" title="3. 双亲委派模型"></a>3. 双亲委派模型</h1><p>从Java虚拟机角度来讲，只存在两种不同的类加载器：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），这个类加载器用C++实现，是虚拟机自身的一部分</li>
<li>所有其他类的加载器，这些类加载器由Java实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader</li>
</ul>
<p>从Java开发人员角度来看，类加载器还可以划分的更细致一些：</p>
<ul>
<li><p>启动类加载器（Bootstrap ClassLoader） 此类加载器负责将存放在 <JAVA_HOME>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在lib 目录中也不会被加载）类库加载到虚拟机内存中。 启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，直接使用null代替即可。</p>
</li>
<li><p>扩展类加载器（Extension ClassLoader） 这个类加载器是由ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将<Java_Home>/lib/ext或者被 java.ext.dir系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</p>
</li>
<li><p>应用程序类加载器（Application ClassLoader） 这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ul>
<p>由开发人员开发的应用程序都是由这三种类加载器相互配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器的关系一般如下图所示：<br><img src="media/15745827002064/15745869705585.jpg" alt=""></p>
<p>上图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器，这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。</p>
<h2 id="3-1-工作过程"><a href="#3-1-工作过程" class="headerlink" title="3.1 工作过程"></a>3.1 工作过程</h2><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。</p>
<p>这样的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。无论哪个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。</p>
<p>相反，如果没有使用双亲委派模式，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。</p>
<h2 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a>3.2 实现</h2><p>双亲委派模型的实现很简单，主要都集中在java.lang.ClassLoader的loadClass()方法中：先检查是否已经被加载过，如果没有，就调用父加载器的loadClass()，若父加载器为空，则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name,<span class="type">boolean</span> resolve)<span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="comment">// 首先，检查请求的类是否已经加载过了</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(parent != <span class="literal">null</span>)&#123;</span><br><span class="line">                c = parent.loadClass(name,<span class="literal">false</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">            <span class="comment">// 如果父类加载器抛出ClassNotFoundException</span></span><br><span class="line">            <span class="comment">// 说明父类加载器无法完成加载请求</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 在父类加载器无法加载的时候</span></span><br><span class="line">            <span class="comment">// 再调用本身的findClass方法进行类加载</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(resolve)&#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-破坏双亲委派模型"><a href="#4-破坏双亲委派模型" class="headerlink" title="4. 破坏双亲委派模型"></a>4. 破坏双亲委派模型</h1><p>三种破坏双亲委派模型的方式：</p>
<h2 id="4-1-JDK1-2引入的双亲委派模型和JDK1-0就有的ClassLoader"><a href="#4-1-JDK1-2引入的双亲委派模型和JDK1-0就有的ClassLoader" class="headerlink" title="4.1 JDK1.2引入的双亲委派模型和JDK1.0就有的ClassLoader"></a>4.1 JDK1.2引入的双亲委派模型和JDK1.0就有的ClassLoader</h2><p>双亲委派模型是JDK1.2之后才被引用的，而在JDK1.0就有ClassLoader了。所以面对已存在的用户自定义类加载器的实现代码，Java设计者引入了双亲委派模型时不得不做出一些妥协。</p>
<p>为了向前兼容，JDK1.2之后的java.lang.ClassLoader添加了一个新的protected方法findClass()。开发者只需要将自己的类加载逻辑代码写到findClass()方法中，在loadClass()方法的逻辑里如果父类加载失败，就会调用自己的findClass()方法来完成加载，这样就可以保证新写出来的类加载器符合双亲委派规则。</p>
<h2 id="4-2-线程上下文类加载器"><a href="#4-2-线程上下文类加载器" class="headerlink" title="4.2 线程上下文类加载器"></a>4.2 线程上下文类加载器</h2><p>这个是因为双亲委派模式自身设计缺陷导致的。</p>
<p>双亲委派很好解决了各个类加载器的基础类统一的问题，但是如果基础类要调用会用户的代码咋办？</p>
<p>这个使用场景我不太了解，我看书上和别人博客上的例子也看不懂。我只能抄一下别人的例子。</p>
<blockquote>
<p>Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。这些 SPI 的接口由 Java 核心库来提供，如 JAXP 的 SPI 接口定义包含在 javax.xml.parsers包中。这些 SPI 的实现代码很可能是作为 Java 应用所依赖的 jar 包被包含进来，可以通过类路径（ClassPath）来找到，如实现了 JAXP SPI 的 Apache Xerces所包含的 jar 包。SPI 接口中的代码经常需要加载具体的实现类。如 JAXP 中的 javax.xml.parsers.DocumentBuilderFactory类中的 newInstance() 方法用来生成一个新的 DocumentBuilderFactory 的实例。这里的实例的真正的类是继承自 javax.xml.parsers.DocumentBuilderFactory，由 SPI 的实现所提供的。如在 Apache Xerces 中，实现的类是 org.apache.xerces.jaxp.DocumentBuilderFactoryImpl。而问题在于，SPI 的接口是Java 核心库的一部分，是由引导类加载器加载的，而SPI 实现的 Java 类一般是由系统类加载器加载的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能委派给系统类加载器，因为它是系统类加载器的祖先类加载器。也就是说，类加载器的双亲委派模型无法解决这个问题。</p>
<p>为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。线程上下文类加载器是从 JDK 1.2 开始引入的。类 java.lang.Thread中的方法 getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。如果没有通过 setContextClassLoader(ClassLoader cl)方法进行设置的话，线程将继承其父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是应用程序类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。</p>
</blockquote>
<h2 id="4-3-程序动态性"><a href="#4-3-程序动态性" class="headerlink" title="4.3 程序动态性"></a>4.3 程序动态性</h2><p>这里所说的“动态性”指的是当前一些非常热门的名词：代码热替换（HotSwap）、模块热部署(Hot Deployment)等。即希望应用程序能像计算机的外设一样，接上鼠标、键盘，不用重启就能立即使用，鼠标出了问题或需要升级就换个鼠标，不用停机或重启。</p>
<p>当前业界“事实上”的Java模块化标准是OSGi，而OSGi实现代码热部署的关键则是它自定义的类机载器的实现。</p>
<p>每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。</p>
<p>在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p>
<ol>
<li>将以java.*开头的类委派给分类加载器加载</li>
<li>否则，将委派列表名单内的类委派给父类加载器加载</li>
<li>否则，将import列表中的类委派给Export这个类的Bundle的类加载器加载</li>
<li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载</li>
<li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载</li>
<li>否则，类查找失败</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM-虚拟机类加载机制</title>
    <url>/posts/65c09aaf.html</url>
    <content><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>
<p>Java类型的加载、连接和初始化过程都是在程序运行期间完成的，为Java应用程序提供高度的灵活性</p>
<h1 id="2-类加载的时机"><a href="#2-类加载的时机" class="headerlink" title="2. 类加载的时机"></a>2. 类加载的时机</h1><p>类从被加载到虚拟机内存中开始，到卸载处内存为止<br>它的整个生命周期包括：</p>
<ul>
<li>加载（Loading）</li>
<li>验证 （Verification）</li>
<li>准备（Preparation）</li>
<li>解析（Resolution）</li>
<li>初始化（Initialization）</li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ul>
<p>验证、解析、准备统称为连接（Linking）</p>
<p>其中，加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的。但是解析不一定，某些情况下可以在初始化之后再开始，这是为了支持Java的运行时绑定。</p>
<h2 id="2-1-加载的时机"><a href="#2-1-加载的时机" class="headerlink" title="2.1 加载的时机"></a>2.1 加载的时机</h2><p>这个Java虚拟机规范中并没有进行强制约束，这个可以交给虚拟机自订。</p>
<h2 id="2-2-初始化的时机"><a href="#2-2-初始化的时机" class="headerlink" title="2.2 初始化的时机"></a>2.2 初始化的时机</h2><p>对于初始化的时机，虚拟机规范强制规定只有5中情况必须立即对类进行“初始化”</p>
<ul>
<li>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这4条字节码指令时，如果类没有初始化过，则需要先触发其初始化。对应着使用<code>new</code>关键字实例化对象的时候、读取或设置一个类的静态字段（被<code>final</code>修饰、已在编译期把结果放入常量池的静态字段外）的时候，以及调用一个类的静态方法的时候</li>
<li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li>
<li>当虚拟机启动时，用户需要制定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类</li>
<li>当使用JDK1.7的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li>
</ul>
<p>而对于接口，当一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口时（如引用父接口中定义的常量）才会初始化。</p>
<p>这五种场景中的行为称为对一个类进行主动引用<br>所有引用类的方式都不会触发初始化，被称为被动引用。</p>
<ul>
<li><p>通过子类引用父类的静态字段，不会导致子类初始化。<br>  对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中的静态字段，只会触发父类的初始化，而不会触发子类的初始化</p>
</li>
<li><p>通过数组定义来引用类，不会触发此类的初始化</p>
</li>
<li>常量在编译阶段会存储调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</li>
</ul>
<h1 id="3-类加载的过程"><a href="#3-类加载的过程" class="headerlink" title="3. 类加载的过程"></a>3. 类加载的过程</h1><p>分为加载、验证、准备、解析和初始化5个阶段</p>
<h2 id="3-1-加载"><a href="#3-1-加载" class="headerlink" title="3.1 加载"></a>3.1 加载</h2><p>加载是类加载中的一个阶段。</p>
<p>在加载阶段，虚拟机需要完成以下3件事</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存汇总生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
<p>虚拟机对这几点的要求其实并不具体，因此虚拟机实现与具体应用的灵活度都是相当大的。</p>
<p>例如第一条，他只说了获取二进制字节流，但是没说具体从哪获取。所以这一点为很多Java技术都建立了基础：</p>
<ul>
<li>从ZIP包读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。</li>
<li>从网络中获取，这种场景最典型的应用是Applet。</li>
<li>运行时计算生成，这种场景使用得最多得就是动态代理技术，在<code>java.lang.reflect.Proxy</code>中，就是用了<code>ProxyGenerator.generateProxyClass</code>的代理类的二进制字节流。</li>
<li>由其他文件生成，典型场景是JSP应用，即由JSP文件生成对应的Class类。</li>
<li>从数据库读取，这种场景相对少见，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li>
</ul>
<h3 id="3-1-1-非数组类的加载"><a href="#3-1-1-非数组类的加载" class="headerlink" title="3.1.1 非数组类的加载"></a>3.1.1 非数组类的加载</h3><p>相对于类加载过程的其它阶段，一个非数组类的加载阶段是开发人员可控性最强的。因为加载阶段既可以使用系统提供的引导类加载类去完成，也可以由用户自定义的类加载器去完成，通过定义自己的类加载器去控制字节流的获取，即重写一个类加载器的<code>loadClass()</code>方法。</p>
<h3 id="3-1-2-数组类的加载"><a href="#3-1-2-数组类的加载" class="headerlink" title="3.1.2 数组类的加载"></a>3.1.2 数组类的加载</h3><p>数据类本身不通过类加载器创建，她是由Java虚拟机直接创建的。</p>
<p>但是数据类的元素类型（数组去掉所有维度的类型）最终是要靠加载器去创建。</p>
<p>一个数组类创建过程必须遵循以下规则：</p>
<ul>
<li>如果数组的组件类型（数组去掉一个维度的类型）是引用类型，那就递归采用本书定义的加载过程去加载这个组件类型，数组类将在加载该组件类型的类加载器的类名称空间上被标识</li>
<li>如果数组的组件类型不是引用类型，Java虚拟机将会数组类标记为与引导类加载器关联</li>
<li>数组类的可见性与他的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public</li>
</ul>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的这些类型数据的外部接口。</p>
<h2 id="3-2-验证"><a href="#3-2-验证" class="headerlink" title="3.2 验证"></a>3.2 验证</h2><p>验证是连接阶段的第一步，为了确保输入的Class文件的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求，并且不会危害虚拟机自身的安全。</p>
<p>如果不检查输入的字节流，对齐完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。</p>
<p>验证阶段是非常重要的，这个阶段是否严瑾，直接决定了Java虚拟机是否能承受恶意代码的攻击，从性能的角度上讲，验证阶段的工作量在虚拟机的类加载子系统又占了相当大的一部分。</p>
<p>从整体上看，验证阶段大致会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p>
<h3 id="3-2-1-文件格式验证"><a href="#3-2-1-文件格式验证" class="headerlink" title="3.2.1 文件格式验证"></a>3.2.1 文件格式验证</h3><p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</p>
<p>可能包括以下验证点：</p>
<ul>
<li>是否以魔数0xCAFEBABE开头</li>
<li>主、次版本号是否在当前虚拟机处理范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型</li>
<li>指向常量的各种索引值是否有指向不存在的常量或不符合类型的常量</li>
<li>CONSTANT_Utf8_info型的常量是否有不符合UTF8编码的数据</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其它信息</li>
<li>……</li>
</ul>
<p>该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。</p>
<p>这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证都是基于方法区的存储结构进行的，不会再直接操作字节流。</p>
<h3 id="3-2-2-元数据验证"><a href="#3-2-2-元数据验证" class="headerlink" title="3.2.2 元数据验证"></a>3.2.2 元数据验证</h3><p>第二阶段是对字节码描述的信息进行语法分析，以保证其描述的信息符合Java语言规范的要求。</p>
<p>可能包括以下验证点：</p>
<ul>
<li>这个类是否有父类（除了Object之外，其他类都有父类）</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口中要求实现的方法</li>
<li>类中的字段、方法是否与父类产生矛盾</li>
<li>……</li>
</ul>
<p>主要目的是对类的元数据信息就行语义检验，保证不存在不符合Java语言规范的元数据信息。</p>
<h3 id="3-2-3-字节码验证"><a href="#3-2-3-字节码验证" class="headerlink" title="3.2.3 字节码验证"></a>3.2.3 字节码验证</h3><p>第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确实程序语义是合法的、符合逻辑的。</p>
<p>在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。</p>
<p>由于数据流校验的高复杂性，耗时较大，所以JDK1.6之后，在Javac中引入一项优化方法（可以通过参数关闭）：在方法体的Code属性的属性表中增加一项“StackMapTable”属性，该属性描述了方法体中所有基本块开始时本地变量表和操作栈应有的状态，从而将字节码验证的类型推导转变为类型检查从而节省一些时间。</p>
<p>如果一个类方法体的字节码没有通过字节码验证，那一定是有问题的；但是如果通过了，那不一定是完全没问题的。</p>
<h3 id="3-2-4-符号引用验证"><a href="#3-2-4-符号引用验证" class="headerlink" title="3.2.4 符号引用验证"></a>3.2.4 符号引用验证</h3><p>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。</p>
<p>符号引用的验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验下列内容：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>指定的类中是否存在符合描述符与简单名称描述的方法与字段。</li>
<li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。</li>
<li>……</li>
</ul>
<p>符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个<code>java.lang.IncompatibleClassChangeError</code>异常的子类。</p>
<h3 id="3-2-5-验证总结"><a href="#3-2-5-验证总结" class="headerlink" title="3.2.5 验证总结"></a>3.2.5 验证总结</h3><p>对于jvm的类加载机制来说，验证阶段是一个非常重要但不是一定必要（因为对运行期没有影响）的阶段。如果所运行的全部代码都已经被反复验证过，那么在实施阶段就可以考虑使用<code>-Xverify:none</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h2 id="3-3-准备"><a href="#3-3-准备" class="headerlink" title="3.3 准备"></a>3.3 准备</h2><p>任务:</p>
<ul>
<li>为类变量分配内存</li>
<li>设置类变量初始值</li>
</ul>
<p>这些变量所使用的内存都将在方法区中进行分配。</p>
<p>首先，在准备阶段进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
<p>其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值为123的动作在初始化阶段才会执行。 值得注意的是，如果类字段的字段属性中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，假设上面类变量value的定义变为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p>
<h2 id="3-4-解析"><a href="#3-4-解析" class="headerlink" title="3.4 解析"></a>3.4 解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<h3 id="3-4-1-什么是符号引用和直接引用"><a href="#3-4-1-什么是符号引用和直接引用" class="headerlink" title="3.4.1 什么是符号引用和直接引用"></a>3.4.1 什么是符号引用和直接引用</h3><p>那我们吸纳来说一下符号引用和直接引用的概念：</p>
<ul>
<li><strong>符号引用</strong>：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用<strong>与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中</strong>。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用<strong>必须一致</strong>，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</li>
<li><strong>直接饮用</strong>：直接引用可以是直接目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局<strong>有关</strong>的，<strong>同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同</strong>。如果有了直接引用，那么引用的目标<strong>必定已经在内存中存在</strong>。</li>
</ul>
<p>虚拟机规范没有规定解析阶段发生的具体时间，虚拟机实现可以根据需要来判断到底是在类被加载时解析还是等到一个符号引用将要被使用前才去解析。</p>
<h3 id="3-4-2-对解析结果进行缓存"><a href="#3-4-2-对解析结果进行缓存" class="headerlink" title="3.4.2 对解析结果进行缓存"></a>3.4.2 对解析结果进行缓存</h3><p>同一符号引用进行多次解析请求是很常见的，除<code>invokedynamic</code>指令以外，虚拟机实现可以对第一次解析结果进行缓存，来避免解析动作重复进行。无论是否真正执行了多次解析动作，虚拟机需要保证的是在同一个实体中，如果一个引用符号之前已经被成功解析过，那么后续的引用解析请求就应当一直成功；同样的，如果 第一次解析失败，那么其他指令对这个符号的解析请求也应该收到相同的异常。</p>
<p>但是以上规则对<code>invokedynamic</code>不成立。当碰到某个前面已经由<code>invokedynamic</code>指令触发过解析的符号引用时，并不意味着这个解析结果对其它<code>invokedynamic</code>指令也同样生效。</p>
<p>原因是因为这个指令用于动态语言支持，也就是等程序执行到这条指令时，才去解析。相对的，其它的都是静态的，也就是刚完成加载阶段，还没开始执行代码就解析了。</p>
<h3 id="3-4-3-解析的对象"><a href="#3-4-3-解析的对象" class="headerlink" title="3.4.3 解析的对象"></a>3.4.3 解析的对象</h3><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>
<p>对于后面3中，与JDK1.7新增的动态语言支持有关。</p>
<h2 id="3-5-初始化"><a href="#3-5-初始化" class="headerlink" title="3.5 初始化"></a>3.5 初始化</h2><p>类初始化阶段是类加载过程的最后一步。</p>
<p>前面的过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。而在从初始化阶段开始，才是真正的执行定义的Java程序代码。</p>
<p>在准备阶段时，我们说过这时程序已经为static修饰的类变量进行了初始化操作。而当时我们也说过，在准备阶段初始化的值只是Java对该变量定义的默认值，就好比int是<code>0</code>，float是<code>0.0f</code>，Boolean是<code>false</code>。他才不管你在代码里面有没有给这些变量定义值。</p>
<p>而在初始化阶段，才是根据程序员通过程序制定的主观计划去初始化类变量和其他资源。简单点说，初始化阶段是执行类构造器<code>&lt;client&gt;()</code>方法的过程。</p>
<p>下面来详细讲讲<code>&lt;client&gt;()</code>方法是怎么生成的：</p>
<ul>
<li><code>&lt;client&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定，特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;  <span class="comment">// 给变量复制可以正常编译通过</span></span><br><span class="line">        System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用” </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;clinit&gt;()</code>方法与类的构造函数（或者说实例构造器<code>&lt;init&gt;()</code>方法）不同，不需要显式的调用父类的()方法。虚拟机会自动保证在子类的<code>&lt;clinit&gt;()</code>方法运行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行结束。因此虚拟机中第一个执行<code>&lt;clinit&gt;()</code>方法的类肯定为<code>java.lang.Object</code>。</li>
<li>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。例如以下代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            A = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">B</span> <span class="operator">=</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Sub.B);<span class="comment">//输出结果是父类中的静态变量值A，也就是2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>&lt;clinit&gt;()</code>方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成<code>&lt;clinit&gt;()</code>方法。</p>
</li>
<li><p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p>
</li>
<li><p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的<code>&lt;clinit&gt;()</code>方法，其它线程都会阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时的操作，就可能造成多个进程阻塞，在实际过程中此种阻塞很隐蔽。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>sakura腾讯面经</title>
    <url>/posts/406dd90d.html</url>
    <content><![CDATA[<h1 id="实习春招-手Q"><a href="#实习春招-手Q" class="headerlink" title="实习春招 (手Q)"></a>实习春招 (手Q)</h1><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><ul>
<li>自我介绍</li>
<li>在百度实习的经历，然后问我手百的框架，写的需求</li>
<li>HTTPS，对称加密，非对称加密</li>
<li>用过的网络框架 okHttp源码解析</li>
<li>RecycleView的源码</li>
<li>算法题 两数之和</li>
<li>智力题 瓶子从100楼往下扔，一共两个瓶子，问从那个楼扔瓶子刚好碎</li>
<li>Handle源码分析</li>
<li>进程之间如何通信</li>
</ul>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><ul>
<li>自我介绍</li>
<li>百度实习的时候做过的业务</li>
<li>安卓和js的交互方式，那种更好，安全性比较</li>
<li>让我讲了下自己写的unity游戏过程</li>
<li>HTTPS</li>
<li>HashMap 的hash操作和扩容机制</li>
<li>红黑树概念，二叉树遍历</li>
<li>算法题 如何判断一个数是2的次方 如何优化 时间复杂度</li>
<li>快排的思想 如何优化 时间复杂度</li>
<li>JVM 内存模型</li>
<li>GC 机制原理，概念，如何自己用</li>
<li>内存泄漏问题</li>
<li>自定义View</li>
<li>ListView的优化</li>
<li>Glide框架的分析</li>
<li>Binder机制</li>
<li>跨进程通信</li>
<li>网络TCP，网络分层</li>
</ul>
<h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><ul>
<li>自我介绍</li>
<li>讲下写的最好的一个项目</li>
<li>大数据排序</li>
<li>对自己项目的优化方式</li>
<li>百度实习的时候生活和学习</li>
</ul>
<h1 id="2019秋招-csig"><a href="#2019秋招-csig" class="headerlink" title="2019秋招 (csig)"></a>2019秋招 (csig)</h1><h2 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h2><ul>
<li>自我介绍</li>
<li>介绍自己写的需求</li>
<li>自定义view的过程</li>
<li>java线程，安卓线程池</li>
<li>handle</li>
<li>GC，GC的使用方式</li>
<li>四大引用</li>
<li>OkHttp源码</li>
<li>HashMap源码</li>
</ul>
<h2 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h2><ul>
<li>java面向对象的理解 多态的实习 接口和抽象类</li>
<li>c语言和java之间的区别</li>
<li>c语言的指针 指针的指向 指针的指针是啥</li>
<li>堆和栈的区别</li>
<li>设计模式 单例 观察者消费者</li>
<li>java的内存模型</li>
<li>垃圾回收对象 意义 方法 什么时候回收 回收那些 如何判断</li>
<li>java多线程 锁那块了解方式 生产者消费者模型 wait底层怎么实现的 sleep底层怎么实现的</li>
<li>java线程池原理</li>
<li>然后问了部门是干啥的 在哪里 催了下进度</li>
</ul>
<h2 id="三面-1"><a href="#三面-1" class="headerlink" title="三面"></a>三面</h2><ul>
<li>自我介绍</li>
<li>百度实习经历 手百的框架结构</li>
<li>腾讯实习做了什么 需求写了那些 对需求的优化有那些 自己写需求的方案有什么 写需求注意什么</li>
<li>自己游戏项目构架是什么 如何实现爆炸效果的 游戏里面的AI怎么实现的 自己怎么组建游戏团队的 AI怪物具体的算法逻辑是什么 自己游戏如果从新构建要怎么做 如何把unity导入安卓里面 如何和安卓进行交互</li>
<li>flutter动态化方案的实现 自己如何设计的 flutter绘制原理是啥 动态化如何实现的 RN动态化的原理 两种方案的对比 ios那边动态化有方案没 手q开始接入flutter了吗</li>
<li>自己对算法的理解 在公司里面写需求的话 用到了吗 如何优化安卓各自方面 内存泄漏咋处理</li>
<li>对编程语言的理解 dart c java kotlin c++ 有那些区别 编程语言底层实现是什么 为什么有这么多不同语言</li>
<li>讲下自己觉得最有意思的数据结构 // 跳表</li>
<li>觉得什么才是一个程序最重要的地方 如何去设计一个系统 自己怎么下手</li>
<li>家哪里的，为什么选择来北京，腾讯实习最大收获是啥</li>
<li>自己的技术发展方向 如何对自己职业的规划</li>
<li>面试官介绍了下他们团队业务 问我什么时候能实习</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>Kotlin</tag>
        <tag>操作系统</tag>
        <tag>JVM</tag>
        <tag>计组</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-手QAndroid面经</title>
    <url>/posts/9d6997ec.html</url>
    <content><![CDATA[<blockquote>
<p>2020/9/26整理</p>
</blockquote>
<h1 id="客户端0基础的，感觉没问个啥"><a href="#客户端0基础的，感觉没问个啥" class="headerlink" title="客户端0基础的，感觉没问个啥"></a>客户端0基础的，感觉没问个啥</h1><h2 id="一面-2020-8-12"><a href="#一面-2020-8-12" class="headerlink" title="一面/2020-8-12"></a><a href="https://www.nowcoder.com/discuss/473953">一面/2020-8-12</a></h2><ul>
<li>Java相关，Java垃圾回收，Java从编译到加载经过的步骤，Java反射的机制</li>
<li>计算机网络，每层各有什么协议，讲一讲http1.1，http2.0，http3.0各有什么改变，tcp可靠传输，http控制缓存的头部字段，有什么安全威胁。</li>
<li>操作系统，线程与进程，单核处理器怎么实现多线程。</li>
<li>数据库，怎么回滚，怎么优化查询。</li>
<li>向量和链表的使用场景</li>
<li>算法题：从非负无序数组中找到缺失的最小非负整数。</li>
<li>反问：部门做什么业务的。</li>
</ul>
<h2 id="二面-2020-8-20"><a href="#二面-2020-8-20" class="headerlink" title="二面/2020/8/20"></a><a href="https://www.nowcoder.com/discuss/483850">二面/2020/8/20</a></h2><ul>
<li>项目相关</li>
<li>tcp、udp相关，滑动窗口</li>
<li>线程、进程相关，堆栈相关</li>
<li>volatile，synchronized</li>
<li>Object中的方法，equal和hashcode的关系</li>
<li>上线做道题</li>
<li>接雨水那道，我先用单调栈解出来了。</li>
<li>把空间优化，然后我勉勉强强用双指针解出来了。</li>
<li>你对移动客户端了解有多少</li>
<li>以后职业规划，为什么想做客户端</li>
<li>秋招有什么进展。</li>
</ul>
<h2 id="三面-2020-9-2"><a href="#三面-2020-9-2" class="headerlink" title="三面/2020-9-2"></a><a href="https://www.nowcoder.com/discuss/495879">三面/2020-9-2</a></h2><ul>
<li>寒暄一下，base深圳可以吗，为什么不考研，介绍下你的专业，我看你主要用Java的，会c++吗。</li>
<li>本地ide写代码，单链表每k个一翻转，剩余不足k个，保持原位置，自己定义数据结构，自己写测试用例。</li>
<li>Java中软引用，弱引用说一下。垃圾回收说一下。</li>
<li>static修饰的代码块什么时候执行</li>
<li>类加载过程</li>
<li>线程与进程的区别，进程内存中有哪些东西，堆栈有什么区别，哪个效率更高。多线程编程，怎么保证线程同步。</li>
<li>内核态和用户态了解吗，内核态可以访问哪些资源。</li>
<li>网络：MTU了解吗？ping是用到什么协议</li>
<li>数据结构：通讯录程序，打开时，将数据库中的数据读到内存，你用什么数据结构来存，保证查询、添加、删除、排序比较高效。</li>
<li>面试官：我这里给你过了，等hr面吧，哦对了，你是一点都不会c++吗（真不会）</li>
</ul>
<p>总结：问了好多底层，感觉完全脱离了Java技术栈（我好菜）。面了各个大厂的客户端和服务端，我发现，客户端比较喜欢问操作系统的底层包括jvm甚至到汇编层面，服务端喜欢问各种框架中间件数据库linux，当然不管哪个一般都是要来道算法题的。</p>
<h2 id="HR-2020-9-19"><a href="#HR-2020-9-19" class="headerlink" title="HR/2020-9-19"></a><a href="https://www.nowcoder.com/discuss/500049?source_id=profile_create&amp;channel=1009">HR/2020-9-19</a></h2><p>简单的背景调查，具体问题看上面链接</p>
<h1 id="18年的，有点老了，但是可以看下"><a href="#18年的，有点老了，但是可以看下" class="headerlink" title="18年的，有点老了，但是可以看下"></a>18年的，有点老了，但是可以看下</h1><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a><a href="https://www.nowcoder.com/discuss/91873">一面</a></h2><p>问C的有点多，因为是面试官是iOS的</p>
<ul>
<li>谈谈你学习过的架构模式 MVC MVP MVVM</li>
<li>一个Union类型，共有一个int类型、Float、Double类型的字段，请问在32位的CPU创建时需要占用多少字节？</li>
<li>Union和Struct的区别</li>
<li>谈谈你所了解的C语言的内存管理</li>
<li>说说你了解的程序设计模式，知道多少说多少</li>
<li>说说TCP和UDP的区别，你认为QQ的实现是使用TCP还是UDP？</li>
<li>谈谈你了解的C语言的编译过程</li>
<li>进程和线程的区别</li>
<li>谈谈你对Viper架构模式的了解</li>
<li>Fiddler的工作原理解释一下</li>
<li>死锁产生的原因以及解决办法</li>
<li>进程的调度算法有哪些，分别解释一下？</li>
<li>Android程序共享数据的方式有哪些？</li>
<li>Android的性能优化</li>
<li>Handler和HandlerThread的区别</li>
<li>八皇后问题了解过吗？具体怎么实现的？</li>
<li>解释一下异步编程，说说它的应用</li>
<li>Android应用的启动过程</li>
</ul>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><ul>
<li>多线程了解吗？</li>
<li>多线程如何实现通信？</li>
<li>多线程如何实现线程安全？</li>
<li>多线程如何实现同步机制？</li>
<li>进程间的通信方式？</li>
<li>谈谈你对架构模式和设计模式的理解。</li>
<li>现在让你设计一个字典，说一下你的设计思路。</li>
</ul>
<h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><ul>
<li>请你画出MVP架构图，并解释一遍它的运作流程。比如网络操作</li>
<li>解释一下页面展示数据获取的数据来源。</li>
<li>多线程会导致什么问题，应该怎么解决？</li>
<li>Android进程的优先级是怎样的？</li>
<li>说一下Activity的生命周期</li>
<li>onStar和onResume方法的区别是什么？什么时候用onStart，什么时候用onResume.</li>
<li>说一下冒泡排序和选择排序的区别？</li>
<li>冒泡排序最优的时间复杂度？</li>
<li>一棵没有特定顺序的二叉树，如何存放在文件中？</li>
<li>手写代码，给一个int的数组，将其移动k位（使用交换的思想）。如array = [1,2,3,4,5], k = 2, 则移动后的array为[4,5,1,2,3]</li>
<li>设计QQ传文件功能，并画出模块设计图。</li>
<li>说一下防火墙穿越的实现原理</li>
<li>加密算法和加密原理</li>
<li>Https实现原理</li>
<li>手写代码，无限大整数转16进制</li>
<li>讲解一下登陆时密码加密过程</li>
</ul>
<blockquote>
<p>PS:感觉难度好高，都怀疑是社招的</p>
</blockquote>
<hr>
<blockquote>
<p>找不到手Q的了，再总结下腾讯的，可以结合下之前发的牛客网的总结，下面都是网络上的，以CSDN为主</p>
</blockquote>
<h1 id="Android面经-问题归纳"><a href="#Android面经-问题归纳" class="headerlink" title="Android面经| 问题归纳"></a><a href="https://blog.csdn.net/qq_42895379/article/details/89343675">Android面经| 问题归纳</a></h1><h1 id="2020春招PCG"><a href="#2020春招PCG" class="headerlink" title="2020春招PCG"></a><a href="https://blog.csdn.net/qq_40987010/article/details/106844530">2020春招PCG</a></h1><h2 id="简历面-应用宝"><a href="#简历面-应用宝" class="headerlink" title="简历面-应用宝"></a>简历面-应用宝</h2><ul>
<li>String，StringBuffer，StringBuilder哪个是线程安全的？String与StringBuffer内部实现上有什么不同？用的时候怎么选择？</li>
<li>HashMap的内部实现能说一下吗？</li>
<li>单例模式了解吗？线程安全的单例模式说一下</li>
<li>JVM虚拟机的内存分区有哪些？堆和栈的区别？</li>
<li>TCP/UDP的区别？</li>
<li>TCP三次握手和四次挥手过程说一下</li>
<li>HTTP网络请求经过五层的解析，每一层分别是怎么解析的？</li>
<li>Android方面，如何跨进程通信？跨进程通信的方式有哪些？Binder底层原理说一下</li>
<li>跨线程怎么通信？</li>
<li>那消息队列了解过吗，谈谈其内部实现原理？Handler的创建和MessageQueue/Looper有什么联系？</li>
<li>内存泄露的原因说一下，怎么检测内存泄漏？有没有使用一些工具检测内存泄漏的经验？</li>
<li>知道设计模式吗？说一些你用过的设计模式</li>
<li>View的绘制过程你了解过吗？说一下</li>
<li>当用户手指点击屏幕的时候，会产生什么事件？，onClick()方法在什么事件触发，在哪个地方调用</li>
</ul>
<h2 id="一面-应用宝"><a href="#一面-应用宝" class="headerlink" title="一面-应用宝"></a>一面-应用宝</h2><ul>
<li>HashMap了解吗？说说内部实现原理</li>
<li>java四类的线程池是哪四类？分别介绍下</li>
<li>java四钟引用类型</li>
<li>单例模式介绍下</li>
<li>GC机制垃圾回收算法有哪些？</li>
<li>说一下分代收集算法的详细过程</li>
<li>TCP三次握手与四次挥手</li>
<li>Android跨进程通信方式有哪些</li>
<li>Android跨线程方式有哪些</li>
<li>消息队列实现原理介绍下</li>
<li>内存泄漏的原因说一下，用过什么工具检测内存泄漏？线上的工具用过吗</li>
<li>View绘制的原理了解吗？介绍下</li>
<li>了解过设计模式吗？说说你常用的设计模式有哪些</li>
<li>ListView和RecyclerView的区别了解吗？说说RecyclerView的缓存机制</li>
<li>View事件的分发机制知道吗？</li>
<li>组件化和热修复，你了解过这些技术吗</li>
<li>Flutter你研究过吗</li>
<li>有什么问题想问我的？</li>
</ul>
<h2 id="二面-应用宝"><a href="#二面-应用宝" class="headerlink" title="二面-应用宝"></a>二面-应用宝</h2><ul>
<li>上来先和我聊十来分钟的项目经历，项目的问题就因人而异了，没有参考价值，就不放出来了</li>
<li>Mysql联合主键在什么情况下会失效，达不到快速索引的效果？</li>
<li>Linux了解吗？<br>只会使用命令，没深入了解过（？？？懵逼状态2）</li>
<li>考虑10亿条数据，里面存储的都是数字，要你设计一个思路，找出里面相同的数</li>
<li>什么时候能来实习，能实习多久？</li>
<li>你有什么想问我的</li>
</ul>
<h2 id="GM-应用宝"><a href="#GM-应用宝" class="headerlink" title="GM-应用宝"></a>GM-应用宝</h2><ul>
<li>你提到你之前负责过4个月的后端开发，是什么让你转到了现在的客户端开发？</li>
<li>你从现在到以后的职业发展规划？</li>
<li>Android你主要是对应用层像View动画这方面了解多一点，还是对Android底层这方面了解多点？</li>
<li>你底层代码看过些什么？<ul>
<li>把我最近看过了底层知识都列举了一遍，View事件分发机制，View重绘机制，消息队列，Binder工作原理，Android四大组件的工作过程什么的。</li>
</ul>
</li>
<li>那你说说消息队列怎么实现的吧</li>
</ul>
<h1 id="2020春招IEG"><a href="#2020春招IEG" class="headerlink" title="2020春招IEG"></a><a href="https://blog.csdn.net/qq_40987010/article/details/106861169">2020春招IEG</a></h1><h2 id="一面-1"><a href="#一面-1" class="headerlink" title="一面-"></a>一面-</h2><ul>
<li>学校有哪些专业课，说一下？学过哪些语言？</li>
<li>了解数据结构吗？说说有哪些数据结构？</li>
<li>HashMap内部实现是怎么样的？扩容机制是咋样的？ArrayList的扩容机制呢？</li>
<li>数组和列表的区别是什么？ArrayList和LinkedList的区别？</li>
<li>双向链表怎么判断形成了环路？如果用代码实现怎么判断？</li>
<li>问个算法题，如何合并两个有序的数组，然后输出新的数组，思路说一下，用本地IDE敲一下吧</li>
<li>问下计算机网络基础吧，TCP/UDP的区别是啥？UDP的应用场景？</li>
<li>OSI五层协议分别是哪些？TCP是第几层协议，HTTP呢？HTTP协议与TCP协议的关系</li>
<li>get/post请求的区别？</li>
<li>响应状态码：1-5开头的状态码分别表示什么意思？206状态码知道什么意思吗？404知道吗？</li>
<li>你是用JAVA多点吧？问些JAVA基础，垃圾回收机制知道多少？介绍一遍</li>
<li>泛型用过吗？你是怎么用泛型的？</li>
<li>问些安卓方面的问题吧，安卓四大组件分别是哪些？</li>
<li>Activity的生命周期说一遍？当用户按下home键时，Activity会经过哪些生命周期？如果是从一个Activity切换到另一个Activity呢</li>
<li>消息队列知道吗？介绍下内部原理</li>
<li>WebView知道吗？</li>
</ul>
<h2 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h2><ul>
<li>先做个简短的自我介绍吧</li>
<li>你简历上提到了2个项目，你能先和我详细介绍下你的第二个项目吗？（接下来就是项目问题了，主要问项目主要是实现了什么功能，怎么实现的？项目架构是咋样的，项目大概问了15分钟吧）</li>
<li>你项目用到了FFMPEG来实时推流，那FFMPEG内部的实现原理那些你去了解过吗？（这里我回答说我在写这个项目的时候看过，只是时间太久远了，很久没看过这部分，所以现在也忘得差不多了）</li>
<li>你项目用WebSocket来全双工通讯，那WebSocket能给我介绍下吗，Websocket和Http的联系？它是基于TCP协议还是UDP协议？它是长连接的话，服务器如何保活？</li>
<li>了解linux吗，知道linux…（linux我不熟，只知道命令，所以这部分跳了）</li>
<li>Mysql知道吗？索引是用来干啥的？Mysql是怎么通过索引快速查找元素的？</li>
<li>什么时候会触发操作系统的分页机制？</li>
<li>进程和线程的区别？守护线程是什么线程？</li>
<li>快排的时间复杂度是多少？它是稳定排序吗？为什么不稳定？</li>
<li>说说你用过的集合，都有哪些集合？TreeMap看过吗？和HashMap的区别？</li>
<li>JVM内存分区中，堆和栈的区别？</li>
<li>有过并发的经验吗？线程池的工作流程说一下</li>
</ul>
<h1 id="腾讯文档2020"><a href="#腾讯文档2020" class="headerlink" title="腾讯文档2020"></a><a href="https://www.nowcoder.com/discuss/475087">腾讯文档2020</a></h1><h2 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h2><ul>
<li>算法题：假期、翻转数列，还有一个名字忘了，但其实就是写个快排</li>
<li>快速排序的优化方法(提示基准值)</li>
<li>Java底层了解什么？</li>
<li>Java程序执行的是什么？</li>
<li>JVM内存结构</li>
<li>多线程需要注意什么？(细讲了java中的锁机制)</li>
<li>详细讲一下项目</li>
<li>项目中担任的角色</li>
<li>各种实现的细节</li>
<li>多线程修改UI怎么处理</li>
<li>每个项目都可以讲一讲…</li>
<li>Java中各种数据结构的实现(细讲了HashMap原理)</li>
<li>各层熟悉的协议讲一讲(HTTP, DNS, TCP, UDP, ICMP, ARP…)</li>
<li>还有什么你了解的我们没问的？(操作系统：中断, 进程调度, 分页分段, 虚拟内存…)</li>
</ul>
<h2 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h2><ul>
<li>讲了两个项目，问了多线程的细节</li>
<li>Synchronize和volatile</li>
<li>sleep和wait的区别</li>
<li>生产者消费者模型，java中的三种实现</li>
<li>JVM内存结构</li>
<li>OOM发生的位置，原因</li>
<li>知道哪些设计模式，项目里用过吗</li>
<li>三次握手四次挥手</li>
<li>TCP和UDP的区别</li>
<li>HTTPS流程</li>
<li>HTTPS是绝对安全的吗</li>
<li>Hashmap的实现</li>
<li>有一个生成[1, 5]随机整数的函数，利用它设计一个生成[1, 7]随机数的函数。</li>
</ul>
<h2 id="CTO-应该是指GM吧"><a href="#CTO-应该是指GM吧" class="headerlink" title="CTO(应该是指GM吧)"></a>CTO(应该是指GM吧)</h2><ul>
<li>先自我介绍，大概了解了一下之后，先聊了项目，然后问了一些基础问题。基础问题大概有这几个内容：</li>
<li>java垃圾回收</li>
<li>TCP握手挥手</li>
<li>HTTP报文格式</li>
<li>深度优先、广度优先</li>
</ul>
<h1 id="腾讯PCG事业群-春招3月-但是原本是做Java的"><a href="#腾讯PCG事业群-春招3月-但是原本是做Java的" class="headerlink" title="腾讯PCG事业群-春招3月,但是原本是做Java的"></a><a href="https://blog.csdn.net/weixin_40992982/article/details/105141252">腾讯PCG事业群-春招3月,但是原本是做Java的</a></h1><h2 id="一面-3"><a href="#一面-3" class="headerlink" title="一面"></a>一面</h2><ul>
<li>自我介绍</li>
<li>我看你这简历上的技能咋都写的是Java的东西呢？安卓的项目做过，SSM的也做过，那你后台开发和Android倾向于哪一个？<ul>
<li>主要准备的Java，Android没有具体学习过，但是对Android很感兴趣。</li>
</ul>
</li>
<li>你咋选的实习地方北京，能来深圳实习嘛？</li>
<li>说说项目，我看你上面有个项目做App的，有准备Android方面吗?</li>
<li>有些SQL比较慢，你咋办？为什么有的SQL这么慢，说说你觉得导致SQL很慢的原因。</li>
<li>内存泄漏？OOM？什么情况会OOM？</li>
<li>用过多线程没？说说咋用的。线程池知道不？说说线程池的原理？</li>
<li>对ArrayList一个读操作，一个写操作，你用多线程咋实现。死锁你知道不？你怎么解决？</li>
<li>volatile知道吗？volatile的原子性？</li>
<li>Java中的锁知道哪些？</li>
<li>线程之间通信的方式？</li>
<li>JVM调优，说说你能从哪些方面着手？</li>
<li>JVM和GC简单聊聊，结合JVM内存说说GC。</li>
<li>HashMap和HastTable，HashMap安全？不安全用什么？hash()？HashTable是怎么实现安全的？</li>
<li>我对你的Java基础有了一个了解了，下面我们问问网络相关的知识，计算机网络应该学过吧，那说说TCP三次握手？第三次握手能不能去掉？UDP和TCP的区别？</li>
<li>你知道长连接吗，说说？为啥用长连接？</li>
<li>HTTP1.0和HTTP2.0的区别？说说NIO？</li>
<li>HTTPS知道吗？说说SSL？</li>
<li>好了，网络聊到这里吧，我们说说算法之类的吧。跳台阶知道吧，怎么做啊。<ul>
<li>一个链表，让你找最中间的节点，你怎么找？</li>
<li>两个大文件，一个比较大，一个比较小，让你求交集，你怎么做？</li>
</ul>
</li>
<li>那么，我们再问两个智力题吧，没有固定答案，不要限制自己的思路，想到啥说啥，一个粗细不一样的绳子，完整的烧完1个小时，你怎么让他烧15分钟（不一定烧完）。</li>
<li>一副全新的扑克牌，按顺序的，AAAA，2222，3333，这种，你怎么洗牌能洗散开？</li>
<li>C++和C了解吗？</li>
</ul>
<h2 id="二面-3"><a href="#二面-3" class="headerlink" title="二面"></a>二面</h2><p>算法题</p>
<h2 id="三面-1"><a href="#三面-1" class="headerlink" title="三面"></a>三面</h2><ul>
<li>面试官上来又是一通确认身份，然后再次确认实习地有没有要求？深圳确实没啥问题是吧？？？</li>
<li>说说JVM的内存吧，他们都是干啥的？对象怎么创建？</li>
<li>每个区域都会发生怎样的异常啊，谁会发生OOM？</li>
<li>说说你对GC的认识吧。</li>
<li>知道引用计数法吗？引用计数法有啥优点吗？缺点呢？</li>
<li>可达性分析？</li>
<li>垃圾回收的几种算法？比较一下。</li>
<li>你觉得垃圾回收有什么缺点？</li>
<li>说说垃圾收集器？有没有想过你说的这些垃圾收集器为啥会有这些缺点呢？</li>
<li>关于垃圾回收和JVM问的很详细很详细，有的问题记不太清了…</li>
<li>那我们再说说链表和数组？比较一下它们有啥区别吧，然后再说说数组里面删除一个元素会怎么样，插入一个元素会怎么样，修改一个元素会怎么样，会发生什么事情？</li>
<li>平时用啥IDE？知道项目run之前干什么吗？<ul>
<li>说了个编译和检查错误，但是面试官似乎还想让我说点东西…</li>
</ul>
</li>
<li>编译期和运行期的区别？</li>
<li>指针了解吗？</li>
<li>十亿个数，一个数4字节，然后你怎么找最大的十个数？十亿个数，占多少内存？</li>
<li>操作系统中有哪些内存知道吗？平时用什么Windows还是Linux？</li>
<li>说说寄存器？</li>
<li>了解编译原理吗？知道计算机组成原理吗？平时都学什么课？</li>
<li>一个人给另一个人发微信消息，说说可能会发生哪些事情？</li>
<li>长连接短连接说说区别，你知道的哪些是长连接，哪些是短连接?TCP是短连接还是长连接吗？</li>
<li>http是基于什么实现的？1.0和1.1什么区别？</li>
<li>MTU知道吗？以太网帧知道不？MTU大小你知道不？MTU的组成你知道不？</li>
<li>TCP和UDP是否可靠，为什么不可靠or为什么可靠？</li>
<li>如果客户端长时间不发消息，那服务器端咋办？【差不多这个意思…】</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>Kotlin</tag>
        <tag>操作系统</tag>
        <tag>JVM</tag>
        <tag>计组</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>百度面试题总结</title>
    <url>/posts/5c3dbcbd.html</url>
    <content><![CDATA[<h1 id="1-第一份"><a href="#1-第一份" class="headerlink" title="1. 第一份"></a>1. 第一份</h1><ol>
<li>算法：链表的逆置<br>算法思路不正确</li>
<li>Java线程池<br>照着源码讲了一遍<br>追问：LinkedBlockingQueue有什么作用？<br>讲的不清楚<br>追问：线程同步有什么办法？<br>只回答了锁<br>追问：锁有哪些？可用于什么场景？<br>synchronized、lock、可重用锁、CAS<br>基本原理回答正确，但不清楚具体场景  </li>
<li>ThreadLocal作用<br>不清楚</li>
<li>Handler使用的时候需要注意什么问题？<br>内存泄露<br>内部类、弱引用，静态内部类<br>onDestroy移除消息<br>追问：Handler都能干什么事？<br>卡顿丢帧检测</li>
<li>Java里面的几种引用区别？使用场景<br>原理回答正确，使用场景理解不够深入</li>
<li>卡顿检测和优化<br>检测方法：BlockCanary、TraceView、屏幕刷新机制<br>造成卡顿的原因回答正确<br>优化：扁平化布局、过渡绘制、刷新次数区域控制<br>主线程耗时操作、SP初始化、不要放大对象，不要频繁提交，减少IO操作<br>自定义View的onDraw方法</li>
<li>SP内部数据结构<br>XML文件，map kv形式<br>追问：线程安全吗？<br>回答正确<br>追问：进程安全吗？<br>不安全<br>追问：怎么保证进程安全？<br>包一层ContentProvider<br>追问：用SQLite可以吗？为什么<br>应该可以</li>
<li>进程间通信的办法<br>AIDL，Binder，除了Binder不知道其他的</li>
<li>LruCache<br>基本原理回答正确<br>追问：get/put方法设计的时候需要注意什么问题？<br>LinkedHashMap不安全，加同步锁</li>
<li>HTTPS<br>基本流程正确，但不完善，不知道如何优化</li>
<li>Kotlin遇到的坑？<br>没遇到什么坑，只觉得有好处<br>追问：有什么好处<br>简洁、语法糖<br>追问：object和compaion object区别<br>回答的比较片面<br>追问：object实现单例的原理<br>回答错误</li>
</ol>
<h1 id="2-第二份"><a href="#2-第二份" class="headerlink" title="2. 第二份"></a>2. 第二份</h1><ol>
<li>2sum算法<br>给出了双重循环的办法，但算法不完善<br>追问：是否有更快的办法？<br>没想法</li>
<li>I am a student变成student a am I<br>没想法</li>
<li>Java的HashMap的哈希冲突<br>回答正确<br>追问：HashMap和HashTable，ConcurrentHashMap<br>回答正确，对比详细</li>
<li>LinkedBlockQueue的作用<br>基本原理回答正常，使用场景基本正确 </li>
<li>ThreadLocal作用，使用时需要注意什么问题？<br>基本原理回答正确<br>注意的问题：内存泄露相关，具体说的不太清楚</li>
<li>几种引用形式的区别<br>内存控制上的区别回答正确、详细<br>追问：具体使用场景<br>能答出Weak的使用场景</li>
<li>Bitmap使用的时候注意的问题<br>颜色配置、过大（缩放、BitmapFactory、option）、及时recycle<br>追问：Recycle了怎么办？<br>磁盘缓存<br>追问：Bitmap的OOM避免<br>能说出基本的<br>追问：Android 6.0和9.0上的Bitmap加载有什么区别<br>基本方向正确，但不完全正确<br>追问：565和8888区别<br>占用空间问题，透明度信息<br>追问：Bitmap在Android上变绿的问题，原因、解决？<br>不了解</li>
<li>MessageQueue<br>Java层回答比较详细<br>追问：死循环为什么不会阻塞主线程？<br>回答错误<br>追问：操作系统上对应什么IO复用模型？<br>不太清楚</li>
<li>图片加载框架的节流设计<br>按需加载，其他不了解，提示了以后，webp<br>追问：怎么知道缓存？<br>不清楚<br>追问：其他节流格式<br>回答不完全正确<br>追问：png和jpeg区别<br>不清楚</li>
<li>ConstraintLayout、LinearLayout、FrameLayout、RelativeLayout性能&amp;使用场景<br>基本测量、layout原理对比回答正确<br>使用场景回答比较抽象，不是很具体<br>追问：列表卡顿优化<br>注意onDraw方法、避免重复创建<br>追问：结合以上几种Layout<br>需要看具体使用场景，基本方向正确，但不是很具体</li>
<li>http2<br>不太清楚</li>
<li>HTTP状态码<br>301、302区别：不清楚<br>404、403区别：404回答基本正确、403不清楚</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>Kotlin</tag>
        <tag>操作系统</tag>
        <tag>JVM</tag>
        <tag>计组</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯2020年秋招牛客网面经总结</title>
    <url>/posts/702658f4.html</url>
    <content><![CDATA[<blockquote>
<p>记录了牛客网面经专区，从2020/4/22到2020/9/16的面经</p>
</blockquote>
<h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><ol>
<li>activity和application有什么区别</li>
<li>生命周期（*）</li>
<li>启动模式（*）</li>
<li>初始化数据应该在onCreate还是onStart——onCreate</li>
<li>activity和fragment通信（*）<ol>
<li>文件</li>
<li>handler</li>
<li>attach回调</li>
<li>eventbus</li>
<li>bundle</li>
</ol>
</li>
<li>fragment和activity有什么区别</li>
<li>activity和window关系</li>
<li>Activity、View、Surface、SurfaceView之间的联系</li>
</ol>
<h3 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h3><ol>
<li>静态广播和动态广播区别？</li>
<li>有序广播的应用</li>
</ol>
<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><ol>
<li>服务start和bind区别</li>
</ol>
<h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><ol>
<li>讲一下View的绘制，performMeasure是哪个调用的（*）</li>
<li>Draw和onDraw什么区别</li>
<li>自定义view需要干什么</li>
<li>View事件分发机制原理（*）</li>
<li>安卓动画有哪些</li>
<li>ListView缓存，有没有想过ListView是怎么实现的</li>
<li>RecyclerView瀑布流</li>
<li>RecyclerView缓存（详细讲）</li>
<li>RecyclerView性能优化</li>
<li>如何自己设计一个RecyclerView。。。</li>
<li>数据错乱处理方式</li>
<li>为什么不用notifiChangeAll()</li>
<li>知道DiffUtil吗，源码</li>
</ol>
<h3 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h3><ol>
<li>图片如何高效加载</li>
<li>设计一个图片加载框架，怎么做</li>
<li>缓存有没有做过呢</li>
<li>DiskLrucache 缓存</li>
<li>批量加载图片怎么做</li>
<li>LRU算法是什么？用在什么场景？简述软件和硬件实现方法？</li>
</ol>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ol>
<li>数据存储有学过吗？数据库和文件保存有什么区别？（*）</li>
<li>android怎么实现多进程通信<img src="https://uploadfiles.nowcoder.com/images/20200515/987124751_1589474702275_090C018F8472A332C47E28C3B3292C62" alt=""></li>
</ol>
<h2 id="框架源码"><a href="#框架源码" class="headerlink" title="框架源码"></a>框架源码</h2><h3 id="Handler（-）"><a href="#Handler（-）" class="headerlink" title="Handler（**）"></a>Handler（<em>**</em>）</h3><ol>
<li>Handler机制</li>
<li>能否让message被push到非主线程的线程里？（提示looper)</li>
<li>threadLocal的原理</li>
<li>looper 为什么设计成死循环</li>
<li>looper死循环为什么不会阻塞主线程</li>
<li>如果在looper中加很多延时命令， 会阻塞吗</li>
<li>是否可以阻塞，如何阻塞</li>
<li>Handler引起的内存泄露怎么解决，软引用，弱引用具体使用场景</li>
<li>两个子线程之间可以通过Handler传递消息吗</li>
<li>MessageQueue的数据结构，为什么是链表不是队列</li>
</ol>
<h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder(-)"></a>Binder(-)</h3><ol>
<li>Linux的进程通信机制，android的进程通信机制</li>
<li>bundle</li>
</ol>
<h3 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h3><ol>
<li>okhttp</li>
</ol>
<h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><ol>
<li>eventbus</li>
</ol>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ol>
<li>内存泄漏的场景和解决方法（*）</li>
<li>单元测试了解吗</li>
<li>内存泄漏 有没有解决办法<ol>
<li>Activity—》onDestory()</li>
<li>弱应用 弱引用的具体实现</li>
</ol>
</li>
<li>安卓11 有哪些新特性</li>
<li>mvc MVP mvvm 区别</li>
<li>安卓变得越来越流畅，你知道底层角度安卓系统做了哪些工作吗 ？？？</li>
</ol>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><ol>
<li>java基本数据类型说一下，long最大值多少</li>
<li>String字符串实际对象的问题（*）</li>
<li>String str = “123” + “456”;会创建几个对象。</li>
<li>我看你代码题里用了 StringBuilder，那你说下 StringBuilder 和 StringBuffer</li>
<li>string stringbuilder stringbuffer有啥区别？</li>
<li>==和equal区别，hashcode何时需要被重写</li>
<li>java中的异常处理（答了try catch）</li>
<li>四种引用的特点（<em>**</em>）</li>
<li>重写和重载的区别</li>
<li>内部类</li>
<li>知道int和INT的区别吗？bool和BOOL的区别呢？（？？？？啥玩意）int和integer的区别？（应该是想问包装类吧）</li>
<li>序列化（Serilizable和Parcelable）</li>
<li>函数一直递归会有什么影响？（栈溢出？）如果不传参，栈还会溢出吗</li>
</ol>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ol>
<li>ArrayList 和 LinkedList（<em>**</em>）</li>
<li>HashMap 和 CurrentHashMap</li>
<li>get的时间复杂度</li>
<li>如何优化冲突</li>
<li>List,Set,Map什么区别，ArrayList, LinkedList区别</li>
<li>HashMap原理，为什么每次扩容都是2的倍数，为什么由头插改成了尾插，环化是怎么引起的（<em>**</em>）</li>
</ol>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ol>
<li>Java 里有哪些加锁的方式（*）</li>
<li>Java 的线程池参数怎么设置</li>
<li>加两次锁会死锁吗</li>
<li>sleep和wait的区别，为什么前者在object类中而后者不在（*）</li>
<li>volatile和synchronized的区别，他们的实现原理是什么（*）</li>
<li>volatile用来干嘛的？</li>
</ol>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ol>
<li>jvm内存模型（2）</li>
<li>创建一个字符串对象，这个对象分配在哪里</li>
<li>堆栈内存具体是怎么申请的</li>
<li>是否了解反射，背后的机制是否了解</li>
<li>类加载机制</li>
<li>注解，反射机制的原理</li>
<li>垃圾回收原理以及算法</li>
<li>GC的标记算法种类，引用计数法的问题怎么解决</li>
<li>GC，FullGC什么时候会触发</li>
</ol>
<h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><p>在浏览器输入百度然后回车之后的整个过程（详细到协议层都发生了什么）</p>
<h2 id="TCP-UDP（-）"><a href="#TCP-UDP（-）" class="headerlink" title="TCP/UDP（*）"></a>TCP/UDP（*）</h2><ol>
<li>断点重传</li>
<li>TCP和UDP区别</li>
<li>Tcp特点</li>
<li>TCP的可靠性和拥塞控制</li>
<li>TCP如何保证可靠</li>
<li>三握四挥</li>
<li>为什么是三次握手，两次不行吗</li>
<li>UDP怎么变可靠，应用场景，Udp(游戏，视频，其中音频不可以）</li>
</ol>
<h2 id="http-https（-）"><a href="#http-https（-）" class="headerlink" title="http/https（*）"></a>http/https（*）</h2><ol>
<li>HTTP和HTTPS,怎么加密的</li>
<li>http和https的区别</li>
<li>https安全吗？提到了第三方证书</li>
<li>http1.0 1.1 2.0 区别</li>
<li>http1.0 1.1 2.0 解决了什么问题</li>
</ol>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><ol>
<li>https能不能防dns劫持？</li>
<li>dns劫持该怎么办</li>
</ol>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><ol>
<li>线程和进程（*）</li>
<li>进程的调度算法</li>
<li>进程之间的通信方法(IPC)</li>
<li>线程的各种状态有什么？</li>
<li>线程的同步方法</li>
<li>死锁是什么，遇到过吗</li>
<li>操作系统中异常是怎么处理的（1）</li>
<li>操作系统中的中断（1）</li>
<li>32位的操作系统能存多大的数据（1）</li>
<li>虚拟内存是什么</li>
<li>虚拟地址到物理地址</li>
</ol>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><ol>
<li>快排和堆排的原理</li>
</ol>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ol>
<li>是否了解设计模式和面向对象原则？讲一讲项目中用到的设计模式（讲了观察者和单例还有工厂）还问了怎么样算一个好的接口：函数名要明确、函数职责明确、有标准的输入输出这一点没有答上来，原来面试官想问的是边界测试的问题</li>
<li>单例，单例有多少种写法</li>
</ol>
<h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><ol>
<li>第k大的数(2)</li>
<li>反转链表（2）</li>
<li>二叉树遍历（3）</li>
<li>给两个字符串a,b，判断a中是否包含了b的所有字符</li>
<li>版本号比较大小</li>
<li>生成长度为N的随机数组</li>
<li>最小的k个数</li>
<li>大数相加（注意：带正负号的情况；再注意：带小数的情况）</li>
<li>一个字符串里面，最长不重复字符的长度</li>
<li>括号匹配</li>
<li>计算0~n（不包含1）之间，所有的3和5的倍数的和。如n=10，输出3+5+6+9=23</li>
<li>正负数交替排列，找和最大的子序列</li>
<li>链表有环</li>
<li>接雨水</li>
<li>二叉树结点最近公共祖先</li>
<li>最长公共子串长度</li>
<li>两个无序数组，每个数组中的元素都是唯一，多种方法找出二者重复的元素</li>
<li>求最大公约数</li>
<li>2数之和</li>
<li>两个数组合并，有序输出。不去重</li>
<li>删除无序链表中的重复结点（能否优化）</li>
</ol>
<h1 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h1><ol>
<li>1000 杯水，有一杯有毒，小鼠喝下后1小时死亡，现在有 10 只小鼠，怎么在 1 小时内找出有毒的那杯水</li>
</ol>
<h1 id="社招面经"><a href="#社招面经" class="headerlink" title="社招面经"></a>社招面经</h1><blockquote>
<p>可以看下，不难，跟咱们面试差不多。<br>有一说一，工作1-3年内的社招面试题真的不难</p>
</blockquote>
<p><a href="https://www.nowcoder.com/discuss/447563">腾讯Android岗社招面筋分享</a><br><a href="https://www.nowcoder.com/discuss/414580">记百度腾讯oppo的Android社招面经</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>Kotlin</tag>
        <tag>操作系统</tag>
        <tag>JVM</tag>
        <tag>计组</tag>
        <tag>计网</tag>
      </tags>
  </entry>
</search>
